Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    BACKSLASH
    BOOLEAN
    BREAK
    CASE
    CLASS
    COMMENTS
    DEFAULT
    DIFERENTE
    DIVIGUAL
    DOUBLE_QUOTES
    FLOAT
    FOR
    FUNCTION
    IGUALIGUAL
    INT
    LENGTH
    LINE_BREAK
    LONGCOMMENT
    MASIGUAL
    MAYORIGUALQUE
    MAYORQUE
    MENORIGUALQUE
    MENORQUE
    MENOSIGUAL
    MODIGUAL
    NOT
    NULL
    OR
    POINT
    PORIGUAL
    POTIGUAK
    RETURN
    SET
    SINGLE_QUOTE
    STATIC
    SWITCH
    THEN
    TOSTRING
    TYPEOF
    UNDEFINED

Grammar

Rule 0     S' -> expression
Rule 1     expression -> variable
Rule 2     expression -> variable expression
Rule 3     expression -> dataStruct
Rule 4     expression -> dataStruct expression
Rule 5     expression -> controlStruct
Rule 6     expression -> controlStruct expression
Rule 7     variable -> type NAME IGUAL datatype SEMICOLON
Rule 8     variable -> type NAME IGUAL operations SEMICOLON
Rule 9     variable -> NAME IGUAL datatype SEMICOLON
Rule 10    controlStruct -> while
Rule 11    controlStruct -> if
Rule 12    dataStruct -> array
Rule 13    dataStruct -> map
Rule 14    while -> WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
Rule 15    while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
Rule 16    if -> soloIf
Rule 17    if -> soloIf elseIf
Rule 18    if -> soloIf elseIf else
Rule 19    if -> soloIf else
Rule 20    soloIf -> IF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
Rule 21    elseIf -> ELSEIF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
Rule 22    elseIf -> ELSEIF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf
Rule 23    else -> ELSE OPEN_BRACE expression CLOSE_BRACE
Rule 24    operations -> NUMBER operand NUMBER
Rule 25    datatype -> NUMBER
Rule 26    datatype -> STRING
Rule 27    datatype -> CHAR
Rule 28    operand -> SUMA
Rule 29    operand -> RESTA
Rule 30    operand -> MULTIPLICACION
Rule 31    operand -> DIVISION
Rule 32    bool -> TRUE
Rule 33    bool -> FALSE
Rule 34    type -> CONST
Rule 35    type -> LET
Rule 36    type -> VAR
Rule 37    array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
Rule 38    array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
Rule 39    map -> iniciarMap
Rule 40    map -> escribirMap
Rule 41    map -> generarMap
Rule 42    iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
Rule 43    escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
Rule 44    claveValor -> clave COLON valor
Rule 45    claveValor -> clave COLON valor COMMA claveValor
Rule 46    clave -> datatype
Rule 47    valor -> datatype
Rule 48    valor -> dataStruct
Rule 49    generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
Rule 50    tuplas -> tupla
Rule 51    tuplas -> tupla tuplas
Rule 52    tupla -> OPEN_BRACKET datatype CLOSE_BRACKET
Rule 53    tupla -> OPEN_BRACKET datatype COMMA datatype CLOSE_BRACKET
Rule 54    items -> numeros
Rule 55    items -> cadena
Rule 56    numeros -> NUMBER
Rule 57    numeros -> NUMBER COMMA numeros
Rule 58    cadena -> STRING
Rule 59    cadena -> STRING COMMA cadena

Terminals, with rules where they appear

AND                  : 
ARRAY                : 38
BACKSLASH            : 
BOOLEAN              : 
BREAK                : 
CASE                 : 
CHAR                 : 27
CLASS                : 
CLOSE_BRACE          : 14 15 20 21 22 23 43 49
CLOSE_BRACKET        : 37 52 53
CLOSE_PARENTHESIS    : 14 15 20 21 22 38 42
COLON                : 44 45
COMMA                : 45 53 57 59
COMMENTS             : 
CONST                : 34
DEFAULT              : 
DIFERENTE            : 
DIVIGUAL             : 
DIVISION             : 31
DOUBLE_QUOTES        : 
ELSE                 : 23
ELSEIF               : 21 22
FALSE                : 33
FLOAT                : 
FOR                  : 
FUNCTION             : 
IF                   : 20
IGUAL                : 7 8 9 37 38 42 43 49
IGUALIGUAL           : 
INT                  : 
LENGTH               : 
LET                  : 35
LINE_BREAK           : 
LONGCOMMENT          : 
MAP                  : 42
MASIGUAL             : 
MAYORIGUALQUE        : 
MAYORQUE             : 
MENORIGUALQUE        : 
MENORQUE             : 
MENOSIGUAL           : 
MODIGUAL             : 
MULTIPLICACION       : 30
NAME                 : 7 8 9 37 38
NEW                  : 38 42
NOT                  : 
NULL                 : 
NUMBER               : 24 24 25 56 57
OPEN_BRACE           : 14 15 20 21 22 23 43 49
OPEN_BRACKET         : 37 52 53
OPEN_PARENTHESIS     : 14 15 20 21 22 38 42
OR                   : 
POINT                : 
PORIGUAL             : 
POTIGUAK             : 
RESTA                : 29
RETURN               : 
SEMICOLON            : 7 8 9 37 38 42
SET                  : 
SINGLE_QUOTE         : 
STATIC               : 
STRING               : 26 58 59
SUMA                 : 28
SWITCH               : 
THEN                 : 
TOSTRING             : 
TRUE                 : 32
TYPEOF               : 
UNDEFINED            : 
VAR                  : 36
WHILE                : 14 15
error                : 

Nonterminals, with rules where they appear

array                : 12
bool                 : 15 20 21 22
cadena               : 55 59
clave                : 44 45
claveValor           : 43 45
controlStruct        : 5 6
dataStruct           : 3 4 48
datatype             : 7 9 46 47 52 53 53
else                 : 18 19
elseIf               : 17 18
escribirMap          : 40
expression           : 2 4 6 14 14 15 20 21 22 23 0
generarMap           : 41
if                   : 11
iniciarMap           : 39
items                : 37 38
map                  : 13
numeros              : 54 57
operand              : 24
operations           : 8
soloIf               : 16 17 18 19 22
tupla                : 50 51
tuplas               : 49 51
type                 : 7 8 37 38
valor                : 44 45
variable             : 1 2 42 43 49
while                : 10

Parsing method: LALR

state 0

    (0) S' -> . expression
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) variable -> . type NAME IGUAL datatype SEMICOLON
    (8) variable -> . type NAME IGUAL operations SEMICOLON
    (9) variable -> . NAME IGUAL datatype SEMICOLON
    (12) dataStruct -> . array
    (13) dataStruct -> . map
    (10) controlStruct -> . while
    (11) controlStruct -> . if
    (34) type -> . CONST
    (35) type -> . LET
    (36) type -> . VAR
    (37) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (38) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (39) map -> . iniciarMap
    (40) map -> . escribirMap
    (41) map -> . generarMap
    (14) while -> . WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (15) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (16) if -> . soloIf
    (17) if -> . soloIf elseIf
    (18) if -> . soloIf elseIf else
    (19) if -> . soloIf else
    (42) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (43) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (49) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (20) soloIf -> . IF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    NAME            shift and go to state 6
    CONST           shift and go to state 11
    LET             shift and go to state 12
    VAR             shift and go to state 13
    WHILE           shift and go to state 17
    IF              shift and go to state 19

    expression                     shift and go to state 1
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    type                           shift and go to state 5
    array                          shift and go to state 7
    map                            shift and go to state 8
    while                          shift and go to state 9
    if                             shift and go to state 10
    iniciarMap                     shift and go to state 14
    escribirMap                    shift and go to state 15
    generarMap                     shift and go to state 16
    soloIf                         shift and go to state 18

state 1

    (0) S' -> expression .



state 2

    (1) expression -> variable .
    (2) expression -> variable . expression
    (42) iniciarMap -> variable . IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (43) escribirMap -> variable . IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (49) generarMap -> variable . IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) variable -> . type NAME IGUAL datatype SEMICOLON
    (8) variable -> . type NAME IGUAL operations SEMICOLON
    (9) variable -> . NAME IGUAL datatype SEMICOLON
    (12) dataStruct -> . array
    (13) dataStruct -> . map
    (10) controlStruct -> . while
    (11) controlStruct -> . if
    (34) type -> . CONST
    (35) type -> . LET
    (36) type -> . VAR
    (37) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (38) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (39) map -> . iniciarMap
    (40) map -> . escribirMap
    (41) map -> . generarMap
    (14) while -> . WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (15) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (16) if -> . soloIf
    (17) if -> . soloIf elseIf
    (18) if -> . soloIf elseIf else
    (19) if -> . soloIf else
    (42) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (43) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (49) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (20) soloIf -> . IF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    $end            reduce using rule 1 (expression -> variable .)
    CLOSE_PARENTHESIS reduce using rule 1 (expression -> variable .)
    CLOSE_BRACE     reduce using rule 1 (expression -> variable .)
    IGUAL           shift and go to state 21
    NAME            shift and go to state 6
    CONST           shift and go to state 11
    LET             shift and go to state 12
    VAR             shift and go to state 13
    WHILE           shift and go to state 17
    IF              shift and go to state 19

    variable                       shift and go to state 2
    expression                     shift and go to state 20
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    type                           shift and go to state 5
    array                          shift and go to state 7
    map                            shift and go to state 8
    while                          shift and go to state 9
    if                             shift and go to state 10
    iniciarMap                     shift and go to state 14
    escribirMap                    shift and go to state 15
    generarMap                     shift and go to state 16
    soloIf                         shift and go to state 18

state 3

    (3) expression -> dataStruct .
    (4) expression -> dataStruct . expression
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) variable -> . type NAME IGUAL datatype SEMICOLON
    (8) variable -> . type NAME IGUAL operations SEMICOLON
    (9) variable -> . NAME IGUAL datatype SEMICOLON
    (12) dataStruct -> . array
    (13) dataStruct -> . map
    (10) controlStruct -> . while
    (11) controlStruct -> . if
    (34) type -> . CONST
    (35) type -> . LET
    (36) type -> . VAR
    (37) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (38) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (39) map -> . iniciarMap
    (40) map -> . escribirMap
    (41) map -> . generarMap
    (14) while -> . WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (15) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (16) if -> . soloIf
    (17) if -> . soloIf elseIf
    (18) if -> . soloIf elseIf else
    (19) if -> . soloIf else
    (42) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (43) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (49) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (20) soloIf -> . IF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    $end            reduce using rule 3 (expression -> dataStruct .)
    CLOSE_PARENTHESIS reduce using rule 3 (expression -> dataStruct .)
    CLOSE_BRACE     reduce using rule 3 (expression -> dataStruct .)
    NAME            shift and go to state 6
    CONST           shift and go to state 11
    LET             shift and go to state 12
    VAR             shift and go to state 13
    WHILE           shift and go to state 17
    IF              shift and go to state 19

    dataStruct                     shift and go to state 3
    expression                     shift and go to state 22
    variable                       shift and go to state 2
    controlStruct                  shift and go to state 4
    type                           shift and go to state 5
    array                          shift and go to state 7
    map                            shift and go to state 8
    while                          shift and go to state 9
    if                             shift and go to state 10
    iniciarMap                     shift and go to state 14
    escribirMap                    shift and go to state 15
    generarMap                     shift and go to state 16
    soloIf                         shift and go to state 18

state 4

    (5) expression -> controlStruct .
    (6) expression -> controlStruct . expression
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) variable -> . type NAME IGUAL datatype SEMICOLON
    (8) variable -> . type NAME IGUAL operations SEMICOLON
    (9) variable -> . NAME IGUAL datatype SEMICOLON
    (12) dataStruct -> . array
    (13) dataStruct -> . map
    (10) controlStruct -> . while
    (11) controlStruct -> . if
    (34) type -> . CONST
    (35) type -> . LET
    (36) type -> . VAR
    (37) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (38) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (39) map -> . iniciarMap
    (40) map -> . escribirMap
    (41) map -> . generarMap
    (14) while -> . WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (15) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (16) if -> . soloIf
    (17) if -> . soloIf elseIf
    (18) if -> . soloIf elseIf else
    (19) if -> . soloIf else
    (42) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (43) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (49) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (20) soloIf -> . IF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    $end            reduce using rule 5 (expression -> controlStruct .)
    CLOSE_PARENTHESIS reduce using rule 5 (expression -> controlStruct .)
    CLOSE_BRACE     reduce using rule 5 (expression -> controlStruct .)
    NAME            shift and go to state 6
    CONST           shift and go to state 11
    LET             shift and go to state 12
    VAR             shift and go to state 13
    WHILE           shift and go to state 17
    IF              shift and go to state 19

    controlStruct                  shift and go to state 4
    expression                     shift and go to state 23
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    type                           shift and go to state 5
    array                          shift and go to state 7
    map                            shift and go to state 8
    while                          shift and go to state 9
    if                             shift and go to state 10
    iniciarMap                     shift and go to state 14
    escribirMap                    shift and go to state 15
    generarMap                     shift and go to state 16
    soloIf                         shift and go to state 18

state 5

    (7) variable -> type . NAME IGUAL datatype SEMICOLON
    (8) variable -> type . NAME IGUAL operations SEMICOLON
    (37) array -> type . NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (38) array -> type . NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON

    NAME            shift and go to state 24


state 6

    (9) variable -> NAME . IGUAL datatype SEMICOLON

    IGUAL           shift and go to state 25


state 7

    (12) dataStruct -> array .

    NAME            reduce using rule 12 (dataStruct -> array .)
    CONST           reduce using rule 12 (dataStruct -> array .)
    LET             reduce using rule 12 (dataStruct -> array .)
    VAR             reduce using rule 12 (dataStruct -> array .)
    WHILE           reduce using rule 12 (dataStruct -> array .)
    IF              reduce using rule 12 (dataStruct -> array .)
    $end            reduce using rule 12 (dataStruct -> array .)
    CLOSE_PARENTHESIS reduce using rule 12 (dataStruct -> array .)
    CLOSE_BRACE     reduce using rule 12 (dataStruct -> array .)
    COMMA           reduce using rule 12 (dataStruct -> array .)


state 8

    (13) dataStruct -> map .

    NAME            reduce using rule 13 (dataStruct -> map .)
    CONST           reduce using rule 13 (dataStruct -> map .)
    LET             reduce using rule 13 (dataStruct -> map .)
    VAR             reduce using rule 13 (dataStruct -> map .)
    WHILE           reduce using rule 13 (dataStruct -> map .)
    IF              reduce using rule 13 (dataStruct -> map .)
    $end            reduce using rule 13 (dataStruct -> map .)
    CLOSE_PARENTHESIS reduce using rule 13 (dataStruct -> map .)
    CLOSE_BRACE     reduce using rule 13 (dataStruct -> map .)
    COMMA           reduce using rule 13 (dataStruct -> map .)


state 9

    (10) controlStruct -> while .

    NAME            reduce using rule 10 (controlStruct -> while .)
    CONST           reduce using rule 10 (controlStruct -> while .)
    LET             reduce using rule 10 (controlStruct -> while .)
    VAR             reduce using rule 10 (controlStruct -> while .)
    WHILE           reduce using rule 10 (controlStruct -> while .)
    IF              reduce using rule 10 (controlStruct -> while .)
    $end            reduce using rule 10 (controlStruct -> while .)
    CLOSE_PARENTHESIS reduce using rule 10 (controlStruct -> while .)
    CLOSE_BRACE     reduce using rule 10 (controlStruct -> while .)


state 10

    (11) controlStruct -> if .

    NAME            reduce using rule 11 (controlStruct -> if .)
    CONST           reduce using rule 11 (controlStruct -> if .)
    LET             reduce using rule 11 (controlStruct -> if .)
    VAR             reduce using rule 11 (controlStruct -> if .)
    WHILE           reduce using rule 11 (controlStruct -> if .)
    IF              reduce using rule 11 (controlStruct -> if .)
    $end            reduce using rule 11 (controlStruct -> if .)
    CLOSE_PARENTHESIS reduce using rule 11 (controlStruct -> if .)
    CLOSE_BRACE     reduce using rule 11 (controlStruct -> if .)


state 11

    (34) type -> CONST .

    NAME            reduce using rule 34 (type -> CONST .)


state 12

    (35) type -> LET .

    NAME            reduce using rule 35 (type -> LET .)


state 13

    (36) type -> VAR .

    NAME            reduce using rule 36 (type -> VAR .)


state 14

    (39) map -> iniciarMap .

    NAME            reduce using rule 39 (map -> iniciarMap .)
    CONST           reduce using rule 39 (map -> iniciarMap .)
    LET             reduce using rule 39 (map -> iniciarMap .)
    VAR             reduce using rule 39 (map -> iniciarMap .)
    WHILE           reduce using rule 39 (map -> iniciarMap .)
    IF              reduce using rule 39 (map -> iniciarMap .)
    $end            reduce using rule 39 (map -> iniciarMap .)
    CLOSE_PARENTHESIS reduce using rule 39 (map -> iniciarMap .)
    CLOSE_BRACE     reduce using rule 39 (map -> iniciarMap .)
    COMMA           reduce using rule 39 (map -> iniciarMap .)


state 15

    (40) map -> escribirMap .

    NAME            reduce using rule 40 (map -> escribirMap .)
    CONST           reduce using rule 40 (map -> escribirMap .)
    LET             reduce using rule 40 (map -> escribirMap .)
    VAR             reduce using rule 40 (map -> escribirMap .)
    WHILE           reduce using rule 40 (map -> escribirMap .)
    IF              reduce using rule 40 (map -> escribirMap .)
    $end            reduce using rule 40 (map -> escribirMap .)
    CLOSE_PARENTHESIS reduce using rule 40 (map -> escribirMap .)
    CLOSE_BRACE     reduce using rule 40 (map -> escribirMap .)
    COMMA           reduce using rule 40 (map -> escribirMap .)


state 16

    (41) map -> generarMap .

    NAME            reduce using rule 41 (map -> generarMap .)
    CONST           reduce using rule 41 (map -> generarMap .)
    LET             reduce using rule 41 (map -> generarMap .)
    VAR             reduce using rule 41 (map -> generarMap .)
    WHILE           reduce using rule 41 (map -> generarMap .)
    IF              reduce using rule 41 (map -> generarMap .)
    $end            reduce using rule 41 (map -> generarMap .)
    CLOSE_PARENTHESIS reduce using rule 41 (map -> generarMap .)
    CLOSE_BRACE     reduce using rule 41 (map -> generarMap .)
    COMMA           reduce using rule 41 (map -> generarMap .)


state 17

    (14) while -> WHILE . OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (15) while -> WHILE . OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    OPEN_PARENTHESIS shift and go to state 26


state 18

    (16) if -> soloIf .
    (17) if -> soloIf . elseIf
    (18) if -> soloIf . elseIf else
    (19) if -> soloIf . else
    (21) elseIf -> . ELSEIF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (22) elseIf -> . ELSEIF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf
    (23) else -> . ELSE OPEN_BRACE expression CLOSE_BRACE

    NAME            reduce using rule 16 (if -> soloIf .)
    CONST           reduce using rule 16 (if -> soloIf .)
    LET             reduce using rule 16 (if -> soloIf .)
    VAR             reduce using rule 16 (if -> soloIf .)
    WHILE           reduce using rule 16 (if -> soloIf .)
    IF              reduce using rule 16 (if -> soloIf .)
    $end            reduce using rule 16 (if -> soloIf .)
    CLOSE_PARENTHESIS reduce using rule 16 (if -> soloIf .)
    CLOSE_BRACE     reduce using rule 16 (if -> soloIf .)
    ELSEIF          shift and go to state 29
    ELSE            shift and go to state 30

    elseIf                         shift and go to state 27
    else                           shift and go to state 28

state 19

    (20) soloIf -> IF . OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    OPEN_PARENTHESIS shift and go to state 31


state 20

    (2) expression -> variable expression .

    $end            reduce using rule 2 (expression -> variable expression .)
    CLOSE_PARENTHESIS reduce using rule 2 (expression -> variable expression .)
    CLOSE_BRACE     reduce using rule 2 (expression -> variable expression .)


state 21

    (42) iniciarMap -> variable IGUAL . NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (43) escribirMap -> variable IGUAL . OPEN_BRACE claveValor CLOSE_BRACE
    (49) generarMap -> variable IGUAL . OPEN_BRACE tuplas CLOSE_BRACE

    NEW             shift and go to state 32
    OPEN_BRACE      shift and go to state 33


state 22

    (4) expression -> dataStruct expression .

    $end            reduce using rule 4 (expression -> dataStruct expression .)
    CLOSE_PARENTHESIS reduce using rule 4 (expression -> dataStruct expression .)
    CLOSE_BRACE     reduce using rule 4 (expression -> dataStruct expression .)


state 23

    (6) expression -> controlStruct expression .

    $end            reduce using rule 6 (expression -> controlStruct expression .)
    CLOSE_PARENTHESIS reduce using rule 6 (expression -> controlStruct expression .)
    CLOSE_BRACE     reduce using rule 6 (expression -> controlStruct expression .)


state 24

    (7) variable -> type NAME . IGUAL datatype SEMICOLON
    (8) variable -> type NAME . IGUAL operations SEMICOLON
    (37) array -> type NAME . IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (38) array -> type NAME . IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON

    IGUAL           shift and go to state 34


state 25

    (9) variable -> NAME IGUAL . datatype SEMICOLON
    (25) datatype -> . NUMBER
    (26) datatype -> . STRING
    (27) datatype -> . CHAR

    NUMBER          shift and go to state 36
    STRING          shift and go to state 37
    CHAR            shift and go to state 38

    datatype                       shift and go to state 35

state 26

    (14) while -> WHILE OPEN_PARENTHESIS . expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (15) while -> WHILE OPEN_PARENTHESIS . bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (32) bool -> . TRUE
    (33) bool -> . FALSE
    (7) variable -> . type NAME IGUAL datatype SEMICOLON
    (8) variable -> . type NAME IGUAL operations SEMICOLON
    (9) variable -> . NAME IGUAL datatype SEMICOLON
    (12) dataStruct -> . array
    (13) dataStruct -> . map
    (10) controlStruct -> . while
    (11) controlStruct -> . if
    (34) type -> . CONST
    (35) type -> . LET
    (36) type -> . VAR
    (37) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (38) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (39) map -> . iniciarMap
    (40) map -> . escribirMap
    (41) map -> . generarMap
    (14) while -> . WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (15) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (16) if -> . soloIf
    (17) if -> . soloIf elseIf
    (18) if -> . soloIf elseIf else
    (19) if -> . soloIf else
    (42) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (43) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (49) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (20) soloIf -> . IF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    TRUE            shift and go to state 41
    FALSE           shift and go to state 42
    NAME            shift and go to state 6
    CONST           shift and go to state 11
    LET             shift and go to state 12
    VAR             shift and go to state 13
    WHILE           shift and go to state 17
    IF              shift and go to state 19

    expression                     shift and go to state 39
    bool                           shift and go to state 40
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    type                           shift and go to state 5
    array                          shift and go to state 7
    map                            shift and go to state 8
    while                          shift and go to state 9
    if                             shift and go to state 10
    iniciarMap                     shift and go to state 14
    escribirMap                    shift and go to state 15
    generarMap                     shift and go to state 16
    soloIf                         shift and go to state 18

state 27

    (17) if -> soloIf elseIf .
    (18) if -> soloIf elseIf . else
    (23) else -> . ELSE OPEN_BRACE expression CLOSE_BRACE

    NAME            reduce using rule 17 (if -> soloIf elseIf .)
    CONST           reduce using rule 17 (if -> soloIf elseIf .)
    LET             reduce using rule 17 (if -> soloIf elseIf .)
    VAR             reduce using rule 17 (if -> soloIf elseIf .)
    WHILE           reduce using rule 17 (if -> soloIf elseIf .)
    IF              reduce using rule 17 (if -> soloIf elseIf .)
    $end            reduce using rule 17 (if -> soloIf elseIf .)
    CLOSE_PARENTHESIS reduce using rule 17 (if -> soloIf elseIf .)
    CLOSE_BRACE     reduce using rule 17 (if -> soloIf elseIf .)
    ELSE            shift and go to state 30

    else                           shift and go to state 43

state 28

    (19) if -> soloIf else .

    NAME            reduce using rule 19 (if -> soloIf else .)
    CONST           reduce using rule 19 (if -> soloIf else .)
    LET             reduce using rule 19 (if -> soloIf else .)
    VAR             reduce using rule 19 (if -> soloIf else .)
    WHILE           reduce using rule 19 (if -> soloIf else .)
    IF              reduce using rule 19 (if -> soloIf else .)
    $end            reduce using rule 19 (if -> soloIf else .)
    CLOSE_PARENTHESIS reduce using rule 19 (if -> soloIf else .)
    CLOSE_BRACE     reduce using rule 19 (if -> soloIf else .)


state 29

    (21) elseIf -> ELSEIF . OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (22) elseIf -> ELSEIF . OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf

    OPEN_PARENTHESIS shift and go to state 44


state 30

    (23) else -> ELSE . OPEN_BRACE expression CLOSE_BRACE

    OPEN_BRACE      shift and go to state 45


state 31

    (20) soloIf -> IF OPEN_PARENTHESIS . bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (32) bool -> . TRUE
    (33) bool -> . FALSE

    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    bool                           shift and go to state 46

state 32

    (42) iniciarMap -> variable IGUAL NEW . MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON

    MAP             shift and go to state 47


state 33

    (43) escribirMap -> variable IGUAL OPEN_BRACE . claveValor CLOSE_BRACE
    (49) generarMap -> variable IGUAL OPEN_BRACE . tuplas CLOSE_BRACE
    (44) claveValor -> . clave COLON valor
    (45) claveValor -> . clave COLON valor COMMA claveValor
    (50) tuplas -> . tupla
    (51) tuplas -> . tupla tuplas
    (46) clave -> . datatype
    (52) tupla -> . OPEN_BRACKET datatype CLOSE_BRACKET
    (53) tupla -> . OPEN_BRACKET datatype COMMA datatype CLOSE_BRACKET
    (25) datatype -> . NUMBER
    (26) datatype -> . STRING
    (27) datatype -> . CHAR

    OPEN_BRACKET    shift and go to state 53
    NUMBER          shift and go to state 36
    STRING          shift and go to state 37
    CHAR            shift and go to state 38

    claveValor                     shift and go to state 48
    tuplas                         shift and go to state 49
    clave                          shift and go to state 50
    tupla                          shift and go to state 51
    datatype                       shift and go to state 52

state 34

    (7) variable -> type NAME IGUAL . datatype SEMICOLON
    (8) variable -> type NAME IGUAL . operations SEMICOLON
    (37) array -> type NAME IGUAL . OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (38) array -> type NAME IGUAL . NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (25) datatype -> . NUMBER
    (26) datatype -> . STRING
    (27) datatype -> . CHAR
    (24) operations -> . NUMBER operand NUMBER

    OPEN_BRACKET    shift and go to state 56
    NEW             shift and go to state 57
    NUMBER          shift and go to state 58
    STRING          shift and go to state 37
    CHAR            shift and go to state 38

    datatype                       shift and go to state 54
    operations                     shift and go to state 55

state 35

    (9) variable -> NAME IGUAL datatype . SEMICOLON

    SEMICOLON       shift and go to state 59


state 36

    (25) datatype -> NUMBER .

    SEMICOLON       reduce using rule 25 (datatype -> NUMBER .)
    COLON           reduce using rule 25 (datatype -> NUMBER .)
    CLOSE_BRACKET   reduce using rule 25 (datatype -> NUMBER .)
    COMMA           reduce using rule 25 (datatype -> NUMBER .)
    CLOSE_BRACE     reduce using rule 25 (datatype -> NUMBER .)


state 37

    (26) datatype -> STRING .

    SEMICOLON       reduce using rule 26 (datatype -> STRING .)
    COLON           reduce using rule 26 (datatype -> STRING .)
    CLOSE_BRACKET   reduce using rule 26 (datatype -> STRING .)
    COMMA           reduce using rule 26 (datatype -> STRING .)
    CLOSE_BRACE     reduce using rule 26 (datatype -> STRING .)


state 38

    (27) datatype -> CHAR .

    SEMICOLON       reduce using rule 27 (datatype -> CHAR .)
    COLON           reduce using rule 27 (datatype -> CHAR .)
    CLOSE_BRACKET   reduce using rule 27 (datatype -> CHAR .)
    COMMA           reduce using rule 27 (datatype -> CHAR .)
    CLOSE_BRACE     reduce using rule 27 (datatype -> CHAR .)


state 39

    (14) while -> WHILE OPEN_PARENTHESIS expression . CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    CLOSE_PARENTHESIS shift and go to state 60


state 40

    (15) while -> WHILE OPEN_PARENTHESIS bool . CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    CLOSE_PARENTHESIS shift and go to state 61


state 41

    (32) bool -> TRUE .

    CLOSE_PARENTHESIS reduce using rule 32 (bool -> TRUE .)


state 42

    (33) bool -> FALSE .

    CLOSE_PARENTHESIS reduce using rule 33 (bool -> FALSE .)


state 43

    (18) if -> soloIf elseIf else .

    NAME            reduce using rule 18 (if -> soloIf elseIf else .)
    CONST           reduce using rule 18 (if -> soloIf elseIf else .)
    LET             reduce using rule 18 (if -> soloIf elseIf else .)
    VAR             reduce using rule 18 (if -> soloIf elseIf else .)
    WHILE           reduce using rule 18 (if -> soloIf elseIf else .)
    IF              reduce using rule 18 (if -> soloIf elseIf else .)
    $end            reduce using rule 18 (if -> soloIf elseIf else .)
    CLOSE_PARENTHESIS reduce using rule 18 (if -> soloIf elseIf else .)
    CLOSE_BRACE     reduce using rule 18 (if -> soloIf elseIf else .)


state 44

    (21) elseIf -> ELSEIF OPEN_PARENTHESIS . bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (22) elseIf -> ELSEIF OPEN_PARENTHESIS . bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf
    (32) bool -> . TRUE
    (33) bool -> . FALSE

    TRUE            shift and go to state 41
    FALSE           shift and go to state 42

    bool                           shift and go to state 62

state 45

    (23) else -> ELSE OPEN_BRACE . expression CLOSE_BRACE
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) variable -> . type NAME IGUAL datatype SEMICOLON
    (8) variable -> . type NAME IGUAL operations SEMICOLON
    (9) variable -> . NAME IGUAL datatype SEMICOLON
    (12) dataStruct -> . array
    (13) dataStruct -> . map
    (10) controlStruct -> . while
    (11) controlStruct -> . if
    (34) type -> . CONST
    (35) type -> . LET
    (36) type -> . VAR
    (37) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (38) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (39) map -> . iniciarMap
    (40) map -> . escribirMap
    (41) map -> . generarMap
    (14) while -> . WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (15) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (16) if -> . soloIf
    (17) if -> . soloIf elseIf
    (18) if -> . soloIf elseIf else
    (19) if -> . soloIf else
    (42) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (43) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (49) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (20) soloIf -> . IF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    NAME            shift and go to state 6
    CONST           shift and go to state 11
    LET             shift and go to state 12
    VAR             shift and go to state 13
    WHILE           shift and go to state 17
    IF              shift and go to state 19

    expression                     shift and go to state 63
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    type                           shift and go to state 5
    array                          shift and go to state 7
    map                            shift and go to state 8
    while                          shift and go to state 9
    if                             shift and go to state 10
    iniciarMap                     shift and go to state 14
    escribirMap                    shift and go to state 15
    generarMap                     shift and go to state 16
    soloIf                         shift and go to state 18

state 46

    (20) soloIf -> IF OPEN_PARENTHESIS bool . CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    CLOSE_PARENTHESIS shift and go to state 64


state 47

    (42) iniciarMap -> variable IGUAL NEW MAP . OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON

    OPEN_PARENTHESIS shift and go to state 65


state 48

    (43) escribirMap -> variable IGUAL OPEN_BRACE claveValor . CLOSE_BRACE

    CLOSE_BRACE     shift and go to state 66


state 49

    (49) generarMap -> variable IGUAL OPEN_BRACE tuplas . CLOSE_BRACE

    CLOSE_BRACE     shift and go to state 67


state 50

    (44) claveValor -> clave . COLON valor
    (45) claveValor -> clave . COLON valor COMMA claveValor

    COLON           shift and go to state 68


state 51

    (50) tuplas -> tupla .
    (51) tuplas -> tupla . tuplas
    (50) tuplas -> . tupla
    (51) tuplas -> . tupla tuplas
    (52) tupla -> . OPEN_BRACKET datatype CLOSE_BRACKET
    (53) tupla -> . OPEN_BRACKET datatype COMMA datatype CLOSE_BRACKET

    CLOSE_BRACE     reduce using rule 50 (tuplas -> tupla .)
    OPEN_BRACKET    shift and go to state 53

    tupla                          shift and go to state 51
    tuplas                         shift and go to state 69

state 52

    (46) clave -> datatype .

    COLON           reduce using rule 46 (clave -> datatype .)


state 53

    (52) tupla -> OPEN_BRACKET . datatype CLOSE_BRACKET
    (53) tupla -> OPEN_BRACKET . datatype COMMA datatype CLOSE_BRACKET
    (25) datatype -> . NUMBER
    (26) datatype -> . STRING
    (27) datatype -> . CHAR

    NUMBER          shift and go to state 36
    STRING          shift and go to state 37
    CHAR            shift and go to state 38

    datatype                       shift and go to state 70

state 54

    (7) variable -> type NAME IGUAL datatype . SEMICOLON

    SEMICOLON       shift and go to state 71


state 55

    (8) variable -> type NAME IGUAL operations . SEMICOLON

    SEMICOLON       shift and go to state 72


state 56

    (37) array -> type NAME IGUAL OPEN_BRACKET . items CLOSE_BRACKET SEMICOLON
    (54) items -> . numeros
    (55) items -> . cadena
    (56) numeros -> . NUMBER
    (57) numeros -> . NUMBER COMMA numeros
    (58) cadena -> . STRING
    (59) cadena -> . STRING COMMA cadena

    NUMBER          shift and go to state 76
    STRING          shift and go to state 77

    items                          shift and go to state 73
    numeros                        shift and go to state 74
    cadena                         shift and go to state 75

state 57

    (38) array -> type NAME IGUAL NEW . ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON

    ARRAY           shift and go to state 78


state 58

    (25) datatype -> NUMBER .
    (24) operations -> NUMBER . operand NUMBER
    (28) operand -> . SUMA
    (29) operand -> . RESTA
    (30) operand -> . MULTIPLICACION
    (31) operand -> . DIVISION

    SEMICOLON       reduce using rule 25 (datatype -> NUMBER .)
    SUMA            shift and go to state 80
    RESTA           shift and go to state 81
    MULTIPLICACION  shift and go to state 82
    DIVISION        shift and go to state 83

    operand                        shift and go to state 79

state 59

    (9) variable -> NAME IGUAL datatype SEMICOLON .

    IGUAL           reduce using rule 9 (variable -> NAME IGUAL datatype SEMICOLON .)
    NAME            reduce using rule 9 (variable -> NAME IGUAL datatype SEMICOLON .)
    CONST           reduce using rule 9 (variable -> NAME IGUAL datatype SEMICOLON .)
    LET             reduce using rule 9 (variable -> NAME IGUAL datatype SEMICOLON .)
    VAR             reduce using rule 9 (variable -> NAME IGUAL datatype SEMICOLON .)
    WHILE           reduce using rule 9 (variable -> NAME IGUAL datatype SEMICOLON .)
    IF              reduce using rule 9 (variable -> NAME IGUAL datatype SEMICOLON .)
    $end            reduce using rule 9 (variable -> NAME IGUAL datatype SEMICOLON .)
    CLOSE_PARENTHESIS reduce using rule 9 (variable -> NAME IGUAL datatype SEMICOLON .)
    CLOSE_BRACE     reduce using rule 9 (variable -> NAME IGUAL datatype SEMICOLON .)


state 60

    (14) while -> WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS . OPEN_BRACE expression CLOSE_BRACE

    OPEN_BRACE      shift and go to state 84


state 61

    (15) while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS . OPEN_BRACE expression CLOSE_BRACE

    OPEN_BRACE      shift and go to state 85


state 62

    (21) elseIf -> ELSEIF OPEN_PARENTHESIS bool . CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (22) elseIf -> ELSEIF OPEN_PARENTHESIS bool . CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf

    CLOSE_PARENTHESIS shift and go to state 86


state 63

    (23) else -> ELSE OPEN_BRACE expression . CLOSE_BRACE

    CLOSE_BRACE     shift and go to state 87


state 64

    (20) soloIf -> IF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS . OPEN_BRACE expression CLOSE_BRACE

    OPEN_BRACE      shift and go to state 88


state 65

    (42) iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS . CLOSE_PARENTHESIS SEMICOLON

    CLOSE_PARENTHESIS shift and go to state 89


state 66

    (43) escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .

    NAME            reduce using rule 43 (escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .)
    CONST           reduce using rule 43 (escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .)
    LET             reduce using rule 43 (escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .)
    VAR             reduce using rule 43 (escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .)
    WHILE           reduce using rule 43 (escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .)
    IF              reduce using rule 43 (escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .)
    $end            reduce using rule 43 (escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .)
    CLOSE_PARENTHESIS reduce using rule 43 (escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 43 (escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .)
    COMMA           reduce using rule 43 (escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .)


state 67

    (49) generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .

    NAME            reduce using rule 49 (generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .)
    CONST           reduce using rule 49 (generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .)
    LET             reduce using rule 49 (generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .)
    VAR             reduce using rule 49 (generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .)
    WHILE           reduce using rule 49 (generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .)
    IF              reduce using rule 49 (generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .)
    $end            reduce using rule 49 (generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .)
    CLOSE_PARENTHESIS reduce using rule 49 (generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 49 (generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .)
    COMMA           reduce using rule 49 (generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .)


state 68

    (44) claveValor -> clave COLON . valor
    (45) claveValor -> clave COLON . valor COMMA claveValor
    (47) valor -> . datatype
    (48) valor -> . dataStruct
    (25) datatype -> . NUMBER
    (26) datatype -> . STRING
    (27) datatype -> . CHAR
    (12) dataStruct -> . array
    (13) dataStruct -> . map
    (37) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (38) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (39) map -> . iniciarMap
    (40) map -> . escribirMap
    (41) map -> . generarMap
    (34) type -> . CONST
    (35) type -> . LET
    (36) type -> . VAR
    (42) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (43) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (49) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (7) variable -> . type NAME IGUAL datatype SEMICOLON
    (8) variable -> . type NAME IGUAL operations SEMICOLON
    (9) variable -> . NAME IGUAL datatype SEMICOLON

    NUMBER          shift and go to state 36
    STRING          shift and go to state 37
    CHAR            shift and go to state 38
    CONST           shift and go to state 11
    LET             shift and go to state 12
    VAR             shift and go to state 13
    NAME            shift and go to state 6

    valor                          shift and go to state 90
    datatype                       shift and go to state 91
    dataStruct                     shift and go to state 92
    array                          shift and go to state 7
    map                            shift and go to state 8
    type                           shift and go to state 93
    iniciarMap                     shift and go to state 14
    escribirMap                    shift and go to state 15
    generarMap                     shift and go to state 16
    variable                       shift and go to state 94

state 69

    (51) tuplas -> tupla tuplas .

    CLOSE_BRACE     reduce using rule 51 (tuplas -> tupla tuplas .)


state 70

    (52) tupla -> OPEN_BRACKET datatype . CLOSE_BRACKET
    (53) tupla -> OPEN_BRACKET datatype . COMMA datatype CLOSE_BRACKET

    CLOSE_BRACKET   shift and go to state 95
    COMMA           shift and go to state 96


state 71

    (7) variable -> type NAME IGUAL datatype SEMICOLON .

    IGUAL           reduce using rule 7 (variable -> type NAME IGUAL datatype SEMICOLON .)
    NAME            reduce using rule 7 (variable -> type NAME IGUAL datatype SEMICOLON .)
    CONST           reduce using rule 7 (variable -> type NAME IGUAL datatype SEMICOLON .)
    LET             reduce using rule 7 (variable -> type NAME IGUAL datatype SEMICOLON .)
    VAR             reduce using rule 7 (variable -> type NAME IGUAL datatype SEMICOLON .)
    WHILE           reduce using rule 7 (variable -> type NAME IGUAL datatype SEMICOLON .)
    IF              reduce using rule 7 (variable -> type NAME IGUAL datatype SEMICOLON .)
    $end            reduce using rule 7 (variable -> type NAME IGUAL datatype SEMICOLON .)
    CLOSE_PARENTHESIS reduce using rule 7 (variable -> type NAME IGUAL datatype SEMICOLON .)
    CLOSE_BRACE     reduce using rule 7 (variable -> type NAME IGUAL datatype SEMICOLON .)


state 72

    (8) variable -> type NAME IGUAL operations SEMICOLON .

    IGUAL           reduce using rule 8 (variable -> type NAME IGUAL operations SEMICOLON .)
    NAME            reduce using rule 8 (variable -> type NAME IGUAL operations SEMICOLON .)
    CONST           reduce using rule 8 (variable -> type NAME IGUAL operations SEMICOLON .)
    LET             reduce using rule 8 (variable -> type NAME IGUAL operations SEMICOLON .)
    VAR             reduce using rule 8 (variable -> type NAME IGUAL operations SEMICOLON .)
    WHILE           reduce using rule 8 (variable -> type NAME IGUAL operations SEMICOLON .)
    IF              reduce using rule 8 (variable -> type NAME IGUAL operations SEMICOLON .)
    $end            reduce using rule 8 (variable -> type NAME IGUAL operations SEMICOLON .)
    CLOSE_PARENTHESIS reduce using rule 8 (variable -> type NAME IGUAL operations SEMICOLON .)
    CLOSE_BRACE     reduce using rule 8 (variable -> type NAME IGUAL operations SEMICOLON .)


state 73

    (37) array -> type NAME IGUAL OPEN_BRACKET items . CLOSE_BRACKET SEMICOLON

    CLOSE_BRACKET   shift and go to state 97


state 74

    (54) items -> numeros .

    CLOSE_BRACKET   reduce using rule 54 (items -> numeros .)
    CLOSE_PARENTHESIS reduce using rule 54 (items -> numeros .)


state 75

    (55) items -> cadena .

    CLOSE_BRACKET   reduce using rule 55 (items -> cadena .)
    CLOSE_PARENTHESIS reduce using rule 55 (items -> cadena .)


state 76

    (56) numeros -> NUMBER .
    (57) numeros -> NUMBER . COMMA numeros

    CLOSE_BRACKET   reduce using rule 56 (numeros -> NUMBER .)
    CLOSE_PARENTHESIS reduce using rule 56 (numeros -> NUMBER .)
    COMMA           shift and go to state 98


state 77

    (58) cadena -> STRING .
    (59) cadena -> STRING . COMMA cadena

    CLOSE_BRACKET   reduce using rule 58 (cadena -> STRING .)
    CLOSE_PARENTHESIS reduce using rule 58 (cadena -> STRING .)
    COMMA           shift and go to state 99


state 78

    (38) array -> type NAME IGUAL NEW ARRAY . OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON

    OPEN_PARENTHESIS shift and go to state 100


state 79

    (24) operations -> NUMBER operand . NUMBER

    NUMBER          shift and go to state 101


state 80

    (28) operand -> SUMA .

    NUMBER          reduce using rule 28 (operand -> SUMA .)


state 81

    (29) operand -> RESTA .

    NUMBER          reduce using rule 29 (operand -> RESTA .)


state 82

    (30) operand -> MULTIPLICACION .

    NUMBER          reduce using rule 30 (operand -> MULTIPLICACION .)


state 83

    (31) operand -> DIVISION .

    NUMBER          reduce using rule 31 (operand -> DIVISION .)


state 84

    (14) while -> WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE . expression CLOSE_BRACE
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) variable -> . type NAME IGUAL datatype SEMICOLON
    (8) variable -> . type NAME IGUAL operations SEMICOLON
    (9) variable -> . NAME IGUAL datatype SEMICOLON
    (12) dataStruct -> . array
    (13) dataStruct -> . map
    (10) controlStruct -> . while
    (11) controlStruct -> . if
    (34) type -> . CONST
    (35) type -> . LET
    (36) type -> . VAR
    (37) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (38) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (39) map -> . iniciarMap
    (40) map -> . escribirMap
    (41) map -> . generarMap
    (14) while -> . WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (15) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (16) if -> . soloIf
    (17) if -> . soloIf elseIf
    (18) if -> . soloIf elseIf else
    (19) if -> . soloIf else
    (42) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (43) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (49) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (20) soloIf -> . IF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    NAME            shift and go to state 6
    CONST           shift and go to state 11
    LET             shift and go to state 12
    VAR             shift and go to state 13
    WHILE           shift and go to state 17
    IF              shift and go to state 19

    expression                     shift and go to state 102
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    type                           shift and go to state 5
    array                          shift and go to state 7
    map                            shift and go to state 8
    while                          shift and go to state 9
    if                             shift and go to state 10
    iniciarMap                     shift and go to state 14
    escribirMap                    shift and go to state 15
    generarMap                     shift and go to state 16
    soloIf                         shift and go to state 18

state 85

    (15) while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE . expression CLOSE_BRACE
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) variable -> . type NAME IGUAL datatype SEMICOLON
    (8) variable -> . type NAME IGUAL operations SEMICOLON
    (9) variable -> . NAME IGUAL datatype SEMICOLON
    (12) dataStruct -> . array
    (13) dataStruct -> . map
    (10) controlStruct -> . while
    (11) controlStruct -> . if
    (34) type -> . CONST
    (35) type -> . LET
    (36) type -> . VAR
    (37) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (38) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (39) map -> . iniciarMap
    (40) map -> . escribirMap
    (41) map -> . generarMap
    (14) while -> . WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (15) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (16) if -> . soloIf
    (17) if -> . soloIf elseIf
    (18) if -> . soloIf elseIf else
    (19) if -> . soloIf else
    (42) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (43) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (49) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (20) soloIf -> . IF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    NAME            shift and go to state 6
    CONST           shift and go to state 11
    LET             shift and go to state 12
    VAR             shift and go to state 13
    WHILE           shift and go to state 17
    IF              shift and go to state 19

    expression                     shift and go to state 103
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    type                           shift and go to state 5
    array                          shift and go to state 7
    map                            shift and go to state 8
    while                          shift and go to state 9
    if                             shift and go to state 10
    iniciarMap                     shift and go to state 14
    escribirMap                    shift and go to state 15
    generarMap                     shift and go to state 16
    soloIf                         shift and go to state 18

state 86

    (21) elseIf -> ELSEIF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS . OPEN_BRACE expression CLOSE_BRACE
    (22) elseIf -> ELSEIF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS . OPEN_BRACE expression CLOSE_BRACE soloIf

    OPEN_BRACE      shift and go to state 104


state 87

    (23) else -> ELSE OPEN_BRACE expression CLOSE_BRACE .

    NAME            reduce using rule 23 (else -> ELSE OPEN_BRACE expression CLOSE_BRACE .)
    CONST           reduce using rule 23 (else -> ELSE OPEN_BRACE expression CLOSE_BRACE .)
    LET             reduce using rule 23 (else -> ELSE OPEN_BRACE expression CLOSE_BRACE .)
    VAR             reduce using rule 23 (else -> ELSE OPEN_BRACE expression CLOSE_BRACE .)
    WHILE           reduce using rule 23 (else -> ELSE OPEN_BRACE expression CLOSE_BRACE .)
    IF              reduce using rule 23 (else -> ELSE OPEN_BRACE expression CLOSE_BRACE .)
    $end            reduce using rule 23 (else -> ELSE OPEN_BRACE expression CLOSE_BRACE .)
    CLOSE_PARENTHESIS reduce using rule 23 (else -> ELSE OPEN_BRACE expression CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 23 (else -> ELSE OPEN_BRACE expression CLOSE_BRACE .)


state 88

    (20) soloIf -> IF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE . expression CLOSE_BRACE
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) variable -> . type NAME IGUAL datatype SEMICOLON
    (8) variable -> . type NAME IGUAL operations SEMICOLON
    (9) variable -> . NAME IGUAL datatype SEMICOLON
    (12) dataStruct -> . array
    (13) dataStruct -> . map
    (10) controlStruct -> . while
    (11) controlStruct -> . if
    (34) type -> . CONST
    (35) type -> . LET
    (36) type -> . VAR
    (37) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (38) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (39) map -> . iniciarMap
    (40) map -> . escribirMap
    (41) map -> . generarMap
    (14) while -> . WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (15) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (16) if -> . soloIf
    (17) if -> . soloIf elseIf
    (18) if -> . soloIf elseIf else
    (19) if -> . soloIf else
    (42) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (43) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (49) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (20) soloIf -> . IF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    NAME            shift and go to state 6
    CONST           shift and go to state 11
    LET             shift and go to state 12
    VAR             shift and go to state 13
    WHILE           shift and go to state 17
    IF              shift and go to state 19

    expression                     shift and go to state 105
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    type                           shift and go to state 5
    array                          shift and go to state 7
    map                            shift and go to state 8
    while                          shift and go to state 9
    if                             shift and go to state 10
    iniciarMap                     shift and go to state 14
    escribirMap                    shift and go to state 15
    generarMap                     shift and go to state 16
    soloIf                         shift and go to state 18

state 89

    (42) iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 106


state 90

    (44) claveValor -> clave COLON valor .
    (45) claveValor -> clave COLON valor . COMMA claveValor

    CLOSE_BRACE     reduce using rule 44 (claveValor -> clave COLON valor .)
    COMMA           shift and go to state 107


state 91

    (47) valor -> datatype .

    COMMA           reduce using rule 47 (valor -> datatype .)
    CLOSE_BRACE     reduce using rule 47 (valor -> datatype .)


state 92

    (48) valor -> dataStruct .

    COMMA           reduce using rule 48 (valor -> dataStruct .)
    CLOSE_BRACE     reduce using rule 48 (valor -> dataStruct .)


state 93

    (37) array -> type . NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (38) array -> type . NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (7) variable -> type . NAME IGUAL datatype SEMICOLON
    (8) variable -> type . NAME IGUAL operations SEMICOLON

    NAME            shift and go to state 108


state 94

    (42) iniciarMap -> variable . IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (43) escribirMap -> variable . IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (49) generarMap -> variable . IGUAL OPEN_BRACE tuplas CLOSE_BRACE

    IGUAL           shift and go to state 21


state 95

    (52) tupla -> OPEN_BRACKET datatype CLOSE_BRACKET .

    OPEN_BRACKET    reduce using rule 52 (tupla -> OPEN_BRACKET datatype CLOSE_BRACKET .)
    CLOSE_BRACE     reduce using rule 52 (tupla -> OPEN_BRACKET datatype CLOSE_BRACKET .)


state 96

    (53) tupla -> OPEN_BRACKET datatype COMMA . datatype CLOSE_BRACKET
    (25) datatype -> . NUMBER
    (26) datatype -> . STRING
    (27) datatype -> . CHAR

    NUMBER          shift and go to state 36
    STRING          shift and go to state 37
    CHAR            shift and go to state 38

    datatype                       shift and go to state 109

state 97

    (37) array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET . SEMICOLON

    SEMICOLON       shift and go to state 110


state 98

    (57) numeros -> NUMBER COMMA . numeros
    (56) numeros -> . NUMBER
    (57) numeros -> . NUMBER COMMA numeros

    NUMBER          shift and go to state 76

    numeros                        shift and go to state 111

state 99

    (59) cadena -> STRING COMMA . cadena
    (58) cadena -> . STRING
    (59) cadena -> . STRING COMMA cadena

    STRING          shift and go to state 77

    cadena                         shift and go to state 112

state 100

    (38) array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS . items CLOSE_PARENTHESIS SEMICOLON
    (54) items -> . numeros
    (55) items -> . cadena
    (56) numeros -> . NUMBER
    (57) numeros -> . NUMBER COMMA numeros
    (58) cadena -> . STRING
    (59) cadena -> . STRING COMMA cadena

    NUMBER          shift and go to state 76
    STRING          shift and go to state 77

    items                          shift and go to state 113
    numeros                        shift and go to state 74
    cadena                         shift and go to state 75

state 101

    (24) operations -> NUMBER operand NUMBER .

    SEMICOLON       reduce using rule 24 (operations -> NUMBER operand NUMBER .)


state 102

    (14) while -> WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression . CLOSE_BRACE

    CLOSE_BRACE     shift and go to state 114


state 103

    (15) while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression . CLOSE_BRACE

    CLOSE_BRACE     shift and go to state 115


state 104

    (21) elseIf -> ELSEIF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE . expression CLOSE_BRACE
    (22) elseIf -> ELSEIF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE . expression CLOSE_BRACE soloIf
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) variable -> . type NAME IGUAL datatype SEMICOLON
    (8) variable -> . type NAME IGUAL operations SEMICOLON
    (9) variable -> . NAME IGUAL datatype SEMICOLON
    (12) dataStruct -> . array
    (13) dataStruct -> . map
    (10) controlStruct -> . while
    (11) controlStruct -> . if
    (34) type -> . CONST
    (35) type -> . LET
    (36) type -> . VAR
    (37) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (38) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (39) map -> . iniciarMap
    (40) map -> . escribirMap
    (41) map -> . generarMap
    (14) while -> . WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (15) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (16) if -> . soloIf
    (17) if -> . soloIf elseIf
    (18) if -> . soloIf elseIf else
    (19) if -> . soloIf else
    (42) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (43) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (49) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (20) soloIf -> . IF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    NAME            shift and go to state 6
    CONST           shift and go to state 11
    LET             shift and go to state 12
    VAR             shift and go to state 13
    WHILE           shift and go to state 17
    IF              shift and go to state 19

    expression                     shift and go to state 116
    soloIf                         shift and go to state 18
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    type                           shift and go to state 5
    array                          shift and go to state 7
    map                            shift and go to state 8
    while                          shift and go to state 9
    if                             shift and go to state 10
    iniciarMap                     shift and go to state 14
    escribirMap                    shift and go to state 15
    generarMap                     shift and go to state 16

state 105

    (20) soloIf -> IF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression . CLOSE_BRACE

    CLOSE_BRACE     shift and go to state 117


state 106

    (42) iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .

    NAME            reduce using rule 42 (iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    CONST           reduce using rule 42 (iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    LET             reduce using rule 42 (iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    VAR             reduce using rule 42 (iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    WHILE           reduce using rule 42 (iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    IF              reduce using rule 42 (iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    $end            reduce using rule 42 (iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_PARENTHESIS reduce using rule 42 (iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 42 (iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    COMMA           reduce using rule 42 (iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)


state 107

    (45) claveValor -> clave COLON valor COMMA . claveValor
    (44) claveValor -> . clave COLON valor
    (45) claveValor -> . clave COLON valor COMMA claveValor
    (46) clave -> . datatype
    (25) datatype -> . NUMBER
    (26) datatype -> . STRING
    (27) datatype -> . CHAR

    NUMBER          shift and go to state 36
    STRING          shift and go to state 37
    CHAR            shift and go to state 38

    clave                          shift and go to state 50
    claveValor                     shift and go to state 118
    datatype                       shift and go to state 52

state 108

    (37) array -> type NAME . IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (38) array -> type NAME . IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (7) variable -> type NAME . IGUAL datatype SEMICOLON
    (8) variable -> type NAME . IGUAL operations SEMICOLON

    IGUAL           shift and go to state 119


state 109

    (53) tupla -> OPEN_BRACKET datatype COMMA datatype . CLOSE_BRACKET

    CLOSE_BRACKET   shift and go to state 120


state 110

    (37) array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .

    NAME            reduce using rule 37 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    CONST           reduce using rule 37 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    LET             reduce using rule 37 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    VAR             reduce using rule 37 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    WHILE           reduce using rule 37 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    IF              reduce using rule 37 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    $end            reduce using rule 37 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    CLOSE_PARENTHESIS reduce using rule 37 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    CLOSE_BRACE     reduce using rule 37 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    COMMA           reduce using rule 37 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)


state 111

    (57) numeros -> NUMBER COMMA numeros .

    CLOSE_BRACKET   reduce using rule 57 (numeros -> NUMBER COMMA numeros .)
    CLOSE_PARENTHESIS reduce using rule 57 (numeros -> NUMBER COMMA numeros .)


state 112

    (59) cadena -> STRING COMMA cadena .

    CLOSE_BRACKET   reduce using rule 59 (cadena -> STRING COMMA cadena .)
    CLOSE_PARENTHESIS reduce using rule 59 (cadena -> STRING COMMA cadena .)


state 113

    (38) array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items . CLOSE_PARENTHESIS SEMICOLON

    CLOSE_PARENTHESIS shift and go to state 121


state 114

    (14) while -> WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .

    NAME            reduce using rule 14 (while -> WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CONST           reduce using rule 14 (while -> WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    LET             reduce using rule 14 (while -> WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    VAR             reduce using rule 14 (while -> WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    WHILE           reduce using rule 14 (while -> WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    IF              reduce using rule 14 (while -> WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    $end            reduce using rule 14 (while -> WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CLOSE_PARENTHESIS reduce using rule 14 (while -> WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 14 (while -> WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)


state 115

    (15) while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .

    NAME            reduce using rule 15 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CONST           reduce using rule 15 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    LET             reduce using rule 15 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    VAR             reduce using rule 15 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    WHILE           reduce using rule 15 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    IF              reduce using rule 15 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    $end            reduce using rule 15 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CLOSE_PARENTHESIS reduce using rule 15 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 15 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)


state 116

    (21) elseIf -> ELSEIF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression . CLOSE_BRACE
    (22) elseIf -> ELSEIF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression . CLOSE_BRACE soloIf

    CLOSE_BRACE     shift and go to state 122


state 117

    (20) soloIf -> IF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .

    ELSEIF          reduce using rule 20 (soloIf -> IF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    ELSE            reduce using rule 20 (soloIf -> IF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    NAME            reduce using rule 20 (soloIf -> IF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CONST           reduce using rule 20 (soloIf -> IF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    LET             reduce using rule 20 (soloIf -> IF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    VAR             reduce using rule 20 (soloIf -> IF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    WHILE           reduce using rule 20 (soloIf -> IF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    IF              reduce using rule 20 (soloIf -> IF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    $end            reduce using rule 20 (soloIf -> IF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CLOSE_PARENTHESIS reduce using rule 20 (soloIf -> IF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 20 (soloIf -> IF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)


state 118

    (45) claveValor -> clave COLON valor COMMA claveValor .

    CLOSE_BRACE     reduce using rule 45 (claveValor -> clave COLON valor COMMA claveValor .)


state 119

    (37) array -> type NAME IGUAL . OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (38) array -> type NAME IGUAL . NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (7) variable -> type NAME IGUAL . datatype SEMICOLON
    (8) variable -> type NAME IGUAL . operations SEMICOLON
    (25) datatype -> . NUMBER
    (26) datatype -> . STRING
    (27) datatype -> . CHAR
    (24) operations -> . NUMBER operand NUMBER

    OPEN_BRACKET    shift and go to state 56
    NEW             shift and go to state 57
    NUMBER          shift and go to state 58
    STRING          shift and go to state 37
    CHAR            shift and go to state 38

    datatype                       shift and go to state 54
    operations                     shift and go to state 55

state 120

    (53) tupla -> OPEN_BRACKET datatype COMMA datatype CLOSE_BRACKET .

    OPEN_BRACKET    reduce using rule 53 (tupla -> OPEN_BRACKET datatype COMMA datatype CLOSE_BRACKET .)
    CLOSE_BRACE     reduce using rule 53 (tupla -> OPEN_BRACKET datatype COMMA datatype CLOSE_BRACKET .)


state 121

    (38) array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 123


state 122

    (21) elseIf -> ELSEIF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .
    (22) elseIf -> ELSEIF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE . soloIf
    (20) soloIf -> . IF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

  ! shift/reduce conflict for IF resolved as shift
    ELSE            reduce using rule 21 (elseIf -> ELSEIF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    NAME            reduce using rule 21 (elseIf -> ELSEIF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CONST           reduce using rule 21 (elseIf -> ELSEIF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    LET             reduce using rule 21 (elseIf -> ELSEIF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    VAR             reduce using rule 21 (elseIf -> ELSEIF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    WHILE           reduce using rule 21 (elseIf -> ELSEIF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    $end            reduce using rule 21 (elseIf -> ELSEIF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CLOSE_PARENTHESIS reduce using rule 21 (elseIf -> ELSEIF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 21 (elseIf -> ELSEIF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    IF              shift and go to state 19

  ! IF              [ reduce using rule 21 (elseIf -> ELSEIF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .) ]

    soloIf                         shift and go to state 124

state 123

    (38) array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .

    NAME            reduce using rule 38 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    CONST           reduce using rule 38 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    LET             reduce using rule 38 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    VAR             reduce using rule 38 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    WHILE           reduce using rule 38 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    IF              reduce using rule 38 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    $end            reduce using rule 38 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_PARENTHESIS reduce using rule 38 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 38 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    COMMA           reduce using rule 38 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)


state 124

    (22) elseIf -> ELSEIF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .

    ELSE            reduce using rule 22 (elseIf -> ELSEIF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .)
    NAME            reduce using rule 22 (elseIf -> ELSEIF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .)
    CONST           reduce using rule 22 (elseIf -> ELSEIF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .)
    LET             reduce using rule 22 (elseIf -> ELSEIF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .)
    VAR             reduce using rule 22 (elseIf -> ELSEIF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .)
    WHILE           reduce using rule 22 (elseIf -> ELSEIF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .)
    IF              reduce using rule 22 (elseIf -> ELSEIF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .)
    $end            reduce using rule 22 (elseIf -> ELSEIF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .)
    CLOSE_PARENTHESIS reduce using rule 22 (elseIf -> ELSEIF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .)
    CLOSE_BRACE     reduce using rule 22 (elseIf -> ELSEIF OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for IF in state 122 resolved as shift
