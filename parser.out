Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    BACKSLASH
    BOOLEAN
    BREAK
    CASE
    CLASS
    COLON
    COMMENTS
    DEFAULT
    DIVIGUAL
    DOUBLE_QUOTES
    ELSE
    FLOAT
    FUNCTION
    IF
    INT
    LENGTH
    LINE_BREAK
    LONGCOMMENT
    MAP
    MASIGUAL
    MENOSIGUAL
    MODIGUAL
    NOT
    NULL
    OR
    POINT
    PORIGUAL
    POTIGUAL
    RETURN
    SINGLE_QUOTE
    STATIC
    SWITCH
    THEN
    TOSTRING
    TYPEOF
    UNDEFINED

Grammar

Rule 0     S' -> expression
Rule 1     expression -> variable
Rule 2     expression -> variable expression
Rule 3     expression -> dataStruct
Rule 4     expression -> dataStruct expression
Rule 5     expression -> controlStruct
Rule 6     expression -> controlStruct expression
Rule 7     variable -> type NAME IGUAL datatype SEMICOLON
Rule 8     controlStruct -> while
Rule 9     controlStruct -> for
Rule 10    dataStruct -> array
Rule 11    dataStruct -> set
Rule 12    while -> WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
Rule 13    while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
Rule 14    for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
Rule 15    inicialization -> type NAME IGUAL NUMBER
Rule 16    inicialization -> NAME IGUAL NUMBER
Rule 17    condition -> NAME clause value
Rule 18    operations -> NUMBER operand NUMBER
Rule 19    operations -> NAME SUMA SUMA
Rule 20    operations -> NAME RESTA RESTA
Rule 21    datatype -> NUMBER
Rule 22    datatype -> STRING
Rule 23    datatype -> operations
Rule 24    datatype -> CHAR
Rule 25    operand -> SUMA
Rule 26    operand -> RESTA
Rule 27    operand -> MULTIPLICACION
Rule 28    operand -> DIVISION
Rule 29    bool -> TRUE
Rule 30    bool -> FALSE
Rule 31    type -> CONST
Rule 32    type -> LET
Rule 33    type -> VAR
Rule 34    clause -> IGUALIGUAL
Rule 35    clause -> DIFERENTE
Rule 36    clause -> MAYORQUE
Rule 37    clause -> MAYORIGUALQUE
Rule 38    clause -> MENORQUE
Rule 39    clause -> MENORIGUALQUE
Rule 40    value -> NAME
Rule 41    value -> NUMBER
Rule 42    array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
Rule 43    array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
Rule 44    set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
Rule 45    set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
Rule 46    set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
Rule 47    items -> numeros
Rule 48    items -> cadena
Rule 49    numeros -> NUMBER
Rule 50    numeros -> NUMBER COMMA numeros
Rule 51    cadena -> STRING
Rule 52    cadena -> STRING COMMA cadena
Rule 53    element -> STRING
Rule 54    element -> NUMBER
Rule 55    element -> NAME

Terminals, with rules where they appear

AND                  : 
ARRAY                : 43
BACKSLASH            : 
BOOLEAN              : 
BREAK                : 
CASE                 : 
CHAR                 : 24
CLASS                : 
CLOSE_BRACE          : 12 13 14
CLOSE_BRACKET        : 42 45
CLOSE_PARENTHESIS    : 12 13 14 43 44 45 46
COLON                : 
COMMA                : 50 52
COMMENTS             : 
CONST                : 31
DEFAULT              : 
DIFERENTE            : 35
DIVIGUAL             : 
DIVISION             : 28
DOUBLE_QUOTES        : 
ELSE                 : 
FALSE                : 30
FLOAT                : 
FOR                  : 14
FUNCTION             : 
IF                   : 
IGUAL                : 7 15 16 42 43 44 45 46
IGUALIGUAL           : 34
INT                  : 
LENGTH               : 
LET                  : 32
LINE_BREAK           : 
LONGCOMMENT          : 
MAP                  : 
MASIGUAL             : 
MAYORIGUALQUE        : 37
MAYORQUE             : 36
MENORIGUALQUE        : 39
MENORQUE             : 38
MENOSIGUAL           : 
MODIGUAL             : 
MULTIPLICACION       : 27
NAME                 : 7 15 16 17 19 20 40 42 43 44 45 46 55
NEW                  : 43 44 45 46
NOT                  : 
NULL                 : 
NUMBER               : 15 16 18 18 21 41 49 50 54
OPEN_BRACE           : 12 13 14
OPEN_BRACKET         : 42 45
OPEN_PARENTHESIS     : 12 13 14 43 44 45 46
OR                   : 
POINT                : 
PORIGUAL             : 
POTIGUAL             : 
RESTA                : 20 20 26
RETURN               : 
SEMICOLON            : 7 14 14 42 43 44 45 46
SET                  : 44 45 46
SINGLE_QUOTE         : 
STATIC               : 
STRING               : 22 51 52 53
SUMA                 : 19 19 25
SWITCH               : 
THEN                 : 
TOSTRING             : 
TRUE                 : 29
TYPEOF               : 
UNDEFINED            : 
VAR                  : 33
WHILE                : 12 13
error                : 

Nonterminals, with rules where they appear

array                : 10
bool                 : 13
cadena               : 48 52
clause               : 17
condition            : 14
controlStruct        : 5 6
dataStruct           : 3 4
datatype             : 7
element              : 46
expression           : 2 4 6 12 12 13 14 0
for                  : 9
inicialization       : 14
items                : 42 43 45
numeros              : 47 50
operand              : 18
operations           : 14 23
set                  : 11
type                 : 7 15 42 43 44 45 46
value                : 17
variable             : 1 2
while                : 8

Parsing method: LALR

state 0

    (0) S' -> . expression
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) variable -> . type NAME IGUAL datatype SEMICOLON
    (10) dataStruct -> . array
    (11) dataStruct -> . set
    (8) controlStruct -> . while
    (9) controlStruct -> . for
    (31) type -> . CONST
    (32) type -> . LET
    (33) type -> . VAR
    (42) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (43) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (44) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (45) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (46) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (12) while -> . WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (13) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (14) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    CONST           shift and go to state 10
    LET             shift and go to state 11
    VAR             shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14

    expression                     shift and go to state 1
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    type                           shift and go to state 5
    array                          shift and go to state 6
    set                            shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9

state 1

    (0) S' -> expression .



state 2

    (1) expression -> variable .
    (2) expression -> variable . expression
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) variable -> . type NAME IGUAL datatype SEMICOLON
    (10) dataStruct -> . array
    (11) dataStruct -> . set
    (8) controlStruct -> . while
    (9) controlStruct -> . for
    (31) type -> . CONST
    (32) type -> . LET
    (33) type -> . VAR
    (42) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (43) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (44) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (45) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (46) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (12) while -> . WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (13) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (14) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    $end            reduce using rule 1 (expression -> variable .)
    CLOSE_PARENTHESIS reduce using rule 1 (expression -> variable .)
    CLOSE_BRACE     reduce using rule 1 (expression -> variable .)
    CONST           shift and go to state 10
    LET             shift and go to state 11
    VAR             shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14

    variable                       shift and go to state 2
    expression                     shift and go to state 15
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    type                           shift and go to state 5
    array                          shift and go to state 6
    set                            shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9

state 3

    (3) expression -> dataStruct .
    (4) expression -> dataStruct . expression
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) variable -> . type NAME IGUAL datatype SEMICOLON
    (10) dataStruct -> . array
    (11) dataStruct -> . set
    (8) controlStruct -> . while
    (9) controlStruct -> . for
    (31) type -> . CONST
    (32) type -> . LET
    (33) type -> . VAR
    (42) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (43) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (44) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (45) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (46) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (12) while -> . WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (13) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (14) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    $end            reduce using rule 3 (expression -> dataStruct .)
    CLOSE_PARENTHESIS reduce using rule 3 (expression -> dataStruct .)
    CLOSE_BRACE     reduce using rule 3 (expression -> dataStruct .)
    CONST           shift and go to state 10
    LET             shift and go to state 11
    VAR             shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14

    dataStruct                     shift and go to state 3
    expression                     shift and go to state 16
    variable                       shift and go to state 2
    controlStruct                  shift and go to state 4
    type                           shift and go to state 5
    array                          shift and go to state 6
    set                            shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9

state 4

    (5) expression -> controlStruct .
    (6) expression -> controlStruct . expression
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) variable -> . type NAME IGUAL datatype SEMICOLON
    (10) dataStruct -> . array
    (11) dataStruct -> . set
    (8) controlStruct -> . while
    (9) controlStruct -> . for
    (31) type -> . CONST
    (32) type -> . LET
    (33) type -> . VAR
    (42) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (43) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (44) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (45) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (46) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (12) while -> . WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (13) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (14) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    $end            reduce using rule 5 (expression -> controlStruct .)
    CLOSE_PARENTHESIS reduce using rule 5 (expression -> controlStruct .)
    CLOSE_BRACE     reduce using rule 5 (expression -> controlStruct .)
    CONST           shift and go to state 10
    LET             shift and go to state 11
    VAR             shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14

    controlStruct                  shift and go to state 4
    expression                     shift and go to state 17
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    type                           shift and go to state 5
    array                          shift and go to state 6
    set                            shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9

state 5

    (7) variable -> type . NAME IGUAL datatype SEMICOLON
    (42) array -> type . NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (43) array -> type . NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (44) set -> type . NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (45) set -> type . NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (46) set -> type . NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON

    NAME            shift and go to state 18


state 6

    (10) dataStruct -> array .

    CONST           reduce using rule 10 (dataStruct -> array .)
    LET             reduce using rule 10 (dataStruct -> array .)
    VAR             reduce using rule 10 (dataStruct -> array .)
    WHILE           reduce using rule 10 (dataStruct -> array .)
    FOR             reduce using rule 10 (dataStruct -> array .)
    $end            reduce using rule 10 (dataStruct -> array .)
    CLOSE_PARENTHESIS reduce using rule 10 (dataStruct -> array .)
    CLOSE_BRACE     reduce using rule 10 (dataStruct -> array .)


state 7

    (11) dataStruct -> set .

    CONST           reduce using rule 11 (dataStruct -> set .)
    LET             reduce using rule 11 (dataStruct -> set .)
    VAR             reduce using rule 11 (dataStruct -> set .)
    WHILE           reduce using rule 11 (dataStruct -> set .)
    FOR             reduce using rule 11 (dataStruct -> set .)
    $end            reduce using rule 11 (dataStruct -> set .)
    CLOSE_PARENTHESIS reduce using rule 11 (dataStruct -> set .)
    CLOSE_BRACE     reduce using rule 11 (dataStruct -> set .)


state 8

    (8) controlStruct -> while .

    CONST           reduce using rule 8 (controlStruct -> while .)
    LET             reduce using rule 8 (controlStruct -> while .)
    VAR             reduce using rule 8 (controlStruct -> while .)
    WHILE           reduce using rule 8 (controlStruct -> while .)
    FOR             reduce using rule 8 (controlStruct -> while .)
    $end            reduce using rule 8 (controlStruct -> while .)
    CLOSE_PARENTHESIS reduce using rule 8 (controlStruct -> while .)
    CLOSE_BRACE     reduce using rule 8 (controlStruct -> while .)


state 9

    (9) controlStruct -> for .

    CONST           reduce using rule 9 (controlStruct -> for .)
    LET             reduce using rule 9 (controlStruct -> for .)
    VAR             reduce using rule 9 (controlStruct -> for .)
    WHILE           reduce using rule 9 (controlStruct -> for .)
    FOR             reduce using rule 9 (controlStruct -> for .)
    $end            reduce using rule 9 (controlStruct -> for .)
    CLOSE_PARENTHESIS reduce using rule 9 (controlStruct -> for .)
    CLOSE_BRACE     reduce using rule 9 (controlStruct -> for .)


state 10

    (31) type -> CONST .

    NAME            reduce using rule 31 (type -> CONST .)


state 11

    (32) type -> LET .

    NAME            reduce using rule 32 (type -> LET .)


state 12

    (33) type -> VAR .

    NAME            reduce using rule 33 (type -> VAR .)


state 13

    (12) while -> WHILE . OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (13) while -> WHILE . OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    OPEN_PARENTHESIS shift and go to state 19


state 14

    (14) for -> FOR . OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    OPEN_PARENTHESIS shift and go to state 20


state 15

    (2) expression -> variable expression .

    $end            reduce using rule 2 (expression -> variable expression .)
    CLOSE_PARENTHESIS reduce using rule 2 (expression -> variable expression .)
    CLOSE_BRACE     reduce using rule 2 (expression -> variable expression .)


state 16

    (4) expression -> dataStruct expression .

    $end            reduce using rule 4 (expression -> dataStruct expression .)
    CLOSE_PARENTHESIS reduce using rule 4 (expression -> dataStruct expression .)
    CLOSE_BRACE     reduce using rule 4 (expression -> dataStruct expression .)


state 17

    (6) expression -> controlStruct expression .

    $end            reduce using rule 6 (expression -> controlStruct expression .)
    CLOSE_PARENTHESIS reduce using rule 6 (expression -> controlStruct expression .)
    CLOSE_BRACE     reduce using rule 6 (expression -> controlStruct expression .)


state 18

    (7) variable -> type NAME . IGUAL datatype SEMICOLON
    (42) array -> type NAME . IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (43) array -> type NAME . IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (44) set -> type NAME . IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (45) set -> type NAME . IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (46) set -> type NAME . IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON

    IGUAL           shift and go to state 21


state 19

    (12) while -> WHILE OPEN_PARENTHESIS . expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (13) while -> WHILE OPEN_PARENTHESIS . bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (29) bool -> . TRUE
    (30) bool -> . FALSE
    (7) variable -> . type NAME IGUAL datatype SEMICOLON
    (10) dataStruct -> . array
    (11) dataStruct -> . set
    (8) controlStruct -> . while
    (9) controlStruct -> . for
    (31) type -> . CONST
    (32) type -> . LET
    (33) type -> . VAR
    (42) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (43) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (44) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (45) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (46) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (12) while -> . WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (13) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (14) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    CONST           shift and go to state 10
    LET             shift and go to state 11
    VAR             shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14

    expression                     shift and go to state 22
    bool                           shift and go to state 23
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    type                           shift and go to state 5
    array                          shift and go to state 6
    set                            shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9

state 20

    (14) for -> FOR OPEN_PARENTHESIS . inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (15) inicialization -> . type NAME IGUAL NUMBER
    (16) inicialization -> . NAME IGUAL NUMBER
    (31) type -> . CONST
    (32) type -> . LET
    (33) type -> . VAR

    NAME            shift and go to state 28
    CONST           shift and go to state 10
    LET             shift and go to state 11
    VAR             shift and go to state 12

    inicialization                 shift and go to state 26
    type                           shift and go to state 27

state 21

    (7) variable -> type NAME IGUAL . datatype SEMICOLON
    (42) array -> type NAME IGUAL . OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (43) array -> type NAME IGUAL . NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (44) set -> type NAME IGUAL . NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (45) set -> type NAME IGUAL . NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (46) set -> type NAME IGUAL . NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (21) datatype -> . NUMBER
    (22) datatype -> . STRING
    (23) datatype -> . operations
    (24) datatype -> . CHAR
    (18) operations -> . NUMBER operand NUMBER
    (19) operations -> . NAME SUMA SUMA
    (20) operations -> . NAME RESTA RESTA

    OPEN_BRACKET    shift and go to state 31
    NEW             shift and go to state 32
    NUMBER          shift and go to state 33
    STRING          shift and go to state 34
    CHAR            shift and go to state 36
    NAME            shift and go to state 29

    datatype                       shift and go to state 30
    operations                     shift and go to state 35

state 22

    (12) while -> WHILE OPEN_PARENTHESIS expression . CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    CLOSE_PARENTHESIS shift and go to state 37


state 23

    (13) while -> WHILE OPEN_PARENTHESIS bool . CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    CLOSE_PARENTHESIS shift and go to state 38


state 24

    (29) bool -> TRUE .

    CLOSE_PARENTHESIS reduce using rule 29 (bool -> TRUE .)


state 25

    (30) bool -> FALSE .

    CLOSE_PARENTHESIS reduce using rule 30 (bool -> FALSE .)


state 26

    (14) for -> FOR OPEN_PARENTHESIS inicialization . SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    SEMICOLON       shift and go to state 39


state 27

    (15) inicialization -> type . NAME IGUAL NUMBER

    NAME            shift and go to state 40


state 28

    (16) inicialization -> NAME . IGUAL NUMBER

    IGUAL           shift and go to state 41


state 29

    (19) operations -> NAME . SUMA SUMA
    (20) operations -> NAME . RESTA RESTA

    SUMA            shift and go to state 42
    RESTA           shift and go to state 43


state 30

    (7) variable -> type NAME IGUAL datatype . SEMICOLON

    SEMICOLON       shift and go to state 44


state 31

    (42) array -> type NAME IGUAL OPEN_BRACKET . items CLOSE_BRACKET SEMICOLON
    (47) items -> . numeros
    (48) items -> . cadena
    (49) numeros -> . NUMBER
    (50) numeros -> . NUMBER COMMA numeros
    (51) cadena -> . STRING
    (52) cadena -> . STRING COMMA cadena

    NUMBER          shift and go to state 48
    STRING          shift and go to state 49

    items                          shift and go to state 45
    numeros                        shift and go to state 46
    cadena                         shift and go to state 47

state 32

    (43) array -> type NAME IGUAL NEW . ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (44) set -> type NAME IGUAL NEW . SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (45) set -> type NAME IGUAL NEW . SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (46) set -> type NAME IGUAL NEW . SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON

    ARRAY           shift and go to state 50
    SET             shift and go to state 51


state 33

    (21) datatype -> NUMBER .
    (18) operations -> NUMBER . operand NUMBER
    (25) operand -> . SUMA
    (26) operand -> . RESTA
    (27) operand -> . MULTIPLICACION
    (28) operand -> . DIVISION

    SEMICOLON       reduce using rule 21 (datatype -> NUMBER .)
    SUMA            shift and go to state 53
    RESTA           shift and go to state 54
    MULTIPLICACION  shift and go to state 55
    DIVISION        shift and go to state 56

    operand                        shift and go to state 52

state 34

    (22) datatype -> STRING .

    SEMICOLON       reduce using rule 22 (datatype -> STRING .)


state 35

    (23) datatype -> operations .

    SEMICOLON       reduce using rule 23 (datatype -> operations .)


state 36

    (24) datatype -> CHAR .

    SEMICOLON       reduce using rule 24 (datatype -> CHAR .)


state 37

    (12) while -> WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS . OPEN_BRACE expression CLOSE_BRACE

    OPEN_BRACE      shift and go to state 57


state 38

    (13) while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS . OPEN_BRACE expression CLOSE_BRACE

    OPEN_BRACE      shift and go to state 58


state 39

    (14) for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON . condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (17) condition -> . NAME clause value

    NAME            shift and go to state 60

    condition                      shift and go to state 59

state 40

    (15) inicialization -> type NAME . IGUAL NUMBER

    IGUAL           shift and go to state 61


state 41

    (16) inicialization -> NAME IGUAL . NUMBER

    NUMBER          shift and go to state 62


state 42

    (19) operations -> NAME SUMA . SUMA

    SUMA            shift and go to state 63


state 43

    (20) operations -> NAME RESTA . RESTA

    RESTA           shift and go to state 64


state 44

    (7) variable -> type NAME IGUAL datatype SEMICOLON .

    CONST           reduce using rule 7 (variable -> type NAME IGUAL datatype SEMICOLON .)
    LET             reduce using rule 7 (variable -> type NAME IGUAL datatype SEMICOLON .)
    VAR             reduce using rule 7 (variable -> type NAME IGUAL datatype SEMICOLON .)
    WHILE           reduce using rule 7 (variable -> type NAME IGUAL datatype SEMICOLON .)
    FOR             reduce using rule 7 (variable -> type NAME IGUAL datatype SEMICOLON .)
    $end            reduce using rule 7 (variable -> type NAME IGUAL datatype SEMICOLON .)
    CLOSE_PARENTHESIS reduce using rule 7 (variable -> type NAME IGUAL datatype SEMICOLON .)
    CLOSE_BRACE     reduce using rule 7 (variable -> type NAME IGUAL datatype SEMICOLON .)


state 45

    (42) array -> type NAME IGUAL OPEN_BRACKET items . CLOSE_BRACKET SEMICOLON

    CLOSE_BRACKET   shift and go to state 65


state 46

    (47) items -> numeros .

    CLOSE_BRACKET   reduce using rule 47 (items -> numeros .)
    CLOSE_PARENTHESIS reduce using rule 47 (items -> numeros .)


state 47

    (48) items -> cadena .

    CLOSE_BRACKET   reduce using rule 48 (items -> cadena .)
    CLOSE_PARENTHESIS reduce using rule 48 (items -> cadena .)


state 48

    (49) numeros -> NUMBER .
    (50) numeros -> NUMBER . COMMA numeros

    CLOSE_BRACKET   reduce using rule 49 (numeros -> NUMBER .)
    CLOSE_PARENTHESIS reduce using rule 49 (numeros -> NUMBER .)
    COMMA           shift and go to state 66


state 49

    (51) cadena -> STRING .
    (52) cadena -> STRING . COMMA cadena

    CLOSE_BRACKET   reduce using rule 51 (cadena -> STRING .)
    CLOSE_PARENTHESIS reduce using rule 51 (cadena -> STRING .)
    COMMA           shift and go to state 67


state 50

    (43) array -> type NAME IGUAL NEW ARRAY . OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON

    OPEN_PARENTHESIS shift and go to state 68


state 51

    (44) set -> type NAME IGUAL NEW SET . OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (45) set -> type NAME IGUAL NEW SET . OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (46) set -> type NAME IGUAL NEW SET . OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON

    OPEN_PARENTHESIS shift and go to state 69


state 52

    (18) operations -> NUMBER operand . NUMBER

    NUMBER          shift and go to state 70


state 53

    (25) operand -> SUMA .

    NUMBER          reduce using rule 25 (operand -> SUMA .)


state 54

    (26) operand -> RESTA .

    NUMBER          reduce using rule 26 (operand -> RESTA .)


state 55

    (27) operand -> MULTIPLICACION .

    NUMBER          reduce using rule 27 (operand -> MULTIPLICACION .)


state 56

    (28) operand -> DIVISION .

    NUMBER          reduce using rule 28 (operand -> DIVISION .)


state 57

    (12) while -> WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE . expression CLOSE_BRACE
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) variable -> . type NAME IGUAL datatype SEMICOLON
    (10) dataStruct -> . array
    (11) dataStruct -> . set
    (8) controlStruct -> . while
    (9) controlStruct -> . for
    (31) type -> . CONST
    (32) type -> . LET
    (33) type -> . VAR
    (42) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (43) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (44) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (45) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (46) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (12) while -> . WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (13) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (14) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    CONST           shift and go to state 10
    LET             shift and go to state 11
    VAR             shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14

    expression                     shift and go to state 71
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    type                           shift and go to state 5
    array                          shift and go to state 6
    set                            shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9

state 58

    (13) while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE . expression CLOSE_BRACE
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) variable -> . type NAME IGUAL datatype SEMICOLON
    (10) dataStruct -> . array
    (11) dataStruct -> . set
    (8) controlStruct -> . while
    (9) controlStruct -> . for
    (31) type -> . CONST
    (32) type -> . LET
    (33) type -> . VAR
    (42) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (43) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (44) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (45) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (46) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (12) while -> . WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (13) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (14) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    CONST           shift and go to state 10
    LET             shift and go to state 11
    VAR             shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14

    expression                     shift and go to state 72
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    type                           shift and go to state 5
    array                          shift and go to state 6
    set                            shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9

state 59

    (14) for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition . SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    SEMICOLON       shift and go to state 73


state 60

    (17) condition -> NAME . clause value
    (34) clause -> . IGUALIGUAL
    (35) clause -> . DIFERENTE
    (36) clause -> . MAYORQUE
    (37) clause -> . MAYORIGUALQUE
    (38) clause -> . MENORQUE
    (39) clause -> . MENORIGUALQUE

    IGUALIGUAL      shift and go to state 75
    DIFERENTE       shift and go to state 76
    MAYORQUE        shift and go to state 77
    MAYORIGUALQUE   shift and go to state 78
    MENORQUE        shift and go to state 79
    MENORIGUALQUE   shift and go to state 80

    clause                         shift and go to state 74

state 61

    (15) inicialization -> type NAME IGUAL . NUMBER

    NUMBER          shift and go to state 81


state 62

    (16) inicialization -> NAME IGUAL NUMBER .

    SEMICOLON       reduce using rule 16 (inicialization -> NAME IGUAL NUMBER .)


state 63

    (19) operations -> NAME SUMA SUMA .

    SEMICOLON       reduce using rule 19 (operations -> NAME SUMA SUMA .)
    CLOSE_PARENTHESIS reduce using rule 19 (operations -> NAME SUMA SUMA .)


state 64

    (20) operations -> NAME RESTA RESTA .

    SEMICOLON       reduce using rule 20 (operations -> NAME RESTA RESTA .)
    CLOSE_PARENTHESIS reduce using rule 20 (operations -> NAME RESTA RESTA .)


state 65

    (42) array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET . SEMICOLON

    SEMICOLON       shift and go to state 82


state 66

    (50) numeros -> NUMBER COMMA . numeros
    (49) numeros -> . NUMBER
    (50) numeros -> . NUMBER COMMA numeros

    NUMBER          shift and go to state 48

    numeros                        shift and go to state 83

state 67

    (52) cadena -> STRING COMMA . cadena
    (51) cadena -> . STRING
    (52) cadena -> . STRING COMMA cadena

    STRING          shift and go to state 49

    cadena                         shift and go to state 84

state 68

    (43) array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS . items CLOSE_PARENTHESIS SEMICOLON
    (47) items -> . numeros
    (48) items -> . cadena
    (49) numeros -> . NUMBER
    (50) numeros -> . NUMBER COMMA numeros
    (51) cadena -> . STRING
    (52) cadena -> . STRING COMMA cadena

    NUMBER          shift and go to state 48
    STRING          shift and go to state 49

    items                          shift and go to state 85
    numeros                        shift and go to state 46
    cadena                         shift and go to state 47

state 69

    (44) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS . CLOSE_PARENTHESIS SEMICOLON
    (45) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS . OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (46) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS . element CLOSE_PARENTHESIS SEMICOLON
    (53) element -> . STRING
    (54) element -> . NUMBER
    (55) element -> . NAME

    CLOSE_PARENTHESIS shift and go to state 87
    OPEN_BRACKET    shift and go to state 88
    STRING          shift and go to state 90
    NUMBER          shift and go to state 91
    NAME            shift and go to state 86

    element                        shift and go to state 89

state 70

    (18) operations -> NUMBER operand NUMBER .

    SEMICOLON       reduce using rule 18 (operations -> NUMBER operand NUMBER .)
    CLOSE_PARENTHESIS reduce using rule 18 (operations -> NUMBER operand NUMBER .)


state 71

    (12) while -> WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression . CLOSE_BRACE

    CLOSE_BRACE     shift and go to state 92


state 72

    (13) while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression . CLOSE_BRACE

    CLOSE_BRACE     shift and go to state 93


state 73

    (14) for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON . operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (18) operations -> . NUMBER operand NUMBER
    (19) operations -> . NAME SUMA SUMA
    (20) operations -> . NAME RESTA RESTA

    NUMBER          shift and go to state 95
    NAME            shift and go to state 29

    operations                     shift and go to state 94

state 74

    (17) condition -> NAME clause . value
    (40) value -> . NAME
    (41) value -> . NUMBER

    NAME            shift and go to state 96
    NUMBER          shift and go to state 98

    value                          shift and go to state 97

state 75

    (34) clause -> IGUALIGUAL .

    NAME            reduce using rule 34 (clause -> IGUALIGUAL .)
    NUMBER          reduce using rule 34 (clause -> IGUALIGUAL .)


state 76

    (35) clause -> DIFERENTE .

    NAME            reduce using rule 35 (clause -> DIFERENTE .)
    NUMBER          reduce using rule 35 (clause -> DIFERENTE .)


state 77

    (36) clause -> MAYORQUE .

    NAME            reduce using rule 36 (clause -> MAYORQUE .)
    NUMBER          reduce using rule 36 (clause -> MAYORQUE .)


state 78

    (37) clause -> MAYORIGUALQUE .

    NAME            reduce using rule 37 (clause -> MAYORIGUALQUE .)
    NUMBER          reduce using rule 37 (clause -> MAYORIGUALQUE .)


state 79

    (38) clause -> MENORQUE .

    NAME            reduce using rule 38 (clause -> MENORQUE .)
    NUMBER          reduce using rule 38 (clause -> MENORQUE .)


state 80

    (39) clause -> MENORIGUALQUE .

    NAME            reduce using rule 39 (clause -> MENORIGUALQUE .)
    NUMBER          reduce using rule 39 (clause -> MENORIGUALQUE .)


state 81

    (15) inicialization -> type NAME IGUAL NUMBER .

    SEMICOLON       reduce using rule 15 (inicialization -> type NAME IGUAL NUMBER .)


state 82

    (42) array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .

    CONST           reduce using rule 42 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    LET             reduce using rule 42 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    VAR             reduce using rule 42 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    WHILE           reduce using rule 42 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    FOR             reduce using rule 42 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    $end            reduce using rule 42 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    CLOSE_PARENTHESIS reduce using rule 42 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    CLOSE_BRACE     reduce using rule 42 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)


state 83

    (50) numeros -> NUMBER COMMA numeros .

    CLOSE_BRACKET   reduce using rule 50 (numeros -> NUMBER COMMA numeros .)
    CLOSE_PARENTHESIS reduce using rule 50 (numeros -> NUMBER COMMA numeros .)


state 84

    (52) cadena -> STRING COMMA cadena .

    CLOSE_BRACKET   reduce using rule 52 (cadena -> STRING COMMA cadena .)
    CLOSE_PARENTHESIS reduce using rule 52 (cadena -> STRING COMMA cadena .)


state 85

    (43) array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items . CLOSE_PARENTHESIS SEMICOLON

    CLOSE_PARENTHESIS shift and go to state 99


state 86

    (55) element -> NAME .

    CLOSE_PARENTHESIS reduce using rule 55 (element -> NAME .)


state 87

    (44) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 100


state 88

    (45) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET . items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (47) items -> . numeros
    (48) items -> . cadena
    (49) numeros -> . NUMBER
    (50) numeros -> . NUMBER COMMA numeros
    (51) cadena -> . STRING
    (52) cadena -> . STRING COMMA cadena

    NUMBER          shift and go to state 48
    STRING          shift and go to state 49

    items                          shift and go to state 101
    numeros                        shift and go to state 46
    cadena                         shift and go to state 47

state 89

    (46) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element . CLOSE_PARENTHESIS SEMICOLON

    CLOSE_PARENTHESIS shift and go to state 102


state 90

    (53) element -> STRING .

    CLOSE_PARENTHESIS reduce using rule 53 (element -> STRING .)


state 91

    (54) element -> NUMBER .

    CLOSE_PARENTHESIS reduce using rule 54 (element -> NUMBER .)


state 92

    (12) while -> WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .

    CONST           reduce using rule 12 (while -> WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    LET             reduce using rule 12 (while -> WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    VAR             reduce using rule 12 (while -> WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    WHILE           reduce using rule 12 (while -> WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    FOR             reduce using rule 12 (while -> WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    $end            reduce using rule 12 (while -> WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CLOSE_PARENTHESIS reduce using rule 12 (while -> WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 12 (while -> WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)


state 93

    (13) while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .

    CONST           reduce using rule 13 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    LET             reduce using rule 13 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    VAR             reduce using rule 13 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    WHILE           reduce using rule 13 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    FOR             reduce using rule 13 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    $end            reduce using rule 13 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CLOSE_PARENTHESIS reduce using rule 13 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 13 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)


state 94

    (14) for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations . CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    CLOSE_PARENTHESIS shift and go to state 103


state 95

    (18) operations -> NUMBER . operand NUMBER
    (25) operand -> . SUMA
    (26) operand -> . RESTA
    (27) operand -> . MULTIPLICACION
    (28) operand -> . DIVISION

    SUMA            shift and go to state 53
    RESTA           shift and go to state 54
    MULTIPLICACION  shift and go to state 55
    DIVISION        shift and go to state 56

    operand                        shift and go to state 52

state 96

    (40) value -> NAME .

    SEMICOLON       reduce using rule 40 (value -> NAME .)


state 97

    (17) condition -> NAME clause value .

    SEMICOLON       reduce using rule 17 (condition -> NAME clause value .)


state 98

    (41) value -> NUMBER .

    SEMICOLON       reduce using rule 41 (value -> NUMBER .)


state 99

    (43) array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 104


state 100

    (44) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .

    CONST           reduce using rule 44 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    LET             reduce using rule 44 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    VAR             reduce using rule 44 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    WHILE           reduce using rule 44 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    FOR             reduce using rule 44 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    $end            reduce using rule 44 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_PARENTHESIS reduce using rule 44 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 44 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)


state 101

    (45) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items . CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON

    CLOSE_BRACKET   shift and go to state 105


state 102

    (46) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 106


state 103

    (14) for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS . OPEN_BRACE expression CLOSE_BRACE

    OPEN_BRACE      shift and go to state 107


state 104

    (43) array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .

    CONST           reduce using rule 43 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    LET             reduce using rule 43 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    VAR             reduce using rule 43 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    WHILE           reduce using rule 43 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    FOR             reduce using rule 43 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    $end            reduce using rule 43 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_PARENTHESIS reduce using rule 43 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 43 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)


state 105

    (45) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET . CLOSE_PARENTHESIS SEMICOLON

    CLOSE_PARENTHESIS shift and go to state 108


state 106

    (46) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .

    CONST           reduce using rule 46 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    LET             reduce using rule 46 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    VAR             reduce using rule 46 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    WHILE           reduce using rule 46 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    FOR             reduce using rule 46 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    $end            reduce using rule 46 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_PARENTHESIS reduce using rule 46 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 46 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)


state 107

    (14) for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE . expression CLOSE_BRACE
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) variable -> . type NAME IGUAL datatype SEMICOLON
    (10) dataStruct -> . array
    (11) dataStruct -> . set
    (8) controlStruct -> . while
    (9) controlStruct -> . for
    (31) type -> . CONST
    (32) type -> . LET
    (33) type -> . VAR
    (42) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (43) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (44) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (45) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (46) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (12) while -> . WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (13) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (14) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    CONST           shift and go to state 10
    LET             shift and go to state 11
    VAR             shift and go to state 12
    WHILE           shift and go to state 13
    FOR             shift and go to state 14

    expression                     shift and go to state 109
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    type                           shift and go to state 5
    array                          shift and go to state 6
    set                            shift and go to state 7
    while                          shift and go to state 8
    for                            shift and go to state 9

state 108

    (45) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 110


state 109

    (14) for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression . CLOSE_BRACE

    CLOSE_BRACE     shift and go to state 111


state 110

    (45) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .

    CONST           reduce using rule 45 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    LET             reduce using rule 45 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    VAR             reduce using rule 45 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    WHILE           reduce using rule 45 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    FOR             reduce using rule 45 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    $end            reduce using rule 45 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_PARENTHESIS reduce using rule 45 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 45 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)


state 111

    (14) for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .

    CONST           reduce using rule 14 (for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    LET             reduce using rule 14 (for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    VAR             reduce using rule 14 (for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    WHILE           reduce using rule 14 (for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    FOR             reduce using rule 14 (for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    $end            reduce using rule 14 (for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CLOSE_PARENTHESIS reduce using rule 14 (for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 14 (for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)

