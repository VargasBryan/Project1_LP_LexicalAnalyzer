Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    BACKSLASH
    BOOLEAN
    BREAK
    CASE
    CLASS
    COMMENTS
    DEFAULT
    DIVIGUAL
    DOUBLE_QUOTES
    FLOAT
    FUNCTION
    INT
    LENGTH
    LINE_BREAK
    LONGCOMMENT
    MASIGUAL
    MENOSIGUAL
    MODIGUAL
    NOT
    NULL
    OR
    PORIGUAL
    POTIGUAL
    RETURN
    SINGLE_QUOTE
    STATIC
    SWITCH
    THEN
    TOSTRING
    TYPEOF
    UNDEFINED

Grammar

Rule 0     S' -> expression
Rule 1     expression -> variable
Rule 2     expression -> variable expression
Rule 3     expression -> dataStruct
Rule 4     expression -> dataStruct expression
Rule 5     expression -> controlStruct
Rule 6     expression -> controlStruct expression
Rule 7     expression -> methodsSet
Rule 8     expression -> mapFunctions
Rule 9     expression -> arrayFn
Rule 10    variable -> type NAME IGUAL datatype SEMICOLON
Rule 11    variable -> type NAME IGUAL operations SEMICOLON
Rule 12    variable -> NAME IGUAL datatype SEMICOLON
Rule 13    controlStruct -> while
Rule 14    controlStruct -> for
Rule 15    controlStruct -> if
Rule 16    dataStruct -> array
Rule 17    dataStruct -> set
Rule 18    dataStruct -> map
Rule 19    while -> WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
Rule 20    while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
Rule 21    if -> soloIf
Rule 22    if -> soloIf elseIf
Rule 23    if -> soloIf elseIf else
Rule 24    if -> soloIf else
Rule 25    soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
Rule 26    elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
Rule 27    elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf
Rule 28    else -> ELSE OPEN_BRACE expression CLOSE_BRACE
Rule 29    comparacion -> IGUALIGUAL
Rule 30    comparacion -> DIFERENTE
Rule 31    comparacion -> MAYORQUE
Rule 32    comparacion -> MAYORIGUALQUE
Rule 33    comparacion -> MENORQUE
Rule 34    comparacion -> MENORIGUALQUE
Rule 35    controlArg -> argUnico comparacion argUnico
Rule 36    for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
Rule 37    inicialization -> type NAME IGUAL NUMBER
Rule 38    inicialization -> NAME IGUAL NUMBER
Rule 39    condition -> NAME clause value
Rule 40    operations -> NUMBER operand NUMBER
Rule 41    operations -> NAME SUMA SUMA
Rule 42    operations -> NAME RESTA RESTA
Rule 43    datatype -> NUMBER
Rule 44    datatype -> STRING
Rule 45    datatype -> CHAR
Rule 46    operand -> SUMA
Rule 47    operand -> RESTA
Rule 48    operand -> MULTIPLICACION
Rule 49    operand -> DIVISION
Rule 50    bool -> TRUE
Rule 51    bool -> FALSE
Rule 52    type -> CONST
Rule 53    type -> LET
Rule 54    type -> VAR
Rule 55    clause -> IGUALIGUAL
Rule 56    clause -> DIFERENTE
Rule 57    clause -> MAYORQUE
Rule 58    clause -> MAYORIGUALQUE
Rule 59    clause -> MENORQUE
Rule 60    clause -> MENORIGUALQUE
Rule 61    value -> NAME
Rule 62    value -> NUMBER
Rule 63    array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
Rule 64    array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
Rule 65    map -> iniciarMap
Rule 66    map -> escribirMap
Rule 67    map -> generarMap
Rule 68    iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
Rule 69    escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
Rule 70    claveValor -> clave COLON valor
Rule 71    claveValor -> clave COLON valor COMMA claveValor
Rule 72    clave -> datatype
Rule 73    valor -> datatype
Rule 74    valor -> dataStruct
Rule 75    generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
Rule 76    tuplas -> tupla
Rule 77    tuplas -> tupla COMMA tuplas
Rule 78    tupla -> OPEN_BRACKET datatype CLOSE_BRACKET
Rule 79    tupla -> OPEN_BRACKET datatype COMMA datatype CLOSE_BRACKET
Rule 80    mapFunctions -> NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
Rule 81    mapFunctions -> NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
Rule 82    mapFunctions -> NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
Rule 83    arrayFn -> NAME POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS
Rule 84    arrayFn -> NAME POINT PUSH OPEN_PARENTHESIS argUnico CLOSE_PARENTHESIS
Rule 85    arrayFn -> NAME POINT UNSHIFT OPEN_PARENTHESIS argUnico CLOSE_PARENTHESIS
Rule 86    argUnico -> NUMBER
Rule 87    argUnico -> STRING
Rule 88    argUnico -> NAME
Rule 89    set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
Rule 90    set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
Rule 91    set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
Rule 92    set -> NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
Rule 93    set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
Rule 94    set -> NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
Rule 95    methodsSet -> NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
Rule 96    methodsSet -> NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
Rule 97    methodsSet -> NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
Rule 98    items -> numeros
Rule 99    items -> cadena
Rule 100   numeros -> NUMBER
Rule 101   numeros -> NUMBER COMMA numeros
Rule 102   cadena -> STRING
Rule 103   cadena -> STRING COMMA cadena
Rule 104   element -> STRING
Rule 105   element -> NUMBER
Rule 106   element -> NAME

Terminals, with rules where they appear

ADD                  : 95
AND                  : 
ARRAY                : 64
BACKSLASH            : 
BOOLEAN              : 
BREAK                : 
CASE                 : 
CHAR                 : 45
CLASS                : 
CLEAR                : 80 97
CLOSE_BRACE          : 19 20 25 26 27 28 36 69 75
CLOSE_BRACKET        : 63 78 79 90 93
CLOSE_PARENTHESIS    : 19 20 25 26 27 36 64 68 80 81 82 83 84 85 89 90 91 92 93 94 95 96 97
COLON                : 70 71
COMMA                : 71 77 79 101 103
COMMENTS             : 
CONST                : 52
DEFAULT              : 
DELETE               : 96
DIFERENTE            : 30 56
DIVIGUAL             : 
DIVISION             : 49
DOUBLE_QUOTES        : 
ELSE                 : 28
ELSEIF               : 26 27
FALSE                : 51
FLOAT                : 
FOR                  : 36
FUNCTION             : 
GET                  : 81
HAS                  : 82
IF                   : 25
IGUAL                : 10 11 12 37 38 63 64 68 69 75 89 90 91 92 93 94
IGUALIGUAL           : 29 55
INT                  : 
LENGTH               : 
LET                  : 53
LINE_BREAK           : 
LONGCOMMENT          : 
MAP                  : 68
MASIGUAL             : 
MAYORIGUALQUE        : 32 58
MAYORQUE             : 31 57
MENORIGUALQUE        : 34 60
MENORQUE             : 33 59
MENOSIGUAL           : 
MODIGUAL             : 
MULTIPLICACION       : 48
NAME                 : 10 11 12 37 38 39 41 42 61 63 64 80 81 82 83 84 85 88 89 90 91 92 93 94 95 96 97 106
NEW                  : 64 68 89 90 91 92 93 94
NOT                  : 
NULL                 : 
NUMBER               : 37 38 40 40 43 62 86 100 101 105
OPEN_BRACE           : 19 20 25 26 27 28 36 69 75
OPEN_BRACKET         : 63 78 79 90 93
OPEN_PARENTHESIS     : 19 20 25 26 27 36 64 68 80 81 82 83 84 85 89 90 91 92 93 94 95 96 97
OR                   : 
POINT                : 80 81 82 83 84 85 95 96 97
POP                  : 83
PORIGUAL             : 
POTIGUAL             : 
PUSH                 : 84
RESTA                : 42 42 47
RETURN               : 
SEMICOLON            : 10 11 12 36 36 63 64 68 80 81 82 89 90 91 92 93 94 95 96 97
SET                  : 89 90 91 92 93 94
SINGLE_QUOTE         : 
STATIC               : 
STRING               : 44 87 102 103 104
SUMA                 : 41 41 46
SWITCH               : 
THEN                 : 
TOSTRING             : 
TRUE                 : 50
TYPEOF               : 
UNDEFINED            : 
UNSHIFT              : 85
VAR                  : 54
WHILE                : 19 20
error                : 

Nonterminals, with rules where they appear

argUnico             : 35 35 84 85
array                : 16
arrayFn              : 9
bool                 : 20
cadena               : 99 103
clause               : 39
clave                : 70 71 81 82
claveValor           : 69 71
comparacion          : 35
condition            : 36
controlArg           : 19 25 26 27
controlStruct        : 5 6
dataStruct           : 3 4 74
datatype             : 10 12 72 73 78 79 79
element              : 91 94 95 96
else                 : 23 24
elseIf               : 22 23
escribirMap          : 66
expression           : 2 4 6 19 20 25 26 27 28 36 0
for                  : 14
generarMap           : 67
if                   : 15
inicialization       : 36
iniciarMap           : 65
items                : 63 64 90 93
map                  : 18
mapFunctions         : 8
methodsSet           : 7
numeros              : 98 101
operand              : 40
operations           : 11 36
set                  : 17
soloIf               : 21 22 23 24 27
tupla                : 76 77
tuplas               : 75 77
type                 : 10 11 37 63 64 89 90 91
valor                : 70 71
value                : 39
variable             : 1 2 68 69 75
while                : 13

Parsing method: LALR

state 0

    (0) S' -> . expression
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) expression -> . methodsSet
    (8) expression -> . mapFunctions
    (9) expression -> . arrayFn
    (10) variable -> . type NAME IGUAL datatype SEMICOLON
    (11) variable -> . type NAME IGUAL operations SEMICOLON
    (12) variable -> . NAME IGUAL datatype SEMICOLON
    (16) dataStruct -> . array
    (17) dataStruct -> . set
    (18) dataStruct -> . map
    (13) controlStruct -> . while
    (14) controlStruct -> . for
    (15) controlStruct -> . if
    (95) methodsSet -> . NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (96) methodsSet -> . NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (97) methodsSet -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (80) mapFunctions -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (81) mapFunctions -> . NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (82) mapFunctions -> . NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (83) arrayFn -> . NAME POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS
    (84) arrayFn -> . NAME POINT PUSH OPEN_PARENTHESIS argUnico CLOSE_PARENTHESIS
    (85) arrayFn -> . NAME POINT UNSHIFT OPEN_PARENTHESIS argUnico CLOSE_PARENTHESIS
    (52) type -> . CONST
    (53) type -> . LET
    (54) type -> . VAR
    (63) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (64) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (89) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (90) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (91) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (92) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (93) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (94) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (65) map -> . iniciarMap
    (66) map -> . escribirMap
    (67) map -> . generarMap
    (19) while -> . WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (20) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (36) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (21) if -> . soloIf
    (22) if -> . soloIf elseIf
    (23) if -> . soloIf elseIf else
    (24) if -> . soloIf else
    (68) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (69) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (75) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (25) soloIf -> . IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    NAME            shift and go to state 9
    CONST           shift and go to state 16
    LET             shift and go to state 17
    VAR             shift and go to state 18
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    IF              shift and go to state 25

    expression                     shift and go to state 1
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    methodsSet                     shift and go to state 5
    mapFunctions                   shift and go to state 6
    arrayFn                        shift and go to state 7
    type                           shift and go to state 8
    array                          shift and go to state 10
    set                            shift and go to state 11
    map                            shift and go to state 12
    while                          shift and go to state 13
    for                            shift and go to state 14
    if                             shift and go to state 15
    iniciarMap                     shift and go to state 19
    escribirMap                    shift and go to state 20
    generarMap                     shift and go to state 21
    soloIf                         shift and go to state 24

state 1

    (0) S' -> expression .



state 2

    (1) expression -> variable .
    (2) expression -> variable . expression
    (68) iniciarMap -> variable . IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (69) escribirMap -> variable . IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (75) generarMap -> variable . IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) expression -> . methodsSet
    (8) expression -> . mapFunctions
    (9) expression -> . arrayFn
    (10) variable -> . type NAME IGUAL datatype SEMICOLON
    (11) variable -> . type NAME IGUAL operations SEMICOLON
    (12) variable -> . NAME IGUAL datatype SEMICOLON
    (16) dataStruct -> . array
    (17) dataStruct -> . set
    (18) dataStruct -> . map
    (13) controlStruct -> . while
    (14) controlStruct -> . for
    (15) controlStruct -> . if
    (95) methodsSet -> . NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (96) methodsSet -> . NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (97) methodsSet -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (80) mapFunctions -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (81) mapFunctions -> . NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (82) mapFunctions -> . NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (83) arrayFn -> . NAME POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS
    (84) arrayFn -> . NAME POINT PUSH OPEN_PARENTHESIS argUnico CLOSE_PARENTHESIS
    (85) arrayFn -> . NAME POINT UNSHIFT OPEN_PARENTHESIS argUnico CLOSE_PARENTHESIS
    (52) type -> . CONST
    (53) type -> . LET
    (54) type -> . VAR
    (63) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (64) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (89) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (90) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (91) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (92) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (93) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (94) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (65) map -> . iniciarMap
    (66) map -> . escribirMap
    (67) map -> . generarMap
    (19) while -> . WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (20) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (36) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (21) if -> . soloIf
    (22) if -> . soloIf elseIf
    (23) if -> . soloIf elseIf else
    (24) if -> . soloIf else
    (68) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (69) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (75) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (25) soloIf -> . IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    $end            reduce using rule 1 (expression -> variable .)
    CLOSE_BRACE     reduce using rule 1 (expression -> variable .)
    IGUAL           shift and go to state 27
    NAME            shift and go to state 9
    CONST           shift and go to state 16
    LET             shift and go to state 17
    VAR             shift and go to state 18
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    IF              shift and go to state 25

    variable                       shift and go to state 2
    expression                     shift and go to state 26
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    methodsSet                     shift and go to state 5
    mapFunctions                   shift and go to state 6
    arrayFn                        shift and go to state 7
    type                           shift and go to state 8
    array                          shift and go to state 10
    set                            shift and go to state 11
    map                            shift and go to state 12
    while                          shift and go to state 13
    for                            shift and go to state 14
    if                             shift and go to state 15
    iniciarMap                     shift and go to state 19
    escribirMap                    shift and go to state 20
    generarMap                     shift and go to state 21
    soloIf                         shift and go to state 24

state 3

    (3) expression -> dataStruct .
    (4) expression -> dataStruct . expression
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) expression -> . methodsSet
    (8) expression -> . mapFunctions
    (9) expression -> . arrayFn
    (10) variable -> . type NAME IGUAL datatype SEMICOLON
    (11) variable -> . type NAME IGUAL operations SEMICOLON
    (12) variable -> . NAME IGUAL datatype SEMICOLON
    (16) dataStruct -> . array
    (17) dataStruct -> . set
    (18) dataStruct -> . map
    (13) controlStruct -> . while
    (14) controlStruct -> . for
    (15) controlStruct -> . if
    (95) methodsSet -> . NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (96) methodsSet -> . NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (97) methodsSet -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (80) mapFunctions -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (81) mapFunctions -> . NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (82) mapFunctions -> . NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (83) arrayFn -> . NAME POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS
    (84) arrayFn -> . NAME POINT PUSH OPEN_PARENTHESIS argUnico CLOSE_PARENTHESIS
    (85) arrayFn -> . NAME POINT UNSHIFT OPEN_PARENTHESIS argUnico CLOSE_PARENTHESIS
    (52) type -> . CONST
    (53) type -> . LET
    (54) type -> . VAR
    (63) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (64) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (89) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (90) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (91) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (92) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (93) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (94) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (65) map -> . iniciarMap
    (66) map -> . escribirMap
    (67) map -> . generarMap
    (19) while -> . WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (20) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (36) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (21) if -> . soloIf
    (22) if -> . soloIf elseIf
    (23) if -> . soloIf elseIf else
    (24) if -> . soloIf else
    (68) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (69) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (75) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (25) soloIf -> . IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    $end            reduce using rule 3 (expression -> dataStruct .)
    CLOSE_BRACE     reduce using rule 3 (expression -> dataStruct .)
    NAME            shift and go to state 9
    CONST           shift and go to state 16
    LET             shift and go to state 17
    VAR             shift and go to state 18
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    IF              shift and go to state 25

    dataStruct                     shift and go to state 3
    expression                     shift and go to state 28
    variable                       shift and go to state 2
    controlStruct                  shift and go to state 4
    methodsSet                     shift and go to state 5
    mapFunctions                   shift and go to state 6
    arrayFn                        shift and go to state 7
    type                           shift and go to state 8
    array                          shift and go to state 10
    set                            shift and go to state 11
    map                            shift and go to state 12
    while                          shift and go to state 13
    for                            shift and go to state 14
    if                             shift and go to state 15
    iniciarMap                     shift and go to state 19
    escribirMap                    shift and go to state 20
    generarMap                     shift and go to state 21
    soloIf                         shift and go to state 24

state 4

    (5) expression -> controlStruct .
    (6) expression -> controlStruct . expression
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) expression -> . methodsSet
    (8) expression -> . mapFunctions
    (9) expression -> . arrayFn
    (10) variable -> . type NAME IGUAL datatype SEMICOLON
    (11) variable -> . type NAME IGUAL operations SEMICOLON
    (12) variable -> . NAME IGUAL datatype SEMICOLON
    (16) dataStruct -> . array
    (17) dataStruct -> . set
    (18) dataStruct -> . map
    (13) controlStruct -> . while
    (14) controlStruct -> . for
    (15) controlStruct -> . if
    (95) methodsSet -> . NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (96) methodsSet -> . NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (97) methodsSet -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (80) mapFunctions -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (81) mapFunctions -> . NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (82) mapFunctions -> . NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (83) arrayFn -> . NAME POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS
    (84) arrayFn -> . NAME POINT PUSH OPEN_PARENTHESIS argUnico CLOSE_PARENTHESIS
    (85) arrayFn -> . NAME POINT UNSHIFT OPEN_PARENTHESIS argUnico CLOSE_PARENTHESIS
    (52) type -> . CONST
    (53) type -> . LET
    (54) type -> . VAR
    (63) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (64) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (89) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (90) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (91) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (92) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (93) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (94) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (65) map -> . iniciarMap
    (66) map -> . escribirMap
    (67) map -> . generarMap
    (19) while -> . WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (20) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (36) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (21) if -> . soloIf
    (22) if -> . soloIf elseIf
    (23) if -> . soloIf elseIf else
    (24) if -> . soloIf else
    (68) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (69) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (75) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (25) soloIf -> . IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    $end            reduce using rule 5 (expression -> controlStruct .)
    CLOSE_BRACE     reduce using rule 5 (expression -> controlStruct .)
    NAME            shift and go to state 9
    CONST           shift and go to state 16
    LET             shift and go to state 17
    VAR             shift and go to state 18
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    IF              shift and go to state 25

    controlStruct                  shift and go to state 4
    expression                     shift and go to state 29
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    methodsSet                     shift and go to state 5
    mapFunctions                   shift and go to state 6
    arrayFn                        shift and go to state 7
    type                           shift and go to state 8
    array                          shift and go to state 10
    set                            shift and go to state 11
    map                            shift and go to state 12
    while                          shift and go to state 13
    for                            shift and go to state 14
    if                             shift and go to state 15
    iniciarMap                     shift and go to state 19
    escribirMap                    shift and go to state 20
    generarMap                     shift and go to state 21
    soloIf                         shift and go to state 24

state 5

    (7) expression -> methodsSet .

    $end            reduce using rule 7 (expression -> methodsSet .)
    CLOSE_BRACE     reduce using rule 7 (expression -> methodsSet .)


state 6

    (8) expression -> mapFunctions .

    $end            reduce using rule 8 (expression -> mapFunctions .)
    CLOSE_BRACE     reduce using rule 8 (expression -> mapFunctions .)


state 7

    (9) expression -> arrayFn .

    $end            reduce using rule 9 (expression -> arrayFn .)
    CLOSE_BRACE     reduce using rule 9 (expression -> arrayFn .)


state 8

    (10) variable -> type . NAME IGUAL datatype SEMICOLON
    (11) variable -> type . NAME IGUAL operations SEMICOLON
    (63) array -> type . NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (64) array -> type . NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (89) set -> type . NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (90) set -> type . NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (91) set -> type . NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON

    NAME            shift and go to state 30


state 9

    (12) variable -> NAME . IGUAL datatype SEMICOLON
    (95) methodsSet -> NAME . POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (96) methodsSet -> NAME . POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (97) methodsSet -> NAME . POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (80) mapFunctions -> NAME . POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (81) mapFunctions -> NAME . POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (82) mapFunctions -> NAME . POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (83) arrayFn -> NAME . POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS
    (84) arrayFn -> NAME . POINT PUSH OPEN_PARENTHESIS argUnico CLOSE_PARENTHESIS
    (85) arrayFn -> NAME . POINT UNSHIFT OPEN_PARENTHESIS argUnico CLOSE_PARENTHESIS
    (92) set -> NAME . IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (93) set -> NAME . IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (94) set -> NAME . IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON

    IGUAL           shift and go to state 31
    POINT           shift and go to state 32


state 10

    (16) dataStruct -> array .

    NAME            reduce using rule 16 (dataStruct -> array .)
    CONST           reduce using rule 16 (dataStruct -> array .)
    LET             reduce using rule 16 (dataStruct -> array .)
    VAR             reduce using rule 16 (dataStruct -> array .)
    WHILE           reduce using rule 16 (dataStruct -> array .)
    FOR             reduce using rule 16 (dataStruct -> array .)
    IF              reduce using rule 16 (dataStruct -> array .)
    $end            reduce using rule 16 (dataStruct -> array .)
    CLOSE_BRACE     reduce using rule 16 (dataStruct -> array .)
    COMMA           reduce using rule 16 (dataStruct -> array .)


state 11

    (17) dataStruct -> set .

    NAME            reduce using rule 17 (dataStruct -> set .)
    CONST           reduce using rule 17 (dataStruct -> set .)
    LET             reduce using rule 17 (dataStruct -> set .)
    VAR             reduce using rule 17 (dataStruct -> set .)
    WHILE           reduce using rule 17 (dataStruct -> set .)
    FOR             reduce using rule 17 (dataStruct -> set .)
    IF              reduce using rule 17 (dataStruct -> set .)
    $end            reduce using rule 17 (dataStruct -> set .)
    CLOSE_BRACE     reduce using rule 17 (dataStruct -> set .)
    COMMA           reduce using rule 17 (dataStruct -> set .)


state 12

    (18) dataStruct -> map .

    NAME            reduce using rule 18 (dataStruct -> map .)
    CONST           reduce using rule 18 (dataStruct -> map .)
    LET             reduce using rule 18 (dataStruct -> map .)
    VAR             reduce using rule 18 (dataStruct -> map .)
    WHILE           reduce using rule 18 (dataStruct -> map .)
    FOR             reduce using rule 18 (dataStruct -> map .)
    IF              reduce using rule 18 (dataStruct -> map .)
    $end            reduce using rule 18 (dataStruct -> map .)
    CLOSE_BRACE     reduce using rule 18 (dataStruct -> map .)
    COMMA           reduce using rule 18 (dataStruct -> map .)


state 13

    (13) controlStruct -> while .

    NAME            reduce using rule 13 (controlStruct -> while .)
    CONST           reduce using rule 13 (controlStruct -> while .)
    LET             reduce using rule 13 (controlStruct -> while .)
    VAR             reduce using rule 13 (controlStruct -> while .)
    WHILE           reduce using rule 13 (controlStruct -> while .)
    FOR             reduce using rule 13 (controlStruct -> while .)
    IF              reduce using rule 13 (controlStruct -> while .)
    $end            reduce using rule 13 (controlStruct -> while .)
    CLOSE_BRACE     reduce using rule 13 (controlStruct -> while .)


state 14

    (14) controlStruct -> for .

    NAME            reduce using rule 14 (controlStruct -> for .)
    CONST           reduce using rule 14 (controlStruct -> for .)
    LET             reduce using rule 14 (controlStruct -> for .)
    VAR             reduce using rule 14 (controlStruct -> for .)
    WHILE           reduce using rule 14 (controlStruct -> for .)
    FOR             reduce using rule 14 (controlStruct -> for .)
    IF              reduce using rule 14 (controlStruct -> for .)
    $end            reduce using rule 14 (controlStruct -> for .)
    CLOSE_BRACE     reduce using rule 14 (controlStruct -> for .)


state 15

    (15) controlStruct -> if .

    NAME            reduce using rule 15 (controlStruct -> if .)
    CONST           reduce using rule 15 (controlStruct -> if .)
    LET             reduce using rule 15 (controlStruct -> if .)
    VAR             reduce using rule 15 (controlStruct -> if .)
    WHILE           reduce using rule 15 (controlStruct -> if .)
    FOR             reduce using rule 15 (controlStruct -> if .)
    IF              reduce using rule 15 (controlStruct -> if .)
    $end            reduce using rule 15 (controlStruct -> if .)
    CLOSE_BRACE     reduce using rule 15 (controlStruct -> if .)


state 16

    (52) type -> CONST .

    NAME            reduce using rule 52 (type -> CONST .)


state 17

    (53) type -> LET .

    NAME            reduce using rule 53 (type -> LET .)


state 18

    (54) type -> VAR .

    NAME            reduce using rule 54 (type -> VAR .)


state 19

    (65) map -> iniciarMap .

    NAME            reduce using rule 65 (map -> iniciarMap .)
    CONST           reduce using rule 65 (map -> iniciarMap .)
    LET             reduce using rule 65 (map -> iniciarMap .)
    VAR             reduce using rule 65 (map -> iniciarMap .)
    WHILE           reduce using rule 65 (map -> iniciarMap .)
    FOR             reduce using rule 65 (map -> iniciarMap .)
    IF              reduce using rule 65 (map -> iniciarMap .)
    $end            reduce using rule 65 (map -> iniciarMap .)
    CLOSE_BRACE     reduce using rule 65 (map -> iniciarMap .)
    COMMA           reduce using rule 65 (map -> iniciarMap .)


state 20

    (66) map -> escribirMap .

    NAME            reduce using rule 66 (map -> escribirMap .)
    CONST           reduce using rule 66 (map -> escribirMap .)
    LET             reduce using rule 66 (map -> escribirMap .)
    VAR             reduce using rule 66 (map -> escribirMap .)
    WHILE           reduce using rule 66 (map -> escribirMap .)
    FOR             reduce using rule 66 (map -> escribirMap .)
    IF              reduce using rule 66 (map -> escribirMap .)
    $end            reduce using rule 66 (map -> escribirMap .)
    CLOSE_BRACE     reduce using rule 66 (map -> escribirMap .)
    COMMA           reduce using rule 66 (map -> escribirMap .)


state 21

    (67) map -> generarMap .

    NAME            reduce using rule 67 (map -> generarMap .)
    CONST           reduce using rule 67 (map -> generarMap .)
    LET             reduce using rule 67 (map -> generarMap .)
    VAR             reduce using rule 67 (map -> generarMap .)
    WHILE           reduce using rule 67 (map -> generarMap .)
    FOR             reduce using rule 67 (map -> generarMap .)
    IF              reduce using rule 67 (map -> generarMap .)
    $end            reduce using rule 67 (map -> generarMap .)
    CLOSE_BRACE     reduce using rule 67 (map -> generarMap .)
    COMMA           reduce using rule 67 (map -> generarMap .)


state 22

    (19) while -> WHILE . OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (20) while -> WHILE . OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    OPEN_PARENTHESIS shift and go to state 33


state 23

    (36) for -> FOR . OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    OPEN_PARENTHESIS shift and go to state 34


state 24

    (21) if -> soloIf .
    (22) if -> soloIf . elseIf
    (23) if -> soloIf . elseIf else
    (24) if -> soloIf . else
    (26) elseIf -> . ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (27) elseIf -> . ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf
    (28) else -> . ELSE OPEN_BRACE expression CLOSE_BRACE

    NAME            reduce using rule 21 (if -> soloIf .)
    CONST           reduce using rule 21 (if -> soloIf .)
    LET             reduce using rule 21 (if -> soloIf .)
    VAR             reduce using rule 21 (if -> soloIf .)
    WHILE           reduce using rule 21 (if -> soloIf .)
    FOR             reduce using rule 21 (if -> soloIf .)
    IF              reduce using rule 21 (if -> soloIf .)
    $end            reduce using rule 21 (if -> soloIf .)
    CLOSE_BRACE     reduce using rule 21 (if -> soloIf .)
    ELSEIF          shift and go to state 37
    ELSE            shift and go to state 38

    elseIf                         shift and go to state 35
    else                           shift and go to state 36

state 25

    (25) soloIf -> IF . OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    OPEN_PARENTHESIS shift and go to state 39


state 26

    (2) expression -> variable expression .

    $end            reduce using rule 2 (expression -> variable expression .)
    CLOSE_BRACE     reduce using rule 2 (expression -> variable expression .)


state 27

    (68) iniciarMap -> variable IGUAL . NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (69) escribirMap -> variable IGUAL . OPEN_BRACE claveValor CLOSE_BRACE
    (75) generarMap -> variable IGUAL . OPEN_BRACE tuplas CLOSE_BRACE

    NEW             shift and go to state 40
    OPEN_BRACE      shift and go to state 41


state 28

    (4) expression -> dataStruct expression .

    $end            reduce using rule 4 (expression -> dataStruct expression .)
    CLOSE_BRACE     reduce using rule 4 (expression -> dataStruct expression .)


state 29

    (6) expression -> controlStruct expression .

    $end            reduce using rule 6 (expression -> controlStruct expression .)
    CLOSE_BRACE     reduce using rule 6 (expression -> controlStruct expression .)


state 30

    (10) variable -> type NAME . IGUAL datatype SEMICOLON
    (11) variable -> type NAME . IGUAL operations SEMICOLON
    (63) array -> type NAME . IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (64) array -> type NAME . IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (89) set -> type NAME . IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (90) set -> type NAME . IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (91) set -> type NAME . IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON

    IGUAL           shift and go to state 42


state 31

    (12) variable -> NAME IGUAL . datatype SEMICOLON
    (92) set -> NAME IGUAL . NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (93) set -> NAME IGUAL . NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (94) set -> NAME IGUAL . NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (43) datatype -> . NUMBER
    (44) datatype -> . STRING
    (45) datatype -> . CHAR

    NEW             shift and go to state 44
    NUMBER          shift and go to state 45
    STRING          shift and go to state 46
    CHAR            shift and go to state 47

    datatype                       shift and go to state 43

state 32

    (95) methodsSet -> NAME POINT . ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (96) methodsSet -> NAME POINT . DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (97) methodsSet -> NAME POINT . CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (80) mapFunctions -> NAME POINT . CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (81) mapFunctions -> NAME POINT . GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (82) mapFunctions -> NAME POINT . HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (83) arrayFn -> NAME POINT . POP OPEN_PARENTHESIS CLOSE_PARENTHESIS
    (84) arrayFn -> NAME POINT . PUSH OPEN_PARENTHESIS argUnico CLOSE_PARENTHESIS
    (85) arrayFn -> NAME POINT . UNSHIFT OPEN_PARENTHESIS argUnico CLOSE_PARENTHESIS

    ADD             shift and go to state 48
    DELETE          shift and go to state 49
    CLEAR           shift and go to state 50
    GET             shift and go to state 51
    HAS             shift and go to state 52
    POP             shift and go to state 53
    PUSH            shift and go to state 54
    UNSHIFT         shift and go to state 55


state 33

    (19) while -> WHILE OPEN_PARENTHESIS . controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (20) while -> WHILE OPEN_PARENTHESIS . bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (35) controlArg -> . argUnico comparacion argUnico
    (50) bool -> . TRUE
    (51) bool -> . FALSE
    (86) argUnico -> . NUMBER
    (87) argUnico -> . STRING
    (88) argUnico -> . NAME

    TRUE            shift and go to state 59
    FALSE           shift and go to state 60
    NUMBER          shift and go to state 61
    STRING          shift and go to state 62
    NAME            shift and go to state 63

    controlArg                     shift and go to state 56
    bool                           shift and go to state 57
    argUnico                       shift and go to state 58

state 34

    (36) for -> FOR OPEN_PARENTHESIS . inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (37) inicialization -> . type NAME IGUAL NUMBER
    (38) inicialization -> . NAME IGUAL NUMBER
    (52) type -> . CONST
    (53) type -> . LET
    (54) type -> . VAR

    NAME            shift and go to state 66
    CONST           shift and go to state 16
    LET             shift and go to state 17
    VAR             shift and go to state 18

    inicialization                 shift and go to state 64
    type                           shift and go to state 65

state 35

    (22) if -> soloIf elseIf .
    (23) if -> soloIf elseIf . else
    (28) else -> . ELSE OPEN_BRACE expression CLOSE_BRACE

    NAME            reduce using rule 22 (if -> soloIf elseIf .)
    CONST           reduce using rule 22 (if -> soloIf elseIf .)
    LET             reduce using rule 22 (if -> soloIf elseIf .)
    VAR             reduce using rule 22 (if -> soloIf elseIf .)
    WHILE           reduce using rule 22 (if -> soloIf elseIf .)
    FOR             reduce using rule 22 (if -> soloIf elseIf .)
    IF              reduce using rule 22 (if -> soloIf elseIf .)
    $end            reduce using rule 22 (if -> soloIf elseIf .)
    CLOSE_BRACE     reduce using rule 22 (if -> soloIf elseIf .)
    ELSE            shift and go to state 38

    else                           shift and go to state 67

state 36

    (24) if -> soloIf else .

    NAME            reduce using rule 24 (if -> soloIf else .)
    CONST           reduce using rule 24 (if -> soloIf else .)
    LET             reduce using rule 24 (if -> soloIf else .)
    VAR             reduce using rule 24 (if -> soloIf else .)
    WHILE           reduce using rule 24 (if -> soloIf else .)
    FOR             reduce using rule 24 (if -> soloIf else .)
    IF              reduce using rule 24 (if -> soloIf else .)
    $end            reduce using rule 24 (if -> soloIf else .)
    CLOSE_BRACE     reduce using rule 24 (if -> soloIf else .)


state 37

    (26) elseIf -> ELSEIF . OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (27) elseIf -> ELSEIF . OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf

    OPEN_PARENTHESIS shift and go to state 68


state 38

    (28) else -> ELSE . OPEN_BRACE expression CLOSE_BRACE

    OPEN_BRACE      shift and go to state 69


state 39

    (25) soloIf -> IF OPEN_PARENTHESIS . controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (35) controlArg -> . argUnico comparacion argUnico
    (86) argUnico -> . NUMBER
    (87) argUnico -> . STRING
    (88) argUnico -> . NAME

    NUMBER          shift and go to state 61
    STRING          shift and go to state 62
    NAME            shift and go to state 63

    controlArg                     shift and go to state 70
    argUnico                       shift and go to state 58

state 40

    (68) iniciarMap -> variable IGUAL NEW . MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON

    MAP             shift and go to state 71


state 41

    (69) escribirMap -> variable IGUAL OPEN_BRACE . claveValor CLOSE_BRACE
    (75) generarMap -> variable IGUAL OPEN_BRACE . tuplas CLOSE_BRACE
    (70) claveValor -> . clave COLON valor
    (71) claveValor -> . clave COLON valor COMMA claveValor
    (76) tuplas -> . tupla
    (77) tuplas -> . tupla COMMA tuplas
    (72) clave -> . datatype
    (78) tupla -> . OPEN_BRACKET datatype CLOSE_BRACKET
    (79) tupla -> . OPEN_BRACKET datatype COMMA datatype CLOSE_BRACKET
    (43) datatype -> . NUMBER
    (44) datatype -> . STRING
    (45) datatype -> . CHAR

    OPEN_BRACKET    shift and go to state 77
    NUMBER          shift and go to state 45
    STRING          shift and go to state 46
    CHAR            shift and go to state 47

    claveValor                     shift and go to state 72
    tuplas                         shift and go to state 73
    clave                          shift and go to state 74
    tupla                          shift and go to state 75
    datatype                       shift and go to state 76

state 42

    (10) variable -> type NAME IGUAL . datatype SEMICOLON
    (11) variable -> type NAME IGUAL . operations SEMICOLON
    (63) array -> type NAME IGUAL . OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (64) array -> type NAME IGUAL . NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (89) set -> type NAME IGUAL . NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (90) set -> type NAME IGUAL . NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (91) set -> type NAME IGUAL . NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (43) datatype -> . NUMBER
    (44) datatype -> . STRING
    (45) datatype -> . CHAR
    (40) operations -> . NUMBER operand NUMBER
    (41) operations -> . NAME SUMA SUMA
    (42) operations -> . NAME RESTA RESTA

    OPEN_BRACKET    shift and go to state 81
    NEW             shift and go to state 82
    NUMBER          shift and go to state 83
    STRING          shift and go to state 46
    CHAR            shift and go to state 47
    NAME            shift and go to state 78

    datatype                       shift and go to state 79
    operations                     shift and go to state 80

state 43

    (12) variable -> NAME IGUAL datatype . SEMICOLON

    SEMICOLON       shift and go to state 84


state 44

    (92) set -> NAME IGUAL NEW . SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (93) set -> NAME IGUAL NEW . SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (94) set -> NAME IGUAL NEW . SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON

    SET             shift and go to state 85


state 45

    (43) datatype -> NUMBER .

    SEMICOLON       reduce using rule 43 (datatype -> NUMBER .)
    COLON           reduce using rule 43 (datatype -> NUMBER .)
    CLOSE_BRACKET   reduce using rule 43 (datatype -> NUMBER .)
    COMMA           reduce using rule 43 (datatype -> NUMBER .)
    CLOSE_PARENTHESIS reduce using rule 43 (datatype -> NUMBER .)
    CLOSE_BRACE     reduce using rule 43 (datatype -> NUMBER .)


state 46

    (44) datatype -> STRING .

    SEMICOLON       reduce using rule 44 (datatype -> STRING .)
    COLON           reduce using rule 44 (datatype -> STRING .)
    CLOSE_BRACKET   reduce using rule 44 (datatype -> STRING .)
    COMMA           reduce using rule 44 (datatype -> STRING .)
    CLOSE_PARENTHESIS reduce using rule 44 (datatype -> STRING .)
    CLOSE_BRACE     reduce using rule 44 (datatype -> STRING .)


state 47

    (45) datatype -> CHAR .

    SEMICOLON       reduce using rule 45 (datatype -> CHAR .)
    COLON           reduce using rule 45 (datatype -> CHAR .)
    CLOSE_BRACKET   reduce using rule 45 (datatype -> CHAR .)
    COMMA           reduce using rule 45 (datatype -> CHAR .)
    CLOSE_PARENTHESIS reduce using rule 45 (datatype -> CHAR .)
    CLOSE_BRACE     reduce using rule 45 (datatype -> CHAR .)


state 48

    (95) methodsSet -> NAME POINT ADD . OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON

    OPEN_PARENTHESIS shift and go to state 86


state 49

    (96) methodsSet -> NAME POINT DELETE . OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON

    OPEN_PARENTHESIS shift and go to state 87


state 50

    (97) methodsSet -> NAME POINT CLEAR . OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (80) mapFunctions -> NAME POINT CLEAR . OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON

    OPEN_PARENTHESIS shift and go to state 88


state 51

    (81) mapFunctions -> NAME POINT GET . OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON

    OPEN_PARENTHESIS shift and go to state 89


state 52

    (82) mapFunctions -> NAME POINT HAS . OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON

    OPEN_PARENTHESIS shift and go to state 90


state 53

    (83) arrayFn -> NAME POINT POP . OPEN_PARENTHESIS CLOSE_PARENTHESIS

    OPEN_PARENTHESIS shift and go to state 91


state 54

    (84) arrayFn -> NAME POINT PUSH . OPEN_PARENTHESIS argUnico CLOSE_PARENTHESIS

    OPEN_PARENTHESIS shift and go to state 92


state 55

    (85) arrayFn -> NAME POINT UNSHIFT . OPEN_PARENTHESIS argUnico CLOSE_PARENTHESIS

    OPEN_PARENTHESIS shift and go to state 93


state 56

    (19) while -> WHILE OPEN_PARENTHESIS controlArg . CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    CLOSE_PARENTHESIS shift and go to state 94


state 57

    (20) while -> WHILE OPEN_PARENTHESIS bool . CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    CLOSE_PARENTHESIS shift and go to state 95


state 58

    (35) controlArg -> argUnico . comparacion argUnico
    (29) comparacion -> . IGUALIGUAL
    (30) comparacion -> . DIFERENTE
    (31) comparacion -> . MAYORQUE
    (32) comparacion -> . MAYORIGUALQUE
    (33) comparacion -> . MENORQUE
    (34) comparacion -> . MENORIGUALQUE

    IGUALIGUAL      shift and go to state 97
    DIFERENTE       shift and go to state 98
    MAYORQUE        shift and go to state 99
    MAYORIGUALQUE   shift and go to state 100
    MENORQUE        shift and go to state 101
    MENORIGUALQUE   shift and go to state 102

    comparacion                    shift and go to state 96

state 59

    (50) bool -> TRUE .

    CLOSE_PARENTHESIS reduce using rule 50 (bool -> TRUE .)


state 60

    (51) bool -> FALSE .

    CLOSE_PARENTHESIS reduce using rule 51 (bool -> FALSE .)


state 61

    (86) argUnico -> NUMBER .

    IGUALIGUAL      reduce using rule 86 (argUnico -> NUMBER .)
    DIFERENTE       reduce using rule 86 (argUnico -> NUMBER .)
    MAYORQUE        reduce using rule 86 (argUnico -> NUMBER .)
    MAYORIGUALQUE   reduce using rule 86 (argUnico -> NUMBER .)
    MENORQUE        reduce using rule 86 (argUnico -> NUMBER .)
    MENORIGUALQUE   reduce using rule 86 (argUnico -> NUMBER .)
    CLOSE_PARENTHESIS reduce using rule 86 (argUnico -> NUMBER .)


state 62

    (87) argUnico -> STRING .

    IGUALIGUAL      reduce using rule 87 (argUnico -> STRING .)
    DIFERENTE       reduce using rule 87 (argUnico -> STRING .)
    MAYORQUE        reduce using rule 87 (argUnico -> STRING .)
    MAYORIGUALQUE   reduce using rule 87 (argUnico -> STRING .)
    MENORQUE        reduce using rule 87 (argUnico -> STRING .)
    MENORIGUALQUE   reduce using rule 87 (argUnico -> STRING .)
    CLOSE_PARENTHESIS reduce using rule 87 (argUnico -> STRING .)


state 63

    (88) argUnico -> NAME .

    IGUALIGUAL      reduce using rule 88 (argUnico -> NAME .)
    DIFERENTE       reduce using rule 88 (argUnico -> NAME .)
    MAYORQUE        reduce using rule 88 (argUnico -> NAME .)
    MAYORIGUALQUE   reduce using rule 88 (argUnico -> NAME .)
    MENORQUE        reduce using rule 88 (argUnico -> NAME .)
    MENORIGUALQUE   reduce using rule 88 (argUnico -> NAME .)
    CLOSE_PARENTHESIS reduce using rule 88 (argUnico -> NAME .)


state 64

    (36) for -> FOR OPEN_PARENTHESIS inicialization . SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    SEMICOLON       shift and go to state 103


state 65

    (37) inicialization -> type . NAME IGUAL NUMBER

    NAME            shift and go to state 104


state 66

    (38) inicialization -> NAME . IGUAL NUMBER

    IGUAL           shift and go to state 105


state 67

    (23) if -> soloIf elseIf else .

    NAME            reduce using rule 23 (if -> soloIf elseIf else .)
    CONST           reduce using rule 23 (if -> soloIf elseIf else .)
    LET             reduce using rule 23 (if -> soloIf elseIf else .)
    VAR             reduce using rule 23 (if -> soloIf elseIf else .)
    WHILE           reduce using rule 23 (if -> soloIf elseIf else .)
    FOR             reduce using rule 23 (if -> soloIf elseIf else .)
    IF              reduce using rule 23 (if -> soloIf elseIf else .)
    $end            reduce using rule 23 (if -> soloIf elseIf else .)
    CLOSE_BRACE     reduce using rule 23 (if -> soloIf elseIf else .)


state 68

    (26) elseIf -> ELSEIF OPEN_PARENTHESIS . controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (27) elseIf -> ELSEIF OPEN_PARENTHESIS . controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf
    (35) controlArg -> . argUnico comparacion argUnico
    (86) argUnico -> . NUMBER
    (87) argUnico -> . STRING
    (88) argUnico -> . NAME

    NUMBER          shift and go to state 61
    STRING          shift and go to state 62
    NAME            shift and go to state 63

    controlArg                     shift and go to state 106
    argUnico                       shift and go to state 58

state 69

    (28) else -> ELSE OPEN_BRACE . expression CLOSE_BRACE
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) expression -> . methodsSet
    (8) expression -> . mapFunctions
    (9) expression -> . arrayFn
    (10) variable -> . type NAME IGUAL datatype SEMICOLON
    (11) variable -> . type NAME IGUAL operations SEMICOLON
    (12) variable -> . NAME IGUAL datatype SEMICOLON
    (16) dataStruct -> . array
    (17) dataStruct -> . set
    (18) dataStruct -> . map
    (13) controlStruct -> . while
    (14) controlStruct -> . for
    (15) controlStruct -> . if
    (95) methodsSet -> . NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (96) methodsSet -> . NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (97) methodsSet -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (80) mapFunctions -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (81) mapFunctions -> . NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (82) mapFunctions -> . NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (83) arrayFn -> . NAME POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS
    (84) arrayFn -> . NAME POINT PUSH OPEN_PARENTHESIS argUnico CLOSE_PARENTHESIS
    (85) arrayFn -> . NAME POINT UNSHIFT OPEN_PARENTHESIS argUnico CLOSE_PARENTHESIS
    (52) type -> . CONST
    (53) type -> . LET
    (54) type -> . VAR
    (63) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (64) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (89) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (90) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (91) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (92) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (93) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (94) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (65) map -> . iniciarMap
    (66) map -> . escribirMap
    (67) map -> . generarMap
    (19) while -> . WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (20) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (36) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (21) if -> . soloIf
    (22) if -> . soloIf elseIf
    (23) if -> . soloIf elseIf else
    (24) if -> . soloIf else
    (68) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (69) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (75) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (25) soloIf -> . IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    NAME            shift and go to state 9
    CONST           shift and go to state 16
    LET             shift and go to state 17
    VAR             shift and go to state 18
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    IF              shift and go to state 25

    expression                     shift and go to state 107
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    methodsSet                     shift and go to state 5
    mapFunctions                   shift and go to state 6
    arrayFn                        shift and go to state 7
    type                           shift and go to state 8
    array                          shift and go to state 10
    set                            shift and go to state 11
    map                            shift and go to state 12
    while                          shift and go to state 13
    for                            shift and go to state 14
    if                             shift and go to state 15
    iniciarMap                     shift and go to state 19
    escribirMap                    shift and go to state 20
    generarMap                     shift and go to state 21
    soloIf                         shift and go to state 24

state 70

    (25) soloIf -> IF OPEN_PARENTHESIS controlArg . CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    CLOSE_PARENTHESIS shift and go to state 108


state 71

    (68) iniciarMap -> variable IGUAL NEW MAP . OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON

    OPEN_PARENTHESIS shift and go to state 109


state 72

    (69) escribirMap -> variable IGUAL OPEN_BRACE claveValor . CLOSE_BRACE

    CLOSE_BRACE     shift and go to state 110


state 73

    (75) generarMap -> variable IGUAL OPEN_BRACE tuplas . CLOSE_BRACE

    CLOSE_BRACE     shift and go to state 111


state 74

    (70) claveValor -> clave . COLON valor
    (71) claveValor -> clave . COLON valor COMMA claveValor

    COLON           shift and go to state 112


state 75

    (76) tuplas -> tupla .
    (77) tuplas -> tupla . COMMA tuplas

    CLOSE_BRACE     reduce using rule 76 (tuplas -> tupla .)
    COMMA           shift and go to state 113


state 76

    (72) clave -> datatype .

    COLON           reduce using rule 72 (clave -> datatype .)
    CLOSE_PARENTHESIS reduce using rule 72 (clave -> datatype .)


state 77

    (78) tupla -> OPEN_BRACKET . datatype CLOSE_BRACKET
    (79) tupla -> OPEN_BRACKET . datatype COMMA datatype CLOSE_BRACKET
    (43) datatype -> . NUMBER
    (44) datatype -> . STRING
    (45) datatype -> . CHAR

    NUMBER          shift and go to state 45
    STRING          shift and go to state 46
    CHAR            shift and go to state 47

    datatype                       shift and go to state 114

state 78

    (41) operations -> NAME . SUMA SUMA
    (42) operations -> NAME . RESTA RESTA

    SUMA            shift and go to state 115
    RESTA           shift and go to state 116


state 79

    (10) variable -> type NAME IGUAL datatype . SEMICOLON

    SEMICOLON       shift and go to state 117


state 80

    (11) variable -> type NAME IGUAL operations . SEMICOLON

    SEMICOLON       shift and go to state 118


state 81

    (63) array -> type NAME IGUAL OPEN_BRACKET . items CLOSE_BRACKET SEMICOLON
    (98) items -> . numeros
    (99) items -> . cadena
    (100) numeros -> . NUMBER
    (101) numeros -> . NUMBER COMMA numeros
    (102) cadena -> . STRING
    (103) cadena -> . STRING COMMA cadena

    NUMBER          shift and go to state 122
    STRING          shift and go to state 123

    items                          shift and go to state 119
    numeros                        shift and go to state 120
    cadena                         shift and go to state 121

state 82

    (64) array -> type NAME IGUAL NEW . ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (89) set -> type NAME IGUAL NEW . SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (90) set -> type NAME IGUAL NEW . SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (91) set -> type NAME IGUAL NEW . SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON

    ARRAY           shift and go to state 124
    SET             shift and go to state 125


state 83

    (43) datatype -> NUMBER .
    (40) operations -> NUMBER . operand NUMBER
    (46) operand -> . SUMA
    (47) operand -> . RESTA
    (48) operand -> . MULTIPLICACION
    (49) operand -> . DIVISION

    SEMICOLON       reduce using rule 43 (datatype -> NUMBER .)
    SUMA            shift and go to state 127
    RESTA           shift and go to state 128
    MULTIPLICACION  shift and go to state 129
    DIVISION        shift and go to state 130

    operand                        shift and go to state 126

state 84

    (12) variable -> NAME IGUAL datatype SEMICOLON .

    IGUAL           reduce using rule 12 (variable -> NAME IGUAL datatype SEMICOLON .)
    NAME            reduce using rule 12 (variable -> NAME IGUAL datatype SEMICOLON .)
    CONST           reduce using rule 12 (variable -> NAME IGUAL datatype SEMICOLON .)
    LET             reduce using rule 12 (variable -> NAME IGUAL datatype SEMICOLON .)
    VAR             reduce using rule 12 (variable -> NAME IGUAL datatype SEMICOLON .)
    WHILE           reduce using rule 12 (variable -> NAME IGUAL datatype SEMICOLON .)
    FOR             reduce using rule 12 (variable -> NAME IGUAL datatype SEMICOLON .)
    IF              reduce using rule 12 (variable -> NAME IGUAL datatype SEMICOLON .)
    $end            reduce using rule 12 (variable -> NAME IGUAL datatype SEMICOLON .)
    CLOSE_BRACE     reduce using rule 12 (variable -> NAME IGUAL datatype SEMICOLON .)


state 85

    (92) set -> NAME IGUAL NEW SET . OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (93) set -> NAME IGUAL NEW SET . OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (94) set -> NAME IGUAL NEW SET . OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON

    OPEN_PARENTHESIS shift and go to state 131


state 86

    (95) methodsSet -> NAME POINT ADD OPEN_PARENTHESIS . element CLOSE_PARENTHESIS SEMICOLON
    (104) element -> . STRING
    (105) element -> . NUMBER
    (106) element -> . NAME

    STRING          shift and go to state 134
    NUMBER          shift and go to state 135
    NAME            shift and go to state 132

    element                        shift and go to state 133

state 87

    (96) methodsSet -> NAME POINT DELETE OPEN_PARENTHESIS . element CLOSE_PARENTHESIS SEMICOLON
    (104) element -> . STRING
    (105) element -> . NUMBER
    (106) element -> . NAME

    STRING          shift and go to state 134
    NUMBER          shift and go to state 135
    NAME            shift and go to state 132

    element                        shift and go to state 136

state 88

    (97) methodsSet -> NAME POINT CLEAR OPEN_PARENTHESIS . CLOSE_PARENTHESIS SEMICOLON
    (80) mapFunctions -> NAME POINT CLEAR OPEN_PARENTHESIS . CLOSE_PARENTHESIS SEMICOLON

    CLOSE_PARENTHESIS shift and go to state 137


state 89

    (81) mapFunctions -> NAME POINT GET OPEN_PARENTHESIS . clave CLOSE_PARENTHESIS SEMICOLON
    (72) clave -> . datatype
    (43) datatype -> . NUMBER
    (44) datatype -> . STRING
    (45) datatype -> . CHAR

    NUMBER          shift and go to state 45
    STRING          shift and go to state 46
    CHAR            shift and go to state 47

    clave                          shift and go to state 138
    datatype                       shift and go to state 76

state 90

    (82) mapFunctions -> NAME POINT HAS OPEN_PARENTHESIS . clave CLOSE_PARENTHESIS SEMICOLON
    (72) clave -> . datatype
    (43) datatype -> . NUMBER
    (44) datatype -> . STRING
    (45) datatype -> . CHAR

    NUMBER          shift and go to state 45
    STRING          shift and go to state 46
    CHAR            shift and go to state 47

    clave                          shift and go to state 139
    datatype                       shift and go to state 76

state 91

    (83) arrayFn -> NAME POINT POP OPEN_PARENTHESIS . CLOSE_PARENTHESIS

    CLOSE_PARENTHESIS shift and go to state 140


state 92

    (84) arrayFn -> NAME POINT PUSH OPEN_PARENTHESIS . argUnico CLOSE_PARENTHESIS
    (86) argUnico -> . NUMBER
    (87) argUnico -> . STRING
    (88) argUnico -> . NAME

    NUMBER          shift and go to state 61
    STRING          shift and go to state 62
    NAME            shift and go to state 63

    argUnico                       shift and go to state 141

state 93

    (85) arrayFn -> NAME POINT UNSHIFT OPEN_PARENTHESIS . argUnico CLOSE_PARENTHESIS
    (86) argUnico -> . NUMBER
    (87) argUnico -> . STRING
    (88) argUnico -> . NAME

    NUMBER          shift and go to state 61
    STRING          shift and go to state 62
    NAME            shift and go to state 63

    argUnico                       shift and go to state 142

state 94

    (19) while -> WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS . OPEN_BRACE expression CLOSE_BRACE

    OPEN_BRACE      shift and go to state 143


state 95

    (20) while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS . OPEN_BRACE expression CLOSE_BRACE

    OPEN_BRACE      shift and go to state 144


state 96

    (35) controlArg -> argUnico comparacion . argUnico
    (86) argUnico -> . NUMBER
    (87) argUnico -> . STRING
    (88) argUnico -> . NAME

    NUMBER          shift and go to state 61
    STRING          shift and go to state 62
    NAME            shift and go to state 63

    argUnico                       shift and go to state 145

state 97

    (29) comparacion -> IGUALIGUAL .

    NUMBER          reduce using rule 29 (comparacion -> IGUALIGUAL .)
    STRING          reduce using rule 29 (comparacion -> IGUALIGUAL .)
    NAME            reduce using rule 29 (comparacion -> IGUALIGUAL .)


state 98

    (30) comparacion -> DIFERENTE .

    NUMBER          reduce using rule 30 (comparacion -> DIFERENTE .)
    STRING          reduce using rule 30 (comparacion -> DIFERENTE .)
    NAME            reduce using rule 30 (comparacion -> DIFERENTE .)


state 99

    (31) comparacion -> MAYORQUE .

    NUMBER          reduce using rule 31 (comparacion -> MAYORQUE .)
    STRING          reduce using rule 31 (comparacion -> MAYORQUE .)
    NAME            reduce using rule 31 (comparacion -> MAYORQUE .)


state 100

    (32) comparacion -> MAYORIGUALQUE .

    NUMBER          reduce using rule 32 (comparacion -> MAYORIGUALQUE .)
    STRING          reduce using rule 32 (comparacion -> MAYORIGUALQUE .)
    NAME            reduce using rule 32 (comparacion -> MAYORIGUALQUE .)


state 101

    (33) comparacion -> MENORQUE .

    NUMBER          reduce using rule 33 (comparacion -> MENORQUE .)
    STRING          reduce using rule 33 (comparacion -> MENORQUE .)
    NAME            reduce using rule 33 (comparacion -> MENORQUE .)


state 102

    (34) comparacion -> MENORIGUALQUE .

    NUMBER          reduce using rule 34 (comparacion -> MENORIGUALQUE .)
    STRING          reduce using rule 34 (comparacion -> MENORIGUALQUE .)
    NAME            reduce using rule 34 (comparacion -> MENORIGUALQUE .)


state 103

    (36) for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON . condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (39) condition -> . NAME clause value

    NAME            shift and go to state 147

    condition                      shift and go to state 146

state 104

    (37) inicialization -> type NAME . IGUAL NUMBER

    IGUAL           shift and go to state 148


state 105

    (38) inicialization -> NAME IGUAL . NUMBER

    NUMBER          shift and go to state 149


state 106

    (26) elseIf -> ELSEIF OPEN_PARENTHESIS controlArg . CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (27) elseIf -> ELSEIF OPEN_PARENTHESIS controlArg . CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf

    CLOSE_PARENTHESIS shift and go to state 150


state 107

    (28) else -> ELSE OPEN_BRACE expression . CLOSE_BRACE

    CLOSE_BRACE     shift and go to state 151


state 108

    (25) soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS . OPEN_BRACE expression CLOSE_BRACE

    OPEN_BRACE      shift and go to state 152


state 109

    (68) iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS . CLOSE_PARENTHESIS SEMICOLON

    CLOSE_PARENTHESIS shift and go to state 153


state 110

    (69) escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .

    NAME            reduce using rule 69 (escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .)
    CONST           reduce using rule 69 (escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .)
    LET             reduce using rule 69 (escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .)
    VAR             reduce using rule 69 (escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .)
    WHILE           reduce using rule 69 (escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .)
    FOR             reduce using rule 69 (escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .)
    IF              reduce using rule 69 (escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .)
    $end            reduce using rule 69 (escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 69 (escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .)
    COMMA           reduce using rule 69 (escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .)


state 111

    (75) generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .

    NAME            reduce using rule 75 (generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .)
    CONST           reduce using rule 75 (generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .)
    LET             reduce using rule 75 (generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .)
    VAR             reduce using rule 75 (generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .)
    WHILE           reduce using rule 75 (generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .)
    FOR             reduce using rule 75 (generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .)
    IF              reduce using rule 75 (generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .)
    $end            reduce using rule 75 (generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 75 (generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .)
    COMMA           reduce using rule 75 (generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .)


state 112

    (70) claveValor -> clave COLON . valor
    (71) claveValor -> clave COLON . valor COMMA claveValor
    (73) valor -> . datatype
    (74) valor -> . dataStruct
    (43) datatype -> . NUMBER
    (44) datatype -> . STRING
    (45) datatype -> . CHAR
    (16) dataStruct -> . array
    (17) dataStruct -> . set
    (18) dataStruct -> . map
    (63) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (64) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (89) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (90) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (91) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (92) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (93) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (94) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (65) map -> . iniciarMap
    (66) map -> . escribirMap
    (67) map -> . generarMap
    (52) type -> . CONST
    (53) type -> . LET
    (54) type -> . VAR
    (68) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (69) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (75) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (10) variable -> . type NAME IGUAL datatype SEMICOLON
    (11) variable -> . type NAME IGUAL operations SEMICOLON
    (12) variable -> . NAME IGUAL datatype SEMICOLON

    NUMBER          shift and go to state 45
    STRING          shift and go to state 46
    CHAR            shift and go to state 47
    NAME            shift and go to state 158
    CONST           shift and go to state 16
    LET             shift and go to state 17
    VAR             shift and go to state 18

    valor                          shift and go to state 154
    datatype                       shift and go to state 155
    dataStruct                     shift and go to state 156
    array                          shift and go to state 10
    set                            shift and go to state 11
    map                            shift and go to state 12
    type                           shift and go to state 157
    iniciarMap                     shift and go to state 19
    escribirMap                    shift and go to state 20
    generarMap                     shift and go to state 21
    variable                       shift and go to state 159

state 113

    (77) tuplas -> tupla COMMA . tuplas
    (76) tuplas -> . tupla
    (77) tuplas -> . tupla COMMA tuplas
    (78) tupla -> . OPEN_BRACKET datatype CLOSE_BRACKET
    (79) tupla -> . OPEN_BRACKET datatype COMMA datatype CLOSE_BRACKET

    OPEN_BRACKET    shift and go to state 77

    tupla                          shift and go to state 75
    tuplas                         shift and go to state 160

state 114

    (78) tupla -> OPEN_BRACKET datatype . CLOSE_BRACKET
    (79) tupla -> OPEN_BRACKET datatype . COMMA datatype CLOSE_BRACKET

    CLOSE_BRACKET   shift and go to state 161
    COMMA           shift and go to state 162


state 115

    (41) operations -> NAME SUMA . SUMA

    SUMA            shift and go to state 163


state 116

    (42) operations -> NAME RESTA . RESTA

    RESTA           shift and go to state 164


state 117

    (10) variable -> type NAME IGUAL datatype SEMICOLON .

    IGUAL           reduce using rule 10 (variable -> type NAME IGUAL datatype SEMICOLON .)
    NAME            reduce using rule 10 (variable -> type NAME IGUAL datatype SEMICOLON .)
    CONST           reduce using rule 10 (variable -> type NAME IGUAL datatype SEMICOLON .)
    LET             reduce using rule 10 (variable -> type NAME IGUAL datatype SEMICOLON .)
    VAR             reduce using rule 10 (variable -> type NAME IGUAL datatype SEMICOLON .)
    WHILE           reduce using rule 10 (variable -> type NAME IGUAL datatype SEMICOLON .)
    FOR             reduce using rule 10 (variable -> type NAME IGUAL datatype SEMICOLON .)
    IF              reduce using rule 10 (variable -> type NAME IGUAL datatype SEMICOLON .)
    $end            reduce using rule 10 (variable -> type NAME IGUAL datatype SEMICOLON .)
    CLOSE_BRACE     reduce using rule 10 (variable -> type NAME IGUAL datatype SEMICOLON .)


state 118

    (11) variable -> type NAME IGUAL operations SEMICOLON .

    IGUAL           reduce using rule 11 (variable -> type NAME IGUAL operations SEMICOLON .)
    NAME            reduce using rule 11 (variable -> type NAME IGUAL operations SEMICOLON .)
    CONST           reduce using rule 11 (variable -> type NAME IGUAL operations SEMICOLON .)
    LET             reduce using rule 11 (variable -> type NAME IGUAL operations SEMICOLON .)
    VAR             reduce using rule 11 (variable -> type NAME IGUAL operations SEMICOLON .)
    WHILE           reduce using rule 11 (variable -> type NAME IGUAL operations SEMICOLON .)
    FOR             reduce using rule 11 (variable -> type NAME IGUAL operations SEMICOLON .)
    IF              reduce using rule 11 (variable -> type NAME IGUAL operations SEMICOLON .)
    $end            reduce using rule 11 (variable -> type NAME IGUAL operations SEMICOLON .)
    CLOSE_BRACE     reduce using rule 11 (variable -> type NAME IGUAL operations SEMICOLON .)


state 119

    (63) array -> type NAME IGUAL OPEN_BRACKET items . CLOSE_BRACKET SEMICOLON

    CLOSE_BRACKET   shift and go to state 165


state 120

    (98) items -> numeros .

    CLOSE_BRACKET   reduce using rule 98 (items -> numeros .)
    CLOSE_PARENTHESIS reduce using rule 98 (items -> numeros .)


state 121

    (99) items -> cadena .

    CLOSE_BRACKET   reduce using rule 99 (items -> cadena .)
    CLOSE_PARENTHESIS reduce using rule 99 (items -> cadena .)


state 122

    (100) numeros -> NUMBER .
    (101) numeros -> NUMBER . COMMA numeros

    CLOSE_BRACKET   reduce using rule 100 (numeros -> NUMBER .)
    CLOSE_PARENTHESIS reduce using rule 100 (numeros -> NUMBER .)
    COMMA           shift and go to state 166


state 123

    (102) cadena -> STRING .
    (103) cadena -> STRING . COMMA cadena

    CLOSE_BRACKET   reduce using rule 102 (cadena -> STRING .)
    CLOSE_PARENTHESIS reduce using rule 102 (cadena -> STRING .)
    COMMA           shift and go to state 167


state 124

    (64) array -> type NAME IGUAL NEW ARRAY . OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON

    OPEN_PARENTHESIS shift and go to state 168


state 125

    (89) set -> type NAME IGUAL NEW SET . OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (90) set -> type NAME IGUAL NEW SET . OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (91) set -> type NAME IGUAL NEW SET . OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON

    OPEN_PARENTHESIS shift and go to state 169


state 126

    (40) operations -> NUMBER operand . NUMBER

    NUMBER          shift and go to state 170


state 127

    (46) operand -> SUMA .

    NUMBER          reduce using rule 46 (operand -> SUMA .)


state 128

    (47) operand -> RESTA .

    NUMBER          reduce using rule 47 (operand -> RESTA .)


state 129

    (48) operand -> MULTIPLICACION .

    NUMBER          reduce using rule 48 (operand -> MULTIPLICACION .)


state 130

    (49) operand -> DIVISION .

    NUMBER          reduce using rule 49 (operand -> DIVISION .)


state 131

    (92) set -> NAME IGUAL NEW SET OPEN_PARENTHESIS . CLOSE_PARENTHESIS SEMICOLON
    (93) set -> NAME IGUAL NEW SET OPEN_PARENTHESIS . OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (94) set -> NAME IGUAL NEW SET OPEN_PARENTHESIS . element CLOSE_PARENTHESIS SEMICOLON
    (104) element -> . STRING
    (105) element -> . NUMBER
    (106) element -> . NAME

    CLOSE_PARENTHESIS shift and go to state 171
    OPEN_BRACKET    shift and go to state 172
    STRING          shift and go to state 134
    NUMBER          shift and go to state 135
    NAME            shift and go to state 132

    element                        shift and go to state 173

state 132

    (106) element -> NAME .

    CLOSE_PARENTHESIS reduce using rule 106 (element -> NAME .)


state 133

    (95) methodsSet -> NAME POINT ADD OPEN_PARENTHESIS element . CLOSE_PARENTHESIS SEMICOLON

    CLOSE_PARENTHESIS shift and go to state 174


state 134

    (104) element -> STRING .

    CLOSE_PARENTHESIS reduce using rule 104 (element -> STRING .)


state 135

    (105) element -> NUMBER .

    CLOSE_PARENTHESIS reduce using rule 105 (element -> NUMBER .)


state 136

    (96) methodsSet -> NAME POINT DELETE OPEN_PARENTHESIS element . CLOSE_PARENTHESIS SEMICOLON

    CLOSE_PARENTHESIS shift and go to state 175


state 137

    (97) methodsSet -> NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS . SEMICOLON
    (80) mapFunctions -> NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 176


state 138

    (81) mapFunctions -> NAME POINT GET OPEN_PARENTHESIS clave . CLOSE_PARENTHESIS SEMICOLON

    CLOSE_PARENTHESIS shift and go to state 177


state 139

    (82) mapFunctions -> NAME POINT HAS OPEN_PARENTHESIS clave . CLOSE_PARENTHESIS SEMICOLON

    CLOSE_PARENTHESIS shift and go to state 178


state 140

    (83) arrayFn -> NAME POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS .

    $end            reduce using rule 83 (arrayFn -> NAME POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS .)
    CLOSE_BRACE     reduce using rule 83 (arrayFn -> NAME POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS .)


state 141

    (84) arrayFn -> NAME POINT PUSH OPEN_PARENTHESIS argUnico . CLOSE_PARENTHESIS

    CLOSE_PARENTHESIS shift and go to state 179


state 142

    (85) arrayFn -> NAME POINT UNSHIFT OPEN_PARENTHESIS argUnico . CLOSE_PARENTHESIS

    CLOSE_PARENTHESIS shift and go to state 180


state 143

    (19) while -> WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE . expression CLOSE_BRACE
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) expression -> . methodsSet
    (8) expression -> . mapFunctions
    (9) expression -> . arrayFn
    (10) variable -> . type NAME IGUAL datatype SEMICOLON
    (11) variable -> . type NAME IGUAL operations SEMICOLON
    (12) variable -> . NAME IGUAL datatype SEMICOLON
    (16) dataStruct -> . array
    (17) dataStruct -> . set
    (18) dataStruct -> . map
    (13) controlStruct -> . while
    (14) controlStruct -> . for
    (15) controlStruct -> . if
    (95) methodsSet -> . NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (96) methodsSet -> . NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (97) methodsSet -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (80) mapFunctions -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (81) mapFunctions -> . NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (82) mapFunctions -> . NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (83) arrayFn -> . NAME POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS
    (84) arrayFn -> . NAME POINT PUSH OPEN_PARENTHESIS argUnico CLOSE_PARENTHESIS
    (85) arrayFn -> . NAME POINT UNSHIFT OPEN_PARENTHESIS argUnico CLOSE_PARENTHESIS
    (52) type -> . CONST
    (53) type -> . LET
    (54) type -> . VAR
    (63) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (64) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (89) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (90) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (91) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (92) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (93) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (94) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (65) map -> . iniciarMap
    (66) map -> . escribirMap
    (67) map -> . generarMap
    (19) while -> . WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (20) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (36) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (21) if -> . soloIf
    (22) if -> . soloIf elseIf
    (23) if -> . soloIf elseIf else
    (24) if -> . soloIf else
    (68) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (69) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (75) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (25) soloIf -> . IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    NAME            shift and go to state 9
    CONST           shift and go to state 16
    LET             shift and go to state 17
    VAR             shift and go to state 18
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    IF              shift and go to state 25

    expression                     shift and go to state 181
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    methodsSet                     shift and go to state 5
    mapFunctions                   shift and go to state 6
    arrayFn                        shift and go to state 7
    type                           shift and go to state 8
    array                          shift and go to state 10
    set                            shift and go to state 11
    map                            shift and go to state 12
    while                          shift and go to state 13
    for                            shift and go to state 14
    if                             shift and go to state 15
    iniciarMap                     shift and go to state 19
    escribirMap                    shift and go to state 20
    generarMap                     shift and go to state 21
    soloIf                         shift and go to state 24

state 144

    (20) while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE . expression CLOSE_BRACE
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) expression -> . methodsSet
    (8) expression -> . mapFunctions
    (9) expression -> . arrayFn
    (10) variable -> . type NAME IGUAL datatype SEMICOLON
    (11) variable -> . type NAME IGUAL operations SEMICOLON
    (12) variable -> . NAME IGUAL datatype SEMICOLON
    (16) dataStruct -> . array
    (17) dataStruct -> . set
    (18) dataStruct -> . map
    (13) controlStruct -> . while
    (14) controlStruct -> . for
    (15) controlStruct -> . if
    (95) methodsSet -> . NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (96) methodsSet -> . NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (97) methodsSet -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (80) mapFunctions -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (81) mapFunctions -> . NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (82) mapFunctions -> . NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (83) arrayFn -> . NAME POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS
    (84) arrayFn -> . NAME POINT PUSH OPEN_PARENTHESIS argUnico CLOSE_PARENTHESIS
    (85) arrayFn -> . NAME POINT UNSHIFT OPEN_PARENTHESIS argUnico CLOSE_PARENTHESIS
    (52) type -> . CONST
    (53) type -> . LET
    (54) type -> . VAR
    (63) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (64) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (89) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (90) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (91) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (92) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (93) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (94) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (65) map -> . iniciarMap
    (66) map -> . escribirMap
    (67) map -> . generarMap
    (19) while -> . WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (20) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (36) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (21) if -> . soloIf
    (22) if -> . soloIf elseIf
    (23) if -> . soloIf elseIf else
    (24) if -> . soloIf else
    (68) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (69) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (75) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (25) soloIf -> . IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    NAME            shift and go to state 9
    CONST           shift and go to state 16
    LET             shift and go to state 17
    VAR             shift and go to state 18
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    IF              shift and go to state 25

    expression                     shift and go to state 182
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    methodsSet                     shift and go to state 5
    mapFunctions                   shift and go to state 6
    arrayFn                        shift and go to state 7
    type                           shift and go to state 8
    array                          shift and go to state 10
    set                            shift and go to state 11
    map                            shift and go to state 12
    while                          shift and go to state 13
    for                            shift and go to state 14
    if                             shift and go to state 15
    iniciarMap                     shift and go to state 19
    escribirMap                    shift and go to state 20
    generarMap                     shift and go to state 21
    soloIf                         shift and go to state 24

state 145

    (35) controlArg -> argUnico comparacion argUnico .

    CLOSE_PARENTHESIS reduce using rule 35 (controlArg -> argUnico comparacion argUnico .)


state 146

    (36) for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition . SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    SEMICOLON       shift and go to state 183


state 147

    (39) condition -> NAME . clause value
    (55) clause -> . IGUALIGUAL
    (56) clause -> . DIFERENTE
    (57) clause -> . MAYORQUE
    (58) clause -> . MAYORIGUALQUE
    (59) clause -> . MENORQUE
    (60) clause -> . MENORIGUALQUE

    IGUALIGUAL      shift and go to state 185
    DIFERENTE       shift and go to state 186
    MAYORQUE        shift and go to state 187
    MAYORIGUALQUE   shift and go to state 188
    MENORQUE        shift and go to state 189
    MENORIGUALQUE   shift and go to state 190

    clause                         shift and go to state 184

state 148

    (37) inicialization -> type NAME IGUAL . NUMBER

    NUMBER          shift and go to state 191


state 149

    (38) inicialization -> NAME IGUAL NUMBER .

    SEMICOLON       reduce using rule 38 (inicialization -> NAME IGUAL NUMBER .)


state 150

    (26) elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS . OPEN_BRACE expression CLOSE_BRACE
    (27) elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS . OPEN_BRACE expression CLOSE_BRACE soloIf

    OPEN_BRACE      shift and go to state 192


state 151

    (28) else -> ELSE OPEN_BRACE expression CLOSE_BRACE .

    NAME            reduce using rule 28 (else -> ELSE OPEN_BRACE expression CLOSE_BRACE .)
    CONST           reduce using rule 28 (else -> ELSE OPEN_BRACE expression CLOSE_BRACE .)
    LET             reduce using rule 28 (else -> ELSE OPEN_BRACE expression CLOSE_BRACE .)
    VAR             reduce using rule 28 (else -> ELSE OPEN_BRACE expression CLOSE_BRACE .)
    WHILE           reduce using rule 28 (else -> ELSE OPEN_BRACE expression CLOSE_BRACE .)
    FOR             reduce using rule 28 (else -> ELSE OPEN_BRACE expression CLOSE_BRACE .)
    IF              reduce using rule 28 (else -> ELSE OPEN_BRACE expression CLOSE_BRACE .)
    $end            reduce using rule 28 (else -> ELSE OPEN_BRACE expression CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 28 (else -> ELSE OPEN_BRACE expression CLOSE_BRACE .)


state 152

    (25) soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE . expression CLOSE_BRACE
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) expression -> . methodsSet
    (8) expression -> . mapFunctions
    (9) expression -> . arrayFn
    (10) variable -> . type NAME IGUAL datatype SEMICOLON
    (11) variable -> . type NAME IGUAL operations SEMICOLON
    (12) variable -> . NAME IGUAL datatype SEMICOLON
    (16) dataStruct -> . array
    (17) dataStruct -> . set
    (18) dataStruct -> . map
    (13) controlStruct -> . while
    (14) controlStruct -> . for
    (15) controlStruct -> . if
    (95) methodsSet -> . NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (96) methodsSet -> . NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (97) methodsSet -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (80) mapFunctions -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (81) mapFunctions -> . NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (82) mapFunctions -> . NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (83) arrayFn -> . NAME POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS
    (84) arrayFn -> . NAME POINT PUSH OPEN_PARENTHESIS argUnico CLOSE_PARENTHESIS
    (85) arrayFn -> . NAME POINT UNSHIFT OPEN_PARENTHESIS argUnico CLOSE_PARENTHESIS
    (52) type -> . CONST
    (53) type -> . LET
    (54) type -> . VAR
    (63) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (64) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (89) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (90) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (91) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (92) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (93) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (94) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (65) map -> . iniciarMap
    (66) map -> . escribirMap
    (67) map -> . generarMap
    (19) while -> . WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (20) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (36) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (21) if -> . soloIf
    (22) if -> . soloIf elseIf
    (23) if -> . soloIf elseIf else
    (24) if -> . soloIf else
    (68) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (69) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (75) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (25) soloIf -> . IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    NAME            shift and go to state 9
    CONST           shift and go to state 16
    LET             shift and go to state 17
    VAR             shift and go to state 18
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    IF              shift and go to state 25

    expression                     shift and go to state 193
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    methodsSet                     shift and go to state 5
    mapFunctions                   shift and go to state 6
    arrayFn                        shift and go to state 7
    type                           shift and go to state 8
    array                          shift and go to state 10
    set                            shift and go to state 11
    map                            shift and go to state 12
    while                          shift and go to state 13
    for                            shift and go to state 14
    if                             shift and go to state 15
    iniciarMap                     shift and go to state 19
    escribirMap                    shift and go to state 20
    generarMap                     shift and go to state 21
    soloIf                         shift and go to state 24

state 153

    (68) iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 194


state 154

    (70) claveValor -> clave COLON valor .
    (71) claveValor -> clave COLON valor . COMMA claveValor

    CLOSE_BRACE     reduce using rule 70 (claveValor -> clave COLON valor .)
    COMMA           shift and go to state 195


state 155

    (73) valor -> datatype .

    COMMA           reduce using rule 73 (valor -> datatype .)
    CLOSE_BRACE     reduce using rule 73 (valor -> datatype .)


state 156

    (74) valor -> dataStruct .

    COMMA           reduce using rule 74 (valor -> dataStruct .)
    CLOSE_BRACE     reduce using rule 74 (valor -> dataStruct .)


state 157

    (63) array -> type . NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (64) array -> type . NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (89) set -> type . NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (90) set -> type . NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (91) set -> type . NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (10) variable -> type . NAME IGUAL datatype SEMICOLON
    (11) variable -> type . NAME IGUAL operations SEMICOLON

    NAME            shift and go to state 196


state 158

    (92) set -> NAME . IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (93) set -> NAME . IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (94) set -> NAME . IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (12) variable -> NAME . IGUAL datatype SEMICOLON

    IGUAL           shift and go to state 197


state 159

    (68) iniciarMap -> variable . IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (69) escribirMap -> variable . IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (75) generarMap -> variable . IGUAL OPEN_BRACE tuplas CLOSE_BRACE

    IGUAL           shift and go to state 27


state 160

    (77) tuplas -> tupla COMMA tuplas .

    CLOSE_BRACE     reduce using rule 77 (tuplas -> tupla COMMA tuplas .)


state 161

    (78) tupla -> OPEN_BRACKET datatype CLOSE_BRACKET .

    COMMA           reduce using rule 78 (tupla -> OPEN_BRACKET datatype CLOSE_BRACKET .)
    CLOSE_BRACE     reduce using rule 78 (tupla -> OPEN_BRACKET datatype CLOSE_BRACKET .)


state 162

    (79) tupla -> OPEN_BRACKET datatype COMMA . datatype CLOSE_BRACKET
    (43) datatype -> . NUMBER
    (44) datatype -> . STRING
    (45) datatype -> . CHAR

    NUMBER          shift and go to state 45
    STRING          shift and go to state 46
    CHAR            shift and go to state 47

    datatype                       shift and go to state 198

state 163

    (41) operations -> NAME SUMA SUMA .

    SEMICOLON       reduce using rule 41 (operations -> NAME SUMA SUMA .)
    CLOSE_PARENTHESIS reduce using rule 41 (operations -> NAME SUMA SUMA .)


state 164

    (42) operations -> NAME RESTA RESTA .

    SEMICOLON       reduce using rule 42 (operations -> NAME RESTA RESTA .)
    CLOSE_PARENTHESIS reduce using rule 42 (operations -> NAME RESTA RESTA .)


state 165

    (63) array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET . SEMICOLON

    SEMICOLON       shift and go to state 199


state 166

    (101) numeros -> NUMBER COMMA . numeros
    (100) numeros -> . NUMBER
    (101) numeros -> . NUMBER COMMA numeros

    NUMBER          shift and go to state 122

    numeros                        shift and go to state 200

state 167

    (103) cadena -> STRING COMMA . cadena
    (102) cadena -> . STRING
    (103) cadena -> . STRING COMMA cadena

    STRING          shift and go to state 123

    cadena                         shift and go to state 201

state 168

    (64) array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS . items CLOSE_PARENTHESIS SEMICOLON
    (98) items -> . numeros
    (99) items -> . cadena
    (100) numeros -> . NUMBER
    (101) numeros -> . NUMBER COMMA numeros
    (102) cadena -> . STRING
    (103) cadena -> . STRING COMMA cadena

    NUMBER          shift and go to state 122
    STRING          shift and go to state 123

    items                          shift and go to state 202
    numeros                        shift and go to state 120
    cadena                         shift and go to state 121

state 169

    (89) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS . CLOSE_PARENTHESIS SEMICOLON
    (90) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS . OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (91) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS . element CLOSE_PARENTHESIS SEMICOLON
    (104) element -> . STRING
    (105) element -> . NUMBER
    (106) element -> . NAME

    CLOSE_PARENTHESIS shift and go to state 203
    OPEN_BRACKET    shift and go to state 204
    STRING          shift and go to state 134
    NUMBER          shift and go to state 135
    NAME            shift and go to state 132

    element                        shift and go to state 205

state 170

    (40) operations -> NUMBER operand NUMBER .

    SEMICOLON       reduce using rule 40 (operations -> NUMBER operand NUMBER .)
    CLOSE_PARENTHESIS reduce using rule 40 (operations -> NUMBER operand NUMBER .)


state 171

    (92) set -> NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 206


state 172

    (93) set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET . items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (98) items -> . numeros
    (99) items -> . cadena
    (100) numeros -> . NUMBER
    (101) numeros -> . NUMBER COMMA numeros
    (102) cadena -> . STRING
    (103) cadena -> . STRING COMMA cadena

    NUMBER          shift and go to state 122
    STRING          shift and go to state 123

    items                          shift and go to state 207
    numeros                        shift and go to state 120
    cadena                         shift and go to state 121

state 173

    (94) set -> NAME IGUAL NEW SET OPEN_PARENTHESIS element . CLOSE_PARENTHESIS SEMICOLON

    CLOSE_PARENTHESIS shift and go to state 208


state 174

    (95) methodsSet -> NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 209


state 175

    (96) methodsSet -> NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 210


state 176

    (97) methodsSet -> NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .
    (80) mapFunctions -> NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .

  ! reduce/reduce conflict for $end resolved using rule 80 (mapFunctions -> NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
  ! reduce/reduce conflict for CLOSE_BRACE resolved using rule 80 (mapFunctions -> NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    $end            reduce using rule 80 (mapFunctions -> NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 80 (mapFunctions -> NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)

  ! $end            [ reduce using rule 97 (methodsSet -> NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .) ]
  ! CLOSE_BRACE     [ reduce using rule 97 (methodsSet -> NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .) ]


state 177

    (81) mapFunctions -> NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 211


state 178

    (82) mapFunctions -> NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 212


state 179

    (84) arrayFn -> NAME POINT PUSH OPEN_PARENTHESIS argUnico CLOSE_PARENTHESIS .

    $end            reduce using rule 84 (arrayFn -> NAME POINT PUSH OPEN_PARENTHESIS argUnico CLOSE_PARENTHESIS .)
    CLOSE_BRACE     reduce using rule 84 (arrayFn -> NAME POINT PUSH OPEN_PARENTHESIS argUnico CLOSE_PARENTHESIS .)


state 180

    (85) arrayFn -> NAME POINT UNSHIFT OPEN_PARENTHESIS argUnico CLOSE_PARENTHESIS .

    $end            reduce using rule 85 (arrayFn -> NAME POINT UNSHIFT OPEN_PARENTHESIS argUnico CLOSE_PARENTHESIS .)
    CLOSE_BRACE     reduce using rule 85 (arrayFn -> NAME POINT UNSHIFT OPEN_PARENTHESIS argUnico CLOSE_PARENTHESIS .)


state 181

    (19) while -> WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression . CLOSE_BRACE

    CLOSE_BRACE     shift and go to state 213


state 182

    (20) while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression . CLOSE_BRACE

    CLOSE_BRACE     shift and go to state 214


state 183

    (36) for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON . operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (40) operations -> . NUMBER operand NUMBER
    (41) operations -> . NAME SUMA SUMA
    (42) operations -> . NAME RESTA RESTA

    NUMBER          shift and go to state 216
    NAME            shift and go to state 78

    operations                     shift and go to state 215

state 184

    (39) condition -> NAME clause . value
    (61) value -> . NAME
    (62) value -> . NUMBER

    NAME            shift and go to state 217
    NUMBER          shift and go to state 219

    value                          shift and go to state 218

state 185

    (55) clause -> IGUALIGUAL .

    NAME            reduce using rule 55 (clause -> IGUALIGUAL .)
    NUMBER          reduce using rule 55 (clause -> IGUALIGUAL .)


state 186

    (56) clause -> DIFERENTE .

    NAME            reduce using rule 56 (clause -> DIFERENTE .)
    NUMBER          reduce using rule 56 (clause -> DIFERENTE .)


state 187

    (57) clause -> MAYORQUE .

    NAME            reduce using rule 57 (clause -> MAYORQUE .)
    NUMBER          reduce using rule 57 (clause -> MAYORQUE .)


state 188

    (58) clause -> MAYORIGUALQUE .

    NAME            reduce using rule 58 (clause -> MAYORIGUALQUE .)
    NUMBER          reduce using rule 58 (clause -> MAYORIGUALQUE .)


state 189

    (59) clause -> MENORQUE .

    NAME            reduce using rule 59 (clause -> MENORQUE .)
    NUMBER          reduce using rule 59 (clause -> MENORQUE .)


state 190

    (60) clause -> MENORIGUALQUE .

    NAME            reduce using rule 60 (clause -> MENORIGUALQUE .)
    NUMBER          reduce using rule 60 (clause -> MENORIGUALQUE .)


state 191

    (37) inicialization -> type NAME IGUAL NUMBER .

    SEMICOLON       reduce using rule 37 (inicialization -> type NAME IGUAL NUMBER .)


state 192

    (26) elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE . expression CLOSE_BRACE
    (27) elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE . expression CLOSE_BRACE soloIf
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) expression -> . methodsSet
    (8) expression -> . mapFunctions
    (9) expression -> . arrayFn
    (10) variable -> . type NAME IGUAL datatype SEMICOLON
    (11) variable -> . type NAME IGUAL operations SEMICOLON
    (12) variable -> . NAME IGUAL datatype SEMICOLON
    (16) dataStruct -> . array
    (17) dataStruct -> . set
    (18) dataStruct -> . map
    (13) controlStruct -> . while
    (14) controlStruct -> . for
    (15) controlStruct -> . if
    (95) methodsSet -> . NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (96) methodsSet -> . NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (97) methodsSet -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (80) mapFunctions -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (81) mapFunctions -> . NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (82) mapFunctions -> . NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (83) arrayFn -> . NAME POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS
    (84) arrayFn -> . NAME POINT PUSH OPEN_PARENTHESIS argUnico CLOSE_PARENTHESIS
    (85) arrayFn -> . NAME POINT UNSHIFT OPEN_PARENTHESIS argUnico CLOSE_PARENTHESIS
    (52) type -> . CONST
    (53) type -> . LET
    (54) type -> . VAR
    (63) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (64) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (89) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (90) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (91) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (92) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (93) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (94) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (65) map -> . iniciarMap
    (66) map -> . escribirMap
    (67) map -> . generarMap
    (19) while -> . WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (20) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (36) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (21) if -> . soloIf
    (22) if -> . soloIf elseIf
    (23) if -> . soloIf elseIf else
    (24) if -> . soloIf else
    (68) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (69) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (75) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (25) soloIf -> . IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    NAME            shift and go to state 9
    CONST           shift and go to state 16
    LET             shift and go to state 17
    VAR             shift and go to state 18
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    IF              shift and go to state 25

    expression                     shift and go to state 220
    soloIf                         shift and go to state 24
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    methodsSet                     shift and go to state 5
    mapFunctions                   shift and go to state 6
    arrayFn                        shift and go to state 7
    type                           shift and go to state 8
    array                          shift and go to state 10
    set                            shift and go to state 11
    map                            shift and go to state 12
    while                          shift and go to state 13
    for                            shift and go to state 14
    if                             shift and go to state 15
    iniciarMap                     shift and go to state 19
    escribirMap                    shift and go to state 20
    generarMap                     shift and go to state 21

state 193

    (25) soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression . CLOSE_BRACE

    CLOSE_BRACE     shift and go to state 221


state 194

    (68) iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .

    NAME            reduce using rule 68 (iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    CONST           reduce using rule 68 (iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    LET             reduce using rule 68 (iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    VAR             reduce using rule 68 (iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    WHILE           reduce using rule 68 (iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    FOR             reduce using rule 68 (iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    IF              reduce using rule 68 (iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    $end            reduce using rule 68 (iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 68 (iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    COMMA           reduce using rule 68 (iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)


state 195

    (71) claveValor -> clave COLON valor COMMA . claveValor
    (70) claveValor -> . clave COLON valor
    (71) claveValor -> . clave COLON valor COMMA claveValor
    (72) clave -> . datatype
    (43) datatype -> . NUMBER
    (44) datatype -> . STRING
    (45) datatype -> . CHAR

    NUMBER          shift and go to state 45
    STRING          shift and go to state 46
    CHAR            shift and go to state 47

    clave                          shift and go to state 74
    claveValor                     shift and go to state 222
    datatype                       shift and go to state 76

state 196

    (63) array -> type NAME . IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (64) array -> type NAME . IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (89) set -> type NAME . IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (90) set -> type NAME . IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (91) set -> type NAME . IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (10) variable -> type NAME . IGUAL datatype SEMICOLON
    (11) variable -> type NAME . IGUAL operations SEMICOLON

    IGUAL           shift and go to state 223


state 197

    (92) set -> NAME IGUAL . NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (93) set -> NAME IGUAL . NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (94) set -> NAME IGUAL . NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (12) variable -> NAME IGUAL . datatype SEMICOLON
    (43) datatype -> . NUMBER
    (44) datatype -> . STRING
    (45) datatype -> . CHAR

    NEW             shift and go to state 44
    NUMBER          shift and go to state 45
    STRING          shift and go to state 46
    CHAR            shift and go to state 47

    datatype                       shift and go to state 43

state 198

    (79) tupla -> OPEN_BRACKET datatype COMMA datatype . CLOSE_BRACKET

    CLOSE_BRACKET   shift and go to state 224


state 199

    (63) array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .

    NAME            reduce using rule 63 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    CONST           reduce using rule 63 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    LET             reduce using rule 63 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    VAR             reduce using rule 63 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    WHILE           reduce using rule 63 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    FOR             reduce using rule 63 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    IF              reduce using rule 63 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    $end            reduce using rule 63 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    CLOSE_BRACE     reduce using rule 63 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    COMMA           reduce using rule 63 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)


state 200

    (101) numeros -> NUMBER COMMA numeros .

    CLOSE_BRACKET   reduce using rule 101 (numeros -> NUMBER COMMA numeros .)
    CLOSE_PARENTHESIS reduce using rule 101 (numeros -> NUMBER COMMA numeros .)


state 201

    (103) cadena -> STRING COMMA cadena .

    CLOSE_BRACKET   reduce using rule 103 (cadena -> STRING COMMA cadena .)
    CLOSE_PARENTHESIS reduce using rule 103 (cadena -> STRING COMMA cadena .)


state 202

    (64) array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items . CLOSE_PARENTHESIS SEMICOLON

    CLOSE_PARENTHESIS shift and go to state 225


state 203

    (89) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 226


state 204

    (90) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET . items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (98) items -> . numeros
    (99) items -> . cadena
    (100) numeros -> . NUMBER
    (101) numeros -> . NUMBER COMMA numeros
    (102) cadena -> . STRING
    (103) cadena -> . STRING COMMA cadena

    NUMBER          shift and go to state 122
    STRING          shift and go to state 123

    items                          shift and go to state 227
    numeros                        shift and go to state 120
    cadena                         shift and go to state 121

state 205

    (91) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element . CLOSE_PARENTHESIS SEMICOLON

    CLOSE_PARENTHESIS shift and go to state 228


state 206

    (92) set -> NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .

    NAME            reduce using rule 92 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    CONST           reduce using rule 92 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    LET             reduce using rule 92 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    VAR             reduce using rule 92 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    WHILE           reduce using rule 92 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    FOR             reduce using rule 92 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    IF              reduce using rule 92 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    $end            reduce using rule 92 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 92 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    COMMA           reduce using rule 92 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)


state 207

    (93) set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items . CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON

    CLOSE_BRACKET   shift and go to state 229


state 208

    (94) set -> NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 230


state 209

    (95) methodsSet -> NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .

    $end            reduce using rule 95 (methodsSet -> NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 95 (methodsSet -> NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)


state 210

    (96) methodsSet -> NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .

    $end            reduce using rule 96 (methodsSet -> NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 96 (methodsSet -> NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)


state 211

    (81) mapFunctions -> NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON .

    $end            reduce using rule 81 (mapFunctions -> NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 81 (mapFunctions -> NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON .)


state 212

    (82) mapFunctions -> NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON .

    $end            reduce using rule 82 (mapFunctions -> NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 82 (mapFunctions -> NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON .)


state 213

    (19) while -> WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .

    NAME            reduce using rule 19 (while -> WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CONST           reduce using rule 19 (while -> WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    LET             reduce using rule 19 (while -> WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    VAR             reduce using rule 19 (while -> WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    WHILE           reduce using rule 19 (while -> WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    FOR             reduce using rule 19 (while -> WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    IF              reduce using rule 19 (while -> WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    $end            reduce using rule 19 (while -> WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 19 (while -> WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)


state 214

    (20) while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .

    NAME            reduce using rule 20 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CONST           reduce using rule 20 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    LET             reduce using rule 20 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    VAR             reduce using rule 20 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    WHILE           reduce using rule 20 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    FOR             reduce using rule 20 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    IF              reduce using rule 20 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    $end            reduce using rule 20 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 20 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)


state 215

    (36) for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations . CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    CLOSE_PARENTHESIS shift and go to state 231


state 216

    (40) operations -> NUMBER . operand NUMBER
    (46) operand -> . SUMA
    (47) operand -> . RESTA
    (48) operand -> . MULTIPLICACION
    (49) operand -> . DIVISION

    SUMA            shift and go to state 127
    RESTA           shift and go to state 128
    MULTIPLICACION  shift and go to state 129
    DIVISION        shift and go to state 130

    operand                        shift and go to state 126

state 217

    (61) value -> NAME .

    SEMICOLON       reduce using rule 61 (value -> NAME .)


state 218

    (39) condition -> NAME clause value .

    SEMICOLON       reduce using rule 39 (condition -> NAME clause value .)


state 219

    (62) value -> NUMBER .

    SEMICOLON       reduce using rule 62 (value -> NUMBER .)


state 220

    (26) elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression . CLOSE_BRACE
    (27) elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression . CLOSE_BRACE soloIf

    CLOSE_BRACE     shift and go to state 232


state 221

    (25) soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .

    ELSEIF          reduce using rule 25 (soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    ELSE            reduce using rule 25 (soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    NAME            reduce using rule 25 (soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CONST           reduce using rule 25 (soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    LET             reduce using rule 25 (soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    VAR             reduce using rule 25 (soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    WHILE           reduce using rule 25 (soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    FOR             reduce using rule 25 (soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    IF              reduce using rule 25 (soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    $end            reduce using rule 25 (soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 25 (soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)


state 222

    (71) claveValor -> clave COLON valor COMMA claveValor .

    CLOSE_BRACE     reduce using rule 71 (claveValor -> clave COLON valor COMMA claveValor .)


state 223

    (63) array -> type NAME IGUAL . OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (64) array -> type NAME IGUAL . NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (89) set -> type NAME IGUAL . NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (90) set -> type NAME IGUAL . NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (91) set -> type NAME IGUAL . NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (10) variable -> type NAME IGUAL . datatype SEMICOLON
    (11) variable -> type NAME IGUAL . operations SEMICOLON
    (43) datatype -> . NUMBER
    (44) datatype -> . STRING
    (45) datatype -> . CHAR
    (40) operations -> . NUMBER operand NUMBER
    (41) operations -> . NAME SUMA SUMA
    (42) operations -> . NAME RESTA RESTA

    OPEN_BRACKET    shift and go to state 81
    NEW             shift and go to state 82
    NUMBER          shift and go to state 83
    STRING          shift and go to state 46
    CHAR            shift and go to state 47
    NAME            shift and go to state 78

    datatype                       shift and go to state 79
    operations                     shift and go to state 80

state 224

    (79) tupla -> OPEN_BRACKET datatype COMMA datatype CLOSE_BRACKET .

    COMMA           reduce using rule 79 (tupla -> OPEN_BRACKET datatype COMMA datatype CLOSE_BRACKET .)
    CLOSE_BRACE     reduce using rule 79 (tupla -> OPEN_BRACKET datatype COMMA datatype CLOSE_BRACKET .)


state 225

    (64) array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 233


state 226

    (89) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .

    NAME            reduce using rule 89 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    CONST           reduce using rule 89 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    LET             reduce using rule 89 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    VAR             reduce using rule 89 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    WHILE           reduce using rule 89 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    FOR             reduce using rule 89 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    IF              reduce using rule 89 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    $end            reduce using rule 89 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 89 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    COMMA           reduce using rule 89 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)


state 227

    (90) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items . CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON

    CLOSE_BRACKET   shift and go to state 234


state 228

    (91) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 235


state 229

    (93) set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET . CLOSE_PARENTHESIS SEMICOLON

    CLOSE_PARENTHESIS shift and go to state 236


state 230

    (94) set -> NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .

    NAME            reduce using rule 94 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    CONST           reduce using rule 94 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    LET             reduce using rule 94 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    VAR             reduce using rule 94 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    WHILE           reduce using rule 94 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    FOR             reduce using rule 94 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    IF              reduce using rule 94 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    $end            reduce using rule 94 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 94 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    COMMA           reduce using rule 94 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)


state 231

    (36) for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS . OPEN_BRACE expression CLOSE_BRACE

    OPEN_BRACE      shift and go to state 237


state 232

    (26) elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .
    (27) elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE . soloIf
    (25) soloIf -> . IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

  ! shift/reduce conflict for IF resolved as shift
    ELSE            reduce using rule 26 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    NAME            reduce using rule 26 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CONST           reduce using rule 26 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    LET             reduce using rule 26 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    VAR             reduce using rule 26 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    WHILE           reduce using rule 26 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    FOR             reduce using rule 26 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    $end            reduce using rule 26 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 26 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    IF              shift and go to state 25

  ! IF              [ reduce using rule 26 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .) ]

    soloIf                         shift and go to state 238

state 233

    (64) array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .

    NAME            reduce using rule 64 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    CONST           reduce using rule 64 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    LET             reduce using rule 64 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    VAR             reduce using rule 64 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    WHILE           reduce using rule 64 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    FOR             reduce using rule 64 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    IF              reduce using rule 64 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    $end            reduce using rule 64 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 64 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    COMMA           reduce using rule 64 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)


state 234

    (90) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET . CLOSE_PARENTHESIS SEMICOLON

    CLOSE_PARENTHESIS shift and go to state 239


state 235

    (91) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .

    NAME            reduce using rule 91 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    CONST           reduce using rule 91 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    LET             reduce using rule 91 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    VAR             reduce using rule 91 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    WHILE           reduce using rule 91 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    FOR             reduce using rule 91 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    IF              reduce using rule 91 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    $end            reduce using rule 91 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 91 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    COMMA           reduce using rule 91 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)


state 236

    (93) set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 240


state 237

    (36) for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE . expression CLOSE_BRACE
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) expression -> . methodsSet
    (8) expression -> . mapFunctions
    (9) expression -> . arrayFn
    (10) variable -> . type NAME IGUAL datatype SEMICOLON
    (11) variable -> . type NAME IGUAL operations SEMICOLON
    (12) variable -> . NAME IGUAL datatype SEMICOLON
    (16) dataStruct -> . array
    (17) dataStruct -> . set
    (18) dataStruct -> . map
    (13) controlStruct -> . while
    (14) controlStruct -> . for
    (15) controlStruct -> . if
    (95) methodsSet -> . NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (96) methodsSet -> . NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (97) methodsSet -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (80) mapFunctions -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (81) mapFunctions -> . NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (82) mapFunctions -> . NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (83) arrayFn -> . NAME POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS
    (84) arrayFn -> . NAME POINT PUSH OPEN_PARENTHESIS argUnico CLOSE_PARENTHESIS
    (85) arrayFn -> . NAME POINT UNSHIFT OPEN_PARENTHESIS argUnico CLOSE_PARENTHESIS
    (52) type -> . CONST
    (53) type -> . LET
    (54) type -> . VAR
    (63) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (64) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (89) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (90) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (91) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (92) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (93) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (94) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (65) map -> . iniciarMap
    (66) map -> . escribirMap
    (67) map -> . generarMap
    (19) while -> . WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (20) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (36) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (21) if -> . soloIf
    (22) if -> . soloIf elseIf
    (23) if -> . soloIf elseIf else
    (24) if -> . soloIf else
    (68) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (69) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (75) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (25) soloIf -> . IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    NAME            shift and go to state 9
    CONST           shift and go to state 16
    LET             shift and go to state 17
    VAR             shift and go to state 18
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    IF              shift and go to state 25

    expression                     shift and go to state 241
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    methodsSet                     shift and go to state 5
    mapFunctions                   shift and go to state 6
    arrayFn                        shift and go to state 7
    type                           shift and go to state 8
    array                          shift and go to state 10
    set                            shift and go to state 11
    map                            shift and go to state 12
    while                          shift and go to state 13
    for                            shift and go to state 14
    if                             shift and go to state 15
    iniciarMap                     shift and go to state 19
    escribirMap                    shift and go to state 20
    generarMap                     shift and go to state 21
    soloIf                         shift and go to state 24

state 238

    (27) elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .

    ELSE            reduce using rule 27 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .)
    NAME            reduce using rule 27 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .)
    CONST           reduce using rule 27 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .)
    LET             reduce using rule 27 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .)
    VAR             reduce using rule 27 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .)
    WHILE           reduce using rule 27 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .)
    FOR             reduce using rule 27 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .)
    IF              reduce using rule 27 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .)
    $end            reduce using rule 27 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .)
    CLOSE_BRACE     reduce using rule 27 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .)


state 239

    (90) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 242


state 240

    (93) set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .

    NAME            reduce using rule 93 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    CONST           reduce using rule 93 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    LET             reduce using rule 93 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    VAR             reduce using rule 93 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    WHILE           reduce using rule 93 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    FOR             reduce using rule 93 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    IF              reduce using rule 93 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    $end            reduce using rule 93 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 93 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    COMMA           reduce using rule 93 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)


state 241

    (36) for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression . CLOSE_BRACE

    CLOSE_BRACE     shift and go to state 243


state 242

    (90) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .

    NAME            reduce using rule 90 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    CONST           reduce using rule 90 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    LET             reduce using rule 90 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    VAR             reduce using rule 90 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    WHILE           reduce using rule 90 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    FOR             reduce using rule 90 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    IF              reduce using rule 90 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    $end            reduce using rule 90 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 90 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    COMMA           reduce using rule 90 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)


state 243

    (36) for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .

    NAME            reduce using rule 36 (for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CONST           reduce using rule 36 (for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    LET             reduce using rule 36 (for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    VAR             reduce using rule 36 (for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    WHILE           reduce using rule 36 (for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    FOR             reduce using rule 36 (for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    IF              reduce using rule 36 (for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    $end            reduce using rule 36 (for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 36 (for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for IF in state 232 resolved as shift
WARNING: reduce/reduce conflict in state 176 resolved using rule (mapFunctions -> NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON)
WARNING: rejected rule (methodsSet -> NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON) in state 176
WARNING: Rule (methodsSet -> NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON) is never reduced
