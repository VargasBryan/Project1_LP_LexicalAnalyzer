Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BACKSLASH
    BOOLEAN
    COMMENTS
    DIVIGUAL
    DOUBLE_QUOTES
    FLOAT
    INT
    LINE_BREAK
    LONGCOMMENT
    MASIGUAL
    MENOSIGUAL
    MODIGUAL
    NULL
    PORIGUAL
    POTIGUAL
    PRINT
    SINGLE_QUOTE
    UNDEFINED

Grammar

Rule 0     S' -> expression
Rule 1     expression -> variable
Rule 2     expression -> variable expression
Rule 3     expression -> dataStruct
Rule 4     expression -> dataStruct expression
Rule 5     expression -> controlStruct
Rule 6     expression -> controlStruct expression
Rule 7     expression -> methodsSet
Rule 8     expression -> mapFunctions
Rule 9     expression -> arrayFn
Rule 10    expression -> declaration
Rule 11    expression -> return
Rule 12    expression -> function
Rule 13    variable -> type NAME IGUAL datatype SEMICOLON
Rule 14    variable -> type NAME IGUAL operations SEMICOLON
Rule 15    variable -> NAME IGUAL datatype SEMICOLON
Rule 16    controlStruct -> while
Rule 17    controlStruct -> for
Rule 18    controlStruct -> if
Rule 19    dataStruct -> array
Rule 20    dataStruct -> set
Rule 21    dataStruct -> map
Rule 22    while -> WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
Rule 23    while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
Rule 24    if -> soloIf
Rule 25    if -> soloIf elseIf
Rule 26    if -> soloIf elseIf else
Rule 27    if -> soloIf else
Rule 28    soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
Rule 29    elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
Rule 30    elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf
Rule 31    else -> ELSE OPEN_BRACE expression CLOSE_BRACE
Rule 32    controlArg -> element clause element
Rule 33    for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
Rule 34    inicialization -> type NAME IGUAL NUMBER
Rule 35    inicialization -> NAME IGUAL NUMBER
Rule 36    operations -> NUMBER operand NUMBER
Rule 37    operations -> NAME
Rule 38    operations -> NUMBER
Rule 39    operations -> NUMBER operand NAME operations
Rule 40    operations -> NAME operand NUMBER operations
Rule 41    operations -> NUMBER operand NAME
Rule 42    operations -> NAME operand NUMBER
Rule 43    operations -> NAME operand NAME operations
Rule 44    operations -> NUMBER operand NUMBER operand operations
Rule 45    datatype -> NUMBER
Rule 46    datatype -> STRING
Rule 47    datatype -> CHAR
Rule 48    operand -> SUMA
Rule 49    operand -> RESTA
Rule 50    operand -> MULTIPLICACION
Rule 51    operand -> DIVISION
Rule 52    bool -> TRUE
Rule 53    bool -> FALSE
Rule 54    type -> CONST
Rule 55    type -> LET
Rule 56    type -> VAR
Rule 57    clause -> IGUALIGUAL
Rule 58    clause -> DIFERENTE
Rule 59    clause -> MAYORQUE
Rule 60    clause -> MAYORIGUALQUE
Rule 61    clause -> MENORQUE
Rule 62    clause -> MENORIGUALQUE
Rule 63    value -> NAME
Rule 64    value -> NUMBER
Rule 65    array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
Rule 66    array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
Rule 67    map -> iniciarMap
Rule 68    map -> escribirMap
Rule 69    map -> generarMap
Rule 70    iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
Rule 71    escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
Rule 72    claveValor -> clave COLON valor
Rule 73    claveValor -> clave COLON valor COMMA claveValor
Rule 74    clave -> datatype
Rule 75    valor -> datatype
Rule 76    valor -> dataStruct
Rule 77    generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
Rule 78    tuplas -> tupla
Rule 79    tuplas -> tupla COMMA tuplas
Rule 80    tupla -> OPEN_BRACKET datatype CLOSE_BRACKET SEMICOLON
Rule 81    tupla -> OPEN_BRACKET datatype COMMA datatype CLOSE_BRACKET SEMICOLON
Rule 82    mapFunctions -> NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
Rule 83    mapFunctions -> NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
Rule 84    mapFunctions -> NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
Rule 85    arrayFn -> NAME POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
Rule 86    arrayFn -> NAME POINT PUSH OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
Rule 87    arrayFn -> NAME POINT UNSHIFT OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
Rule 88    set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
Rule 89    set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
Rule 90    set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
Rule 91    set -> NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
Rule 92    set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
Rule 93    set -> NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
Rule 94    methodsSet -> NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
Rule 95    methodsSet -> NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
Rule 96    methodsSet -> NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
Rule 97    items -> numeros
Rule 98    items -> cadena
Rule 99    numeros -> NUMBER
Rule 100   numeros -> NUMBER COMMA numeros
Rule 101   cadena -> STRING
Rule 102   cadena -> STRING COMMA cadena
Rule 103   element -> STRING
Rule 104   element -> NUMBER
Rule 105   element -> NAME
Rule 106   declaration -> NAME IGUAL element SEMICOLON
Rule 107   logicalOperator -> AND
Rule 108   logicalOperator -> OR
Rule 109   expBoolean -> controlArg
Rule 110   expBoolean -> bool
Rule 111   expBoolean -> NOT expBoolean
Rule 112   expBoolean -> expBoolean logicalOperator expBoolean
Rule 113   function -> FUNCTION NAME OPEN_PARENTHESIS CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
Rule 114   function -> FUNCTION NAME OPEN_PARENTHESIS parameter CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
Rule 115   parameter -> element
Rule 116   parameter -> element parameter
Rule 117   return -> RETURN element SEMICOLON

Terminals, with rules where they appear

ADD                  : 94
AND                  : 107
ARRAY                : 66
BACKSLASH            : 
BOOLEAN              : 
CHAR                 : 47
CLEAR                : 82 96
CLOSE_BRACE          : 22 23 28 29 30 31 33 71 77 113 114
CLOSE_BRACKET        : 65 80 81 89 92
CLOSE_PARENTHESIS    : 22 23 28 29 30 33 66 70 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 113 114
COLON                : 72 73
COMMA                : 73 79 81 100 102
COMMENTS             : 
CONST                : 54
DELETE               : 95
DIFERENTE            : 58
DIVIGUAL             : 
DIVISION             : 51
DOUBLE_QUOTES        : 
ELSE                 : 31
ELSEIF               : 29 30
FALSE                : 53
FLOAT                : 
FOR                  : 33
FUNCTION             : 113 114
GET                  : 83
HAS                  : 84
IF                   : 28
IGUAL                : 13 14 15 34 35 65 66 70 71 77 88 89 90 91 92 93 106
IGUALIGUAL           : 57
INT                  : 
LET                  : 55
LINE_BREAK           : 
LONGCOMMENT          : 
MAP                  : 70
MASIGUAL             : 
MAYORIGUALQUE        : 60
MAYORQUE             : 59
MENORIGUALQUE        : 62
MENORQUE             : 61
MENOSIGUAL           : 
MODIGUAL             : 
MULTIPLICACION       : 50
NAME                 : 13 14 15 34 35 37 39 40 41 42 43 43 63 65 66 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 105 106 113 114
NEW                  : 66 70 88 89 90 91 92 93
NOT                  : 111
NULL                 : 
NUMBER               : 34 35 36 36 38 39 40 41 42 44 44 45 64 99 100 104
OPEN_BRACE           : 22 23 28 29 30 31 33 71 77 113 114
OPEN_BRACKET         : 65 80 81 89 92
OPEN_PARENTHESIS     : 22 23 28 29 30 33 66 70 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 113 114
OR                   : 108
POINT                : 82 83 84 85 86 87 94 95 96
POP                  : 85
PORIGUAL             : 
POTIGUAL             : 
PRINT                : 
PUSH                 : 86
RESTA                : 49
RETURN               : 117
SEMICOLON            : 13 14 15 33 33 65 66 70 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 106 117
SET                  : 88 89 90 91 92 93
SINGLE_QUOTE         : 
STRING               : 46 101 102 103
SUMA                 : 48
TRUE                 : 52
UNDEFINED            : 
UNSHIFT              : 87
VAR                  : 56
WHILE                : 22 23
error                : 

Nonterminals, with rules where they appear

array                : 19
arrayFn              : 9
bool                 : 23 110
cadena               : 98 102
clause               : 32
clave                : 72 73 83 84
claveValor           : 71 73
controlArg           : 22 28 29 30 109
controlStruct        : 5 6
dataStruct           : 3 4 76
datatype             : 13 15 74 75 80 81 81
declaration          : 10
element              : 32 32 86 87 90 93 94 95 106 115 116 117
else                 : 26 27
elseIf               : 25 26
escribirMap          : 68
expBoolean           : 33 111 112 112
expression           : 2 4 6 22 23 28 29 30 31 33 113 114 0
for                  : 17
function             : 12
generarMap           : 69
if                   : 18
inicialization       : 33
iniciarMap           : 67
items                : 65 66 89 92
logicalOperator      : 112
map                  : 21
mapFunctions         : 8
methodsSet           : 7
numeros              : 97 100
operand              : 36 39 40 41 42 43 44 44
operations           : 14 33 39 40 43 44
parameter            : 114 116
return               : 11
set                  : 20
soloIf               : 24 25 26 27 30
tupla                : 78 79
tuplas               : 77 79
type                 : 13 14 34 65 66 88 89 90
valor                : 72 73
value                : 
variable             : 1 2 70 71 77
while                : 16

Parsing method: LALR

state 0

    (0) S' -> . expression
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) expression -> . methodsSet
    (8) expression -> . mapFunctions
    (9) expression -> . arrayFn
    (10) expression -> . declaration
    (11) expression -> . return
    (12) expression -> . function
    (13) variable -> . type NAME IGUAL datatype SEMICOLON
    (14) variable -> . type NAME IGUAL operations SEMICOLON
    (15) variable -> . NAME IGUAL datatype SEMICOLON
    (19) dataStruct -> . array
    (20) dataStruct -> . set
    (21) dataStruct -> . map
    (16) controlStruct -> . while
    (17) controlStruct -> . for
    (18) controlStruct -> . if
    (94) methodsSet -> . NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (95) methodsSet -> . NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (96) methodsSet -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (82) mapFunctions -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (83) mapFunctions -> . NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (84) mapFunctions -> . NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (85) arrayFn -> . NAME POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (86) arrayFn -> . NAME POINT PUSH OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (87) arrayFn -> . NAME POINT UNSHIFT OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (106) declaration -> . NAME IGUAL element SEMICOLON
    (117) return -> . RETURN element SEMICOLON
    (113) function -> . FUNCTION NAME OPEN_PARENTHESIS CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (114) function -> . FUNCTION NAME OPEN_PARENTHESIS parameter CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (54) type -> . CONST
    (55) type -> . LET
    (56) type -> . VAR
    (65) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (66) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (88) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (89) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (90) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (91) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (92) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (93) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (67) map -> . iniciarMap
    (68) map -> . escribirMap
    (69) map -> . generarMap
    (22) while -> . WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (23) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (33) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (24) if -> . soloIf
    (25) if -> . soloIf elseIf
    (26) if -> . soloIf elseIf else
    (27) if -> . soloIf else
    (70) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (71) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (77) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (28) soloIf -> . IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    NAME            shift and go to state 12
    RETURN          shift and go to state 19
    FUNCTION        shift and go to state 20
    CONST           shift and go to state 21
    LET             shift and go to state 22
    VAR             shift and go to state 23
    WHILE           shift and go to state 27
    FOR             shift and go to state 28
    IF              shift and go to state 30

    expression                     shift and go to state 1
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    methodsSet                     shift and go to state 5
    mapFunctions                   shift and go to state 6
    arrayFn                        shift and go to state 7
    declaration                    shift and go to state 8
    return                         shift and go to state 9
    function                       shift and go to state 10
    type                           shift and go to state 11
    array                          shift and go to state 13
    set                            shift and go to state 14
    map                            shift and go to state 15
    while                          shift and go to state 16
    for                            shift and go to state 17
    if                             shift and go to state 18
    iniciarMap                     shift and go to state 24
    escribirMap                    shift and go to state 25
    generarMap                     shift and go to state 26
    soloIf                         shift and go to state 29

state 1

    (0) S' -> expression .



state 2

    (1) expression -> variable .
    (2) expression -> variable . expression
    (70) iniciarMap -> variable . IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (71) escribirMap -> variable . IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (77) generarMap -> variable . IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) expression -> . methodsSet
    (8) expression -> . mapFunctions
    (9) expression -> . arrayFn
    (10) expression -> . declaration
    (11) expression -> . return
    (12) expression -> . function
    (13) variable -> . type NAME IGUAL datatype SEMICOLON
    (14) variable -> . type NAME IGUAL operations SEMICOLON
    (15) variable -> . NAME IGUAL datatype SEMICOLON
    (19) dataStruct -> . array
    (20) dataStruct -> . set
    (21) dataStruct -> . map
    (16) controlStruct -> . while
    (17) controlStruct -> . for
    (18) controlStruct -> . if
    (94) methodsSet -> . NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (95) methodsSet -> . NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (96) methodsSet -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (82) mapFunctions -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (83) mapFunctions -> . NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (84) mapFunctions -> . NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (85) arrayFn -> . NAME POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (86) arrayFn -> . NAME POINT PUSH OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (87) arrayFn -> . NAME POINT UNSHIFT OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (106) declaration -> . NAME IGUAL element SEMICOLON
    (117) return -> . RETURN element SEMICOLON
    (113) function -> . FUNCTION NAME OPEN_PARENTHESIS CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (114) function -> . FUNCTION NAME OPEN_PARENTHESIS parameter CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (54) type -> . CONST
    (55) type -> . LET
    (56) type -> . VAR
    (65) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (66) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (88) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (89) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (90) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (91) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (92) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (93) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (67) map -> . iniciarMap
    (68) map -> . escribirMap
    (69) map -> . generarMap
    (22) while -> . WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (23) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (33) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (24) if -> . soloIf
    (25) if -> . soloIf elseIf
    (26) if -> . soloIf elseIf else
    (27) if -> . soloIf else
    (70) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (71) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (77) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (28) soloIf -> . IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    $end            reduce using rule 1 (expression -> variable .)
    CLOSE_BRACE     reduce using rule 1 (expression -> variable .)
    IGUAL           shift and go to state 32
    NAME            shift and go to state 12
    RETURN          shift and go to state 19
    FUNCTION        shift and go to state 20
    CONST           shift and go to state 21
    LET             shift and go to state 22
    VAR             shift and go to state 23
    WHILE           shift and go to state 27
    FOR             shift and go to state 28
    IF              shift and go to state 30

    variable                       shift and go to state 2
    expression                     shift and go to state 31
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    methodsSet                     shift and go to state 5
    mapFunctions                   shift and go to state 6
    arrayFn                        shift and go to state 7
    declaration                    shift and go to state 8
    return                         shift and go to state 9
    function                       shift and go to state 10
    type                           shift and go to state 11
    array                          shift and go to state 13
    set                            shift and go to state 14
    map                            shift and go to state 15
    while                          shift and go to state 16
    for                            shift and go to state 17
    if                             shift and go to state 18
    iniciarMap                     shift and go to state 24
    escribirMap                    shift and go to state 25
    generarMap                     shift and go to state 26
    soloIf                         shift and go to state 29

state 3

    (3) expression -> dataStruct .
    (4) expression -> dataStruct . expression
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) expression -> . methodsSet
    (8) expression -> . mapFunctions
    (9) expression -> . arrayFn
    (10) expression -> . declaration
    (11) expression -> . return
    (12) expression -> . function
    (13) variable -> . type NAME IGUAL datatype SEMICOLON
    (14) variable -> . type NAME IGUAL operations SEMICOLON
    (15) variable -> . NAME IGUAL datatype SEMICOLON
    (19) dataStruct -> . array
    (20) dataStruct -> . set
    (21) dataStruct -> . map
    (16) controlStruct -> . while
    (17) controlStruct -> . for
    (18) controlStruct -> . if
    (94) methodsSet -> . NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (95) methodsSet -> . NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (96) methodsSet -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (82) mapFunctions -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (83) mapFunctions -> . NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (84) mapFunctions -> . NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (85) arrayFn -> . NAME POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (86) arrayFn -> . NAME POINT PUSH OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (87) arrayFn -> . NAME POINT UNSHIFT OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (106) declaration -> . NAME IGUAL element SEMICOLON
    (117) return -> . RETURN element SEMICOLON
    (113) function -> . FUNCTION NAME OPEN_PARENTHESIS CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (114) function -> . FUNCTION NAME OPEN_PARENTHESIS parameter CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (54) type -> . CONST
    (55) type -> . LET
    (56) type -> . VAR
    (65) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (66) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (88) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (89) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (90) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (91) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (92) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (93) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (67) map -> . iniciarMap
    (68) map -> . escribirMap
    (69) map -> . generarMap
    (22) while -> . WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (23) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (33) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (24) if -> . soloIf
    (25) if -> . soloIf elseIf
    (26) if -> . soloIf elseIf else
    (27) if -> . soloIf else
    (70) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (71) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (77) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (28) soloIf -> . IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    $end            reduce using rule 3 (expression -> dataStruct .)
    CLOSE_BRACE     reduce using rule 3 (expression -> dataStruct .)
    NAME            shift and go to state 12
    RETURN          shift and go to state 19
    FUNCTION        shift and go to state 20
    CONST           shift and go to state 21
    LET             shift and go to state 22
    VAR             shift and go to state 23
    WHILE           shift and go to state 27
    FOR             shift and go to state 28
    IF              shift and go to state 30

    dataStruct                     shift and go to state 3
    expression                     shift and go to state 33
    variable                       shift and go to state 2
    controlStruct                  shift and go to state 4
    methodsSet                     shift and go to state 5
    mapFunctions                   shift and go to state 6
    arrayFn                        shift and go to state 7
    declaration                    shift and go to state 8
    return                         shift and go to state 9
    function                       shift and go to state 10
    type                           shift and go to state 11
    array                          shift and go to state 13
    set                            shift and go to state 14
    map                            shift and go to state 15
    while                          shift and go to state 16
    for                            shift and go to state 17
    if                             shift and go to state 18
    iniciarMap                     shift and go to state 24
    escribirMap                    shift and go to state 25
    generarMap                     shift and go to state 26
    soloIf                         shift and go to state 29

state 4

    (5) expression -> controlStruct .
    (6) expression -> controlStruct . expression
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) expression -> . methodsSet
    (8) expression -> . mapFunctions
    (9) expression -> . arrayFn
    (10) expression -> . declaration
    (11) expression -> . return
    (12) expression -> . function
    (13) variable -> . type NAME IGUAL datatype SEMICOLON
    (14) variable -> . type NAME IGUAL operations SEMICOLON
    (15) variable -> . NAME IGUAL datatype SEMICOLON
    (19) dataStruct -> . array
    (20) dataStruct -> . set
    (21) dataStruct -> . map
    (16) controlStruct -> . while
    (17) controlStruct -> . for
    (18) controlStruct -> . if
    (94) methodsSet -> . NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (95) methodsSet -> . NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (96) methodsSet -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (82) mapFunctions -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (83) mapFunctions -> . NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (84) mapFunctions -> . NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (85) arrayFn -> . NAME POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (86) arrayFn -> . NAME POINT PUSH OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (87) arrayFn -> . NAME POINT UNSHIFT OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (106) declaration -> . NAME IGUAL element SEMICOLON
    (117) return -> . RETURN element SEMICOLON
    (113) function -> . FUNCTION NAME OPEN_PARENTHESIS CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (114) function -> . FUNCTION NAME OPEN_PARENTHESIS parameter CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (54) type -> . CONST
    (55) type -> . LET
    (56) type -> . VAR
    (65) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (66) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (88) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (89) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (90) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (91) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (92) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (93) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (67) map -> . iniciarMap
    (68) map -> . escribirMap
    (69) map -> . generarMap
    (22) while -> . WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (23) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (33) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (24) if -> . soloIf
    (25) if -> . soloIf elseIf
    (26) if -> . soloIf elseIf else
    (27) if -> . soloIf else
    (70) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (71) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (77) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (28) soloIf -> . IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    $end            reduce using rule 5 (expression -> controlStruct .)
    CLOSE_BRACE     reduce using rule 5 (expression -> controlStruct .)
    NAME            shift and go to state 12
    RETURN          shift and go to state 19
    FUNCTION        shift and go to state 20
    CONST           shift and go to state 21
    LET             shift and go to state 22
    VAR             shift and go to state 23
    WHILE           shift and go to state 27
    FOR             shift and go to state 28
    IF              shift and go to state 30

    controlStruct                  shift and go to state 4
    expression                     shift and go to state 34
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    methodsSet                     shift and go to state 5
    mapFunctions                   shift and go to state 6
    arrayFn                        shift and go to state 7
    declaration                    shift and go to state 8
    return                         shift and go to state 9
    function                       shift and go to state 10
    type                           shift and go to state 11
    array                          shift and go to state 13
    set                            shift and go to state 14
    map                            shift and go to state 15
    while                          shift and go to state 16
    for                            shift and go to state 17
    if                             shift and go to state 18
    iniciarMap                     shift and go to state 24
    escribirMap                    shift and go to state 25
    generarMap                     shift and go to state 26
    soloIf                         shift and go to state 29

state 5

    (7) expression -> methodsSet .

    $end            reduce using rule 7 (expression -> methodsSet .)
    CLOSE_BRACE     reduce using rule 7 (expression -> methodsSet .)


state 6

    (8) expression -> mapFunctions .

    $end            reduce using rule 8 (expression -> mapFunctions .)
    CLOSE_BRACE     reduce using rule 8 (expression -> mapFunctions .)


state 7

    (9) expression -> arrayFn .

    $end            reduce using rule 9 (expression -> arrayFn .)
    CLOSE_BRACE     reduce using rule 9 (expression -> arrayFn .)


state 8

    (10) expression -> declaration .

    $end            reduce using rule 10 (expression -> declaration .)
    CLOSE_BRACE     reduce using rule 10 (expression -> declaration .)


state 9

    (11) expression -> return .

    $end            reduce using rule 11 (expression -> return .)
    CLOSE_BRACE     reduce using rule 11 (expression -> return .)


state 10

    (12) expression -> function .

    $end            reduce using rule 12 (expression -> function .)
    CLOSE_BRACE     reduce using rule 12 (expression -> function .)


state 11

    (13) variable -> type . NAME IGUAL datatype SEMICOLON
    (14) variable -> type . NAME IGUAL operations SEMICOLON
    (65) array -> type . NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (66) array -> type . NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (88) set -> type . NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (89) set -> type . NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (90) set -> type . NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON

    NAME            shift and go to state 35


state 12

    (15) variable -> NAME . IGUAL datatype SEMICOLON
    (94) methodsSet -> NAME . POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (95) methodsSet -> NAME . POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (96) methodsSet -> NAME . POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (82) mapFunctions -> NAME . POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (83) mapFunctions -> NAME . POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (84) mapFunctions -> NAME . POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (85) arrayFn -> NAME . POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (86) arrayFn -> NAME . POINT PUSH OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (87) arrayFn -> NAME . POINT UNSHIFT OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (106) declaration -> NAME . IGUAL element SEMICOLON
    (91) set -> NAME . IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (92) set -> NAME . IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (93) set -> NAME . IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON

    IGUAL           shift and go to state 36
    POINT           shift and go to state 37


state 13

    (19) dataStruct -> array .

    NAME            reduce using rule 19 (dataStruct -> array .)
    RETURN          reduce using rule 19 (dataStruct -> array .)
    FUNCTION        reduce using rule 19 (dataStruct -> array .)
    CONST           reduce using rule 19 (dataStruct -> array .)
    LET             reduce using rule 19 (dataStruct -> array .)
    VAR             reduce using rule 19 (dataStruct -> array .)
    WHILE           reduce using rule 19 (dataStruct -> array .)
    FOR             reduce using rule 19 (dataStruct -> array .)
    IF              reduce using rule 19 (dataStruct -> array .)
    $end            reduce using rule 19 (dataStruct -> array .)
    CLOSE_BRACE     reduce using rule 19 (dataStruct -> array .)
    COMMA           reduce using rule 19 (dataStruct -> array .)


state 14

    (20) dataStruct -> set .

    NAME            reduce using rule 20 (dataStruct -> set .)
    RETURN          reduce using rule 20 (dataStruct -> set .)
    FUNCTION        reduce using rule 20 (dataStruct -> set .)
    CONST           reduce using rule 20 (dataStruct -> set .)
    LET             reduce using rule 20 (dataStruct -> set .)
    VAR             reduce using rule 20 (dataStruct -> set .)
    WHILE           reduce using rule 20 (dataStruct -> set .)
    FOR             reduce using rule 20 (dataStruct -> set .)
    IF              reduce using rule 20 (dataStruct -> set .)
    $end            reduce using rule 20 (dataStruct -> set .)
    CLOSE_BRACE     reduce using rule 20 (dataStruct -> set .)
    COMMA           reduce using rule 20 (dataStruct -> set .)


state 15

    (21) dataStruct -> map .

    NAME            reduce using rule 21 (dataStruct -> map .)
    RETURN          reduce using rule 21 (dataStruct -> map .)
    FUNCTION        reduce using rule 21 (dataStruct -> map .)
    CONST           reduce using rule 21 (dataStruct -> map .)
    LET             reduce using rule 21 (dataStruct -> map .)
    VAR             reduce using rule 21 (dataStruct -> map .)
    WHILE           reduce using rule 21 (dataStruct -> map .)
    FOR             reduce using rule 21 (dataStruct -> map .)
    IF              reduce using rule 21 (dataStruct -> map .)
    $end            reduce using rule 21 (dataStruct -> map .)
    CLOSE_BRACE     reduce using rule 21 (dataStruct -> map .)
    COMMA           reduce using rule 21 (dataStruct -> map .)


state 16

    (16) controlStruct -> while .

    NAME            reduce using rule 16 (controlStruct -> while .)
    RETURN          reduce using rule 16 (controlStruct -> while .)
    FUNCTION        reduce using rule 16 (controlStruct -> while .)
    CONST           reduce using rule 16 (controlStruct -> while .)
    LET             reduce using rule 16 (controlStruct -> while .)
    VAR             reduce using rule 16 (controlStruct -> while .)
    WHILE           reduce using rule 16 (controlStruct -> while .)
    FOR             reduce using rule 16 (controlStruct -> while .)
    IF              reduce using rule 16 (controlStruct -> while .)
    $end            reduce using rule 16 (controlStruct -> while .)
    CLOSE_BRACE     reduce using rule 16 (controlStruct -> while .)


state 17

    (17) controlStruct -> for .

    NAME            reduce using rule 17 (controlStruct -> for .)
    RETURN          reduce using rule 17 (controlStruct -> for .)
    FUNCTION        reduce using rule 17 (controlStruct -> for .)
    CONST           reduce using rule 17 (controlStruct -> for .)
    LET             reduce using rule 17 (controlStruct -> for .)
    VAR             reduce using rule 17 (controlStruct -> for .)
    WHILE           reduce using rule 17 (controlStruct -> for .)
    FOR             reduce using rule 17 (controlStruct -> for .)
    IF              reduce using rule 17 (controlStruct -> for .)
    $end            reduce using rule 17 (controlStruct -> for .)
    CLOSE_BRACE     reduce using rule 17 (controlStruct -> for .)


state 18

    (18) controlStruct -> if .

    NAME            reduce using rule 18 (controlStruct -> if .)
    RETURN          reduce using rule 18 (controlStruct -> if .)
    FUNCTION        reduce using rule 18 (controlStruct -> if .)
    CONST           reduce using rule 18 (controlStruct -> if .)
    LET             reduce using rule 18 (controlStruct -> if .)
    VAR             reduce using rule 18 (controlStruct -> if .)
    WHILE           reduce using rule 18 (controlStruct -> if .)
    FOR             reduce using rule 18 (controlStruct -> if .)
    IF              reduce using rule 18 (controlStruct -> if .)
    $end            reduce using rule 18 (controlStruct -> if .)
    CLOSE_BRACE     reduce using rule 18 (controlStruct -> if .)


state 19

    (117) return -> RETURN . element SEMICOLON
    (103) element -> . STRING
    (104) element -> . NUMBER
    (105) element -> . NAME

    STRING          shift and go to state 39
    NUMBER          shift and go to state 40
    NAME            shift and go to state 41

    element                        shift and go to state 38

state 20

    (113) function -> FUNCTION . NAME OPEN_PARENTHESIS CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (114) function -> FUNCTION . NAME OPEN_PARENTHESIS parameter CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    NAME            shift and go to state 42


state 21

    (54) type -> CONST .

    NAME            reduce using rule 54 (type -> CONST .)


state 22

    (55) type -> LET .

    NAME            reduce using rule 55 (type -> LET .)


state 23

    (56) type -> VAR .

    NAME            reduce using rule 56 (type -> VAR .)


state 24

    (67) map -> iniciarMap .

    NAME            reduce using rule 67 (map -> iniciarMap .)
    RETURN          reduce using rule 67 (map -> iniciarMap .)
    FUNCTION        reduce using rule 67 (map -> iniciarMap .)
    CONST           reduce using rule 67 (map -> iniciarMap .)
    LET             reduce using rule 67 (map -> iniciarMap .)
    VAR             reduce using rule 67 (map -> iniciarMap .)
    WHILE           reduce using rule 67 (map -> iniciarMap .)
    FOR             reduce using rule 67 (map -> iniciarMap .)
    IF              reduce using rule 67 (map -> iniciarMap .)
    $end            reduce using rule 67 (map -> iniciarMap .)
    CLOSE_BRACE     reduce using rule 67 (map -> iniciarMap .)
    COMMA           reduce using rule 67 (map -> iniciarMap .)


state 25

    (68) map -> escribirMap .

    NAME            reduce using rule 68 (map -> escribirMap .)
    RETURN          reduce using rule 68 (map -> escribirMap .)
    FUNCTION        reduce using rule 68 (map -> escribirMap .)
    CONST           reduce using rule 68 (map -> escribirMap .)
    LET             reduce using rule 68 (map -> escribirMap .)
    VAR             reduce using rule 68 (map -> escribirMap .)
    WHILE           reduce using rule 68 (map -> escribirMap .)
    FOR             reduce using rule 68 (map -> escribirMap .)
    IF              reduce using rule 68 (map -> escribirMap .)
    $end            reduce using rule 68 (map -> escribirMap .)
    CLOSE_BRACE     reduce using rule 68 (map -> escribirMap .)
    COMMA           reduce using rule 68 (map -> escribirMap .)


state 26

    (69) map -> generarMap .

    NAME            reduce using rule 69 (map -> generarMap .)
    RETURN          reduce using rule 69 (map -> generarMap .)
    FUNCTION        reduce using rule 69 (map -> generarMap .)
    CONST           reduce using rule 69 (map -> generarMap .)
    LET             reduce using rule 69 (map -> generarMap .)
    VAR             reduce using rule 69 (map -> generarMap .)
    WHILE           reduce using rule 69 (map -> generarMap .)
    FOR             reduce using rule 69 (map -> generarMap .)
    IF              reduce using rule 69 (map -> generarMap .)
    $end            reduce using rule 69 (map -> generarMap .)
    CLOSE_BRACE     reduce using rule 69 (map -> generarMap .)
    COMMA           reduce using rule 69 (map -> generarMap .)


state 27

    (22) while -> WHILE . OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (23) while -> WHILE . OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    OPEN_PARENTHESIS shift and go to state 43


state 28

    (33) for -> FOR . OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    OPEN_PARENTHESIS shift and go to state 44


state 29

    (24) if -> soloIf .
    (25) if -> soloIf . elseIf
    (26) if -> soloIf . elseIf else
    (27) if -> soloIf . else
    (29) elseIf -> . ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (30) elseIf -> . ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf
    (31) else -> . ELSE OPEN_BRACE expression CLOSE_BRACE

    NAME            reduce using rule 24 (if -> soloIf .)
    RETURN          reduce using rule 24 (if -> soloIf .)
    FUNCTION        reduce using rule 24 (if -> soloIf .)
    CONST           reduce using rule 24 (if -> soloIf .)
    LET             reduce using rule 24 (if -> soloIf .)
    VAR             reduce using rule 24 (if -> soloIf .)
    WHILE           reduce using rule 24 (if -> soloIf .)
    FOR             reduce using rule 24 (if -> soloIf .)
    IF              reduce using rule 24 (if -> soloIf .)
    $end            reduce using rule 24 (if -> soloIf .)
    CLOSE_BRACE     reduce using rule 24 (if -> soloIf .)
    ELSEIF          shift and go to state 47
    ELSE            shift and go to state 48

    elseIf                         shift and go to state 45
    else                           shift and go to state 46

state 30

    (28) soloIf -> IF . OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    OPEN_PARENTHESIS shift and go to state 49


state 31

    (2) expression -> variable expression .

    $end            reduce using rule 2 (expression -> variable expression .)
    CLOSE_BRACE     reduce using rule 2 (expression -> variable expression .)


state 32

    (70) iniciarMap -> variable IGUAL . NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (71) escribirMap -> variable IGUAL . OPEN_BRACE claveValor CLOSE_BRACE
    (77) generarMap -> variable IGUAL . OPEN_BRACE tuplas CLOSE_BRACE

    NEW             shift and go to state 50
    OPEN_BRACE      shift and go to state 51


state 33

    (4) expression -> dataStruct expression .

    $end            reduce using rule 4 (expression -> dataStruct expression .)
    CLOSE_BRACE     reduce using rule 4 (expression -> dataStruct expression .)


state 34

    (6) expression -> controlStruct expression .

    $end            reduce using rule 6 (expression -> controlStruct expression .)
    CLOSE_BRACE     reduce using rule 6 (expression -> controlStruct expression .)


state 35

    (13) variable -> type NAME . IGUAL datatype SEMICOLON
    (14) variable -> type NAME . IGUAL operations SEMICOLON
    (65) array -> type NAME . IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (66) array -> type NAME . IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (88) set -> type NAME . IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (89) set -> type NAME . IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (90) set -> type NAME . IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON

    IGUAL           shift and go to state 52


state 36

    (15) variable -> NAME IGUAL . datatype SEMICOLON
    (106) declaration -> NAME IGUAL . element SEMICOLON
    (91) set -> NAME IGUAL . NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (92) set -> NAME IGUAL . NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (93) set -> NAME IGUAL . NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (45) datatype -> . NUMBER
    (46) datatype -> . STRING
    (47) datatype -> . CHAR
    (103) element -> . STRING
    (104) element -> . NUMBER
    (105) element -> . NAME

    NEW             shift and go to state 55
    NUMBER          shift and go to state 56
    STRING          shift and go to state 57
    CHAR            shift and go to state 58
    NAME            shift and go to state 41

    datatype                       shift and go to state 53
    element                        shift and go to state 54

state 37

    (94) methodsSet -> NAME POINT . ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (95) methodsSet -> NAME POINT . DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (96) methodsSet -> NAME POINT . CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (82) mapFunctions -> NAME POINT . CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (83) mapFunctions -> NAME POINT . GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (84) mapFunctions -> NAME POINT . HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (85) arrayFn -> NAME POINT . POP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (86) arrayFn -> NAME POINT . PUSH OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (87) arrayFn -> NAME POINT . UNSHIFT OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON

    ADD             shift and go to state 59
    DELETE          shift and go to state 60
    CLEAR           shift and go to state 61
    GET             shift and go to state 62
    HAS             shift and go to state 63
    POP             shift and go to state 64
    PUSH            shift and go to state 65
    UNSHIFT         shift and go to state 66


state 38

    (117) return -> RETURN element . SEMICOLON

    SEMICOLON       shift and go to state 67


state 39

    (103) element -> STRING .

    SEMICOLON       reduce using rule 103 (element -> STRING .)
    IGUALIGUAL      reduce using rule 103 (element -> STRING .)
    DIFERENTE       reduce using rule 103 (element -> STRING .)
    MAYORQUE        reduce using rule 103 (element -> STRING .)
    MAYORIGUALQUE   reduce using rule 103 (element -> STRING .)
    MENORQUE        reduce using rule 103 (element -> STRING .)
    MENORIGUALQUE   reduce using rule 103 (element -> STRING .)
    STRING          reduce using rule 103 (element -> STRING .)
    NUMBER          reduce using rule 103 (element -> STRING .)
    NAME            reduce using rule 103 (element -> STRING .)
    CLOSE_PARENTHESIS reduce using rule 103 (element -> STRING .)
    AND             reduce using rule 103 (element -> STRING .)
    OR              reduce using rule 103 (element -> STRING .)


state 40

    (104) element -> NUMBER .

    SEMICOLON       reduce using rule 104 (element -> NUMBER .)
    IGUALIGUAL      reduce using rule 104 (element -> NUMBER .)
    DIFERENTE       reduce using rule 104 (element -> NUMBER .)
    MAYORQUE        reduce using rule 104 (element -> NUMBER .)
    MAYORIGUALQUE   reduce using rule 104 (element -> NUMBER .)
    MENORQUE        reduce using rule 104 (element -> NUMBER .)
    MENORIGUALQUE   reduce using rule 104 (element -> NUMBER .)
    STRING          reduce using rule 104 (element -> NUMBER .)
    NUMBER          reduce using rule 104 (element -> NUMBER .)
    NAME            reduce using rule 104 (element -> NUMBER .)
    CLOSE_PARENTHESIS reduce using rule 104 (element -> NUMBER .)
    AND             reduce using rule 104 (element -> NUMBER .)
    OR              reduce using rule 104 (element -> NUMBER .)


state 41

    (105) element -> NAME .

    SEMICOLON       reduce using rule 105 (element -> NAME .)
    IGUALIGUAL      reduce using rule 105 (element -> NAME .)
    DIFERENTE       reduce using rule 105 (element -> NAME .)
    MAYORQUE        reduce using rule 105 (element -> NAME .)
    MAYORIGUALQUE   reduce using rule 105 (element -> NAME .)
    MENORQUE        reduce using rule 105 (element -> NAME .)
    MENORIGUALQUE   reduce using rule 105 (element -> NAME .)
    STRING          reduce using rule 105 (element -> NAME .)
    NUMBER          reduce using rule 105 (element -> NAME .)
    NAME            reduce using rule 105 (element -> NAME .)
    CLOSE_PARENTHESIS reduce using rule 105 (element -> NAME .)
    AND             reduce using rule 105 (element -> NAME .)
    OR              reduce using rule 105 (element -> NAME .)


state 42

    (113) function -> FUNCTION NAME . OPEN_PARENTHESIS CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (114) function -> FUNCTION NAME . OPEN_PARENTHESIS parameter CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    OPEN_PARENTHESIS shift and go to state 68


state 43

    (22) while -> WHILE OPEN_PARENTHESIS . controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (23) while -> WHILE OPEN_PARENTHESIS . bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (32) controlArg -> . element clause element
    (52) bool -> . TRUE
    (53) bool -> . FALSE
    (103) element -> . STRING
    (104) element -> . NUMBER
    (105) element -> . NAME

    TRUE            shift and go to state 72
    FALSE           shift and go to state 73
    STRING          shift and go to state 39
    NUMBER          shift and go to state 40
    NAME            shift and go to state 41

    controlArg                     shift and go to state 69
    bool                           shift and go to state 70
    element                        shift and go to state 71

state 44

    (33) for -> FOR OPEN_PARENTHESIS . inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (34) inicialization -> . type NAME IGUAL NUMBER
    (35) inicialization -> . NAME IGUAL NUMBER
    (54) type -> . CONST
    (55) type -> . LET
    (56) type -> . VAR

    NAME            shift and go to state 76
    CONST           shift and go to state 21
    LET             shift and go to state 22
    VAR             shift and go to state 23

    inicialization                 shift and go to state 74
    type                           shift and go to state 75

state 45

    (25) if -> soloIf elseIf .
    (26) if -> soloIf elseIf . else
    (31) else -> . ELSE OPEN_BRACE expression CLOSE_BRACE

    NAME            reduce using rule 25 (if -> soloIf elseIf .)
    RETURN          reduce using rule 25 (if -> soloIf elseIf .)
    FUNCTION        reduce using rule 25 (if -> soloIf elseIf .)
    CONST           reduce using rule 25 (if -> soloIf elseIf .)
    LET             reduce using rule 25 (if -> soloIf elseIf .)
    VAR             reduce using rule 25 (if -> soloIf elseIf .)
    WHILE           reduce using rule 25 (if -> soloIf elseIf .)
    FOR             reduce using rule 25 (if -> soloIf elseIf .)
    IF              reduce using rule 25 (if -> soloIf elseIf .)
    $end            reduce using rule 25 (if -> soloIf elseIf .)
    CLOSE_BRACE     reduce using rule 25 (if -> soloIf elseIf .)
    ELSE            shift and go to state 48

    else                           shift and go to state 77

state 46

    (27) if -> soloIf else .

    NAME            reduce using rule 27 (if -> soloIf else .)
    RETURN          reduce using rule 27 (if -> soloIf else .)
    FUNCTION        reduce using rule 27 (if -> soloIf else .)
    CONST           reduce using rule 27 (if -> soloIf else .)
    LET             reduce using rule 27 (if -> soloIf else .)
    VAR             reduce using rule 27 (if -> soloIf else .)
    WHILE           reduce using rule 27 (if -> soloIf else .)
    FOR             reduce using rule 27 (if -> soloIf else .)
    IF              reduce using rule 27 (if -> soloIf else .)
    $end            reduce using rule 27 (if -> soloIf else .)
    CLOSE_BRACE     reduce using rule 27 (if -> soloIf else .)


state 47

    (29) elseIf -> ELSEIF . OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (30) elseIf -> ELSEIF . OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf

    OPEN_PARENTHESIS shift and go to state 78


state 48

    (31) else -> ELSE . OPEN_BRACE expression CLOSE_BRACE

    OPEN_BRACE      shift and go to state 79


state 49

    (28) soloIf -> IF OPEN_PARENTHESIS . controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (32) controlArg -> . element clause element
    (103) element -> . STRING
    (104) element -> . NUMBER
    (105) element -> . NAME

    STRING          shift and go to state 39
    NUMBER          shift and go to state 40
    NAME            shift and go to state 41

    controlArg                     shift and go to state 80
    element                        shift and go to state 71

state 50

    (70) iniciarMap -> variable IGUAL NEW . MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON

    MAP             shift and go to state 81


state 51

    (71) escribirMap -> variable IGUAL OPEN_BRACE . claveValor CLOSE_BRACE
    (77) generarMap -> variable IGUAL OPEN_BRACE . tuplas CLOSE_BRACE
    (72) claveValor -> . clave COLON valor
    (73) claveValor -> . clave COLON valor COMMA claveValor
    (78) tuplas -> . tupla
    (79) tuplas -> . tupla COMMA tuplas
    (74) clave -> . datatype
    (80) tupla -> . OPEN_BRACKET datatype CLOSE_BRACKET SEMICOLON
    (81) tupla -> . OPEN_BRACKET datatype COMMA datatype CLOSE_BRACKET SEMICOLON
    (45) datatype -> . NUMBER
    (46) datatype -> . STRING
    (47) datatype -> . CHAR

    OPEN_BRACKET    shift and go to state 87
    NUMBER          shift and go to state 88
    STRING          shift and go to state 89
    CHAR            shift and go to state 58

    claveValor                     shift and go to state 82
    tuplas                         shift and go to state 83
    clave                          shift and go to state 84
    tupla                          shift and go to state 85
    datatype                       shift and go to state 86

state 52

    (13) variable -> type NAME IGUAL . datatype SEMICOLON
    (14) variable -> type NAME IGUAL . operations SEMICOLON
    (65) array -> type NAME IGUAL . OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (66) array -> type NAME IGUAL . NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (88) set -> type NAME IGUAL . NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (89) set -> type NAME IGUAL . NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (90) set -> type NAME IGUAL . NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (45) datatype -> . NUMBER
    (46) datatype -> . STRING
    (47) datatype -> . CHAR
    (36) operations -> . NUMBER operand NUMBER
    (37) operations -> . NAME
    (38) operations -> . NUMBER
    (39) operations -> . NUMBER operand NAME operations
    (40) operations -> . NAME operand NUMBER operations
    (41) operations -> . NUMBER operand NAME
    (42) operations -> . NAME operand NUMBER
    (43) operations -> . NAME operand NAME operations
    (44) operations -> . NUMBER operand NUMBER operand operations

    OPEN_BRACKET    shift and go to state 93
    NEW             shift and go to state 94
    NUMBER          shift and go to state 95
    STRING          shift and go to state 89
    CHAR            shift and go to state 58
    NAME            shift and go to state 90

    datatype                       shift and go to state 91
    operations                     shift and go to state 92

state 53

    (15) variable -> NAME IGUAL datatype . SEMICOLON

    SEMICOLON       shift and go to state 96


state 54

    (106) declaration -> NAME IGUAL element . SEMICOLON

    SEMICOLON       shift and go to state 97


state 55

    (91) set -> NAME IGUAL NEW . SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (92) set -> NAME IGUAL NEW . SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (93) set -> NAME IGUAL NEW . SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON

    SET             shift and go to state 98


state 56

    (45) datatype -> NUMBER .
    (104) element -> NUMBER .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 45 (datatype -> NUMBER .)
    SEMICOLON       reduce using rule 45 (datatype -> NUMBER .)

  ! SEMICOLON       [ reduce using rule 104 (element -> NUMBER .) ]


state 57

    (46) datatype -> STRING .
    (103) element -> STRING .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 46 (datatype -> STRING .)
    SEMICOLON       reduce using rule 46 (datatype -> STRING .)

  ! SEMICOLON       [ reduce using rule 103 (element -> STRING .) ]


state 58

    (47) datatype -> CHAR .

    SEMICOLON       reduce using rule 47 (datatype -> CHAR .)
    COLON           reduce using rule 47 (datatype -> CHAR .)
    CLOSE_BRACKET   reduce using rule 47 (datatype -> CHAR .)
    COMMA           reduce using rule 47 (datatype -> CHAR .)
    CLOSE_PARENTHESIS reduce using rule 47 (datatype -> CHAR .)
    CLOSE_BRACE     reduce using rule 47 (datatype -> CHAR .)


state 59

    (94) methodsSet -> NAME POINT ADD . OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON

    OPEN_PARENTHESIS shift and go to state 99


state 60

    (95) methodsSet -> NAME POINT DELETE . OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON

    OPEN_PARENTHESIS shift and go to state 100


state 61

    (96) methodsSet -> NAME POINT CLEAR . OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (82) mapFunctions -> NAME POINT CLEAR . OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON

    OPEN_PARENTHESIS shift and go to state 101


state 62

    (83) mapFunctions -> NAME POINT GET . OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON

    OPEN_PARENTHESIS shift and go to state 102


state 63

    (84) mapFunctions -> NAME POINT HAS . OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON

    OPEN_PARENTHESIS shift and go to state 103


state 64

    (85) arrayFn -> NAME POINT POP . OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON

    OPEN_PARENTHESIS shift and go to state 104


state 65

    (86) arrayFn -> NAME POINT PUSH . OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON

    OPEN_PARENTHESIS shift and go to state 105


state 66

    (87) arrayFn -> NAME POINT UNSHIFT . OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON

    OPEN_PARENTHESIS shift and go to state 106


state 67

    (117) return -> RETURN element SEMICOLON .

    $end            reduce using rule 117 (return -> RETURN element SEMICOLON .)
    CLOSE_BRACE     reduce using rule 117 (return -> RETURN element SEMICOLON .)


state 68

    (113) function -> FUNCTION NAME OPEN_PARENTHESIS . CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (114) function -> FUNCTION NAME OPEN_PARENTHESIS . parameter CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (115) parameter -> . element
    (116) parameter -> . element parameter
    (103) element -> . STRING
    (104) element -> . NUMBER
    (105) element -> . NAME

    CLOSE_PARENTHESIS shift and go to state 107
    STRING          shift and go to state 39
    NUMBER          shift and go to state 40
    NAME            shift and go to state 41

    parameter                      shift and go to state 108
    element                        shift and go to state 109

state 69

    (22) while -> WHILE OPEN_PARENTHESIS controlArg . CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    CLOSE_PARENTHESIS shift and go to state 110


state 70

    (23) while -> WHILE OPEN_PARENTHESIS bool . CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    CLOSE_PARENTHESIS shift and go to state 111


state 71

    (32) controlArg -> element . clause element
    (57) clause -> . IGUALIGUAL
    (58) clause -> . DIFERENTE
    (59) clause -> . MAYORQUE
    (60) clause -> . MAYORIGUALQUE
    (61) clause -> . MENORQUE
    (62) clause -> . MENORIGUALQUE

    IGUALIGUAL      shift and go to state 113
    DIFERENTE       shift and go to state 114
    MAYORQUE        shift and go to state 115
    MAYORIGUALQUE   shift and go to state 116
    MENORQUE        shift and go to state 117
    MENORIGUALQUE   shift and go to state 118

    clause                         shift and go to state 112

state 72

    (52) bool -> TRUE .

    CLOSE_PARENTHESIS reduce using rule 52 (bool -> TRUE .)
    SEMICOLON       reduce using rule 52 (bool -> TRUE .)
    AND             reduce using rule 52 (bool -> TRUE .)
    OR              reduce using rule 52 (bool -> TRUE .)


state 73

    (53) bool -> FALSE .

    CLOSE_PARENTHESIS reduce using rule 53 (bool -> FALSE .)
    SEMICOLON       reduce using rule 53 (bool -> FALSE .)
    AND             reduce using rule 53 (bool -> FALSE .)
    OR              reduce using rule 53 (bool -> FALSE .)


state 74

    (33) for -> FOR OPEN_PARENTHESIS inicialization . SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    SEMICOLON       shift and go to state 119


state 75

    (34) inicialization -> type . NAME IGUAL NUMBER

    NAME            shift and go to state 120


state 76

    (35) inicialization -> NAME . IGUAL NUMBER

    IGUAL           shift and go to state 121


state 77

    (26) if -> soloIf elseIf else .

    NAME            reduce using rule 26 (if -> soloIf elseIf else .)
    RETURN          reduce using rule 26 (if -> soloIf elseIf else .)
    FUNCTION        reduce using rule 26 (if -> soloIf elseIf else .)
    CONST           reduce using rule 26 (if -> soloIf elseIf else .)
    LET             reduce using rule 26 (if -> soloIf elseIf else .)
    VAR             reduce using rule 26 (if -> soloIf elseIf else .)
    WHILE           reduce using rule 26 (if -> soloIf elseIf else .)
    FOR             reduce using rule 26 (if -> soloIf elseIf else .)
    IF              reduce using rule 26 (if -> soloIf elseIf else .)
    $end            reduce using rule 26 (if -> soloIf elseIf else .)
    CLOSE_BRACE     reduce using rule 26 (if -> soloIf elseIf else .)


state 78

    (29) elseIf -> ELSEIF OPEN_PARENTHESIS . controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (30) elseIf -> ELSEIF OPEN_PARENTHESIS . controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf
    (32) controlArg -> . element clause element
    (103) element -> . STRING
    (104) element -> . NUMBER
    (105) element -> . NAME

    STRING          shift and go to state 39
    NUMBER          shift and go to state 40
    NAME            shift and go to state 41

    controlArg                     shift and go to state 122
    element                        shift and go to state 71

state 79

    (31) else -> ELSE OPEN_BRACE . expression CLOSE_BRACE
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) expression -> . methodsSet
    (8) expression -> . mapFunctions
    (9) expression -> . arrayFn
    (10) expression -> . declaration
    (11) expression -> . return
    (12) expression -> . function
    (13) variable -> . type NAME IGUAL datatype SEMICOLON
    (14) variable -> . type NAME IGUAL operations SEMICOLON
    (15) variable -> . NAME IGUAL datatype SEMICOLON
    (19) dataStruct -> . array
    (20) dataStruct -> . set
    (21) dataStruct -> . map
    (16) controlStruct -> . while
    (17) controlStruct -> . for
    (18) controlStruct -> . if
    (94) methodsSet -> . NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (95) methodsSet -> . NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (96) methodsSet -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (82) mapFunctions -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (83) mapFunctions -> . NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (84) mapFunctions -> . NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (85) arrayFn -> . NAME POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (86) arrayFn -> . NAME POINT PUSH OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (87) arrayFn -> . NAME POINT UNSHIFT OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (106) declaration -> . NAME IGUAL element SEMICOLON
    (117) return -> . RETURN element SEMICOLON
    (113) function -> . FUNCTION NAME OPEN_PARENTHESIS CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (114) function -> . FUNCTION NAME OPEN_PARENTHESIS parameter CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (54) type -> . CONST
    (55) type -> . LET
    (56) type -> . VAR
    (65) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (66) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (88) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (89) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (90) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (91) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (92) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (93) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (67) map -> . iniciarMap
    (68) map -> . escribirMap
    (69) map -> . generarMap
    (22) while -> . WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (23) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (33) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (24) if -> . soloIf
    (25) if -> . soloIf elseIf
    (26) if -> . soloIf elseIf else
    (27) if -> . soloIf else
    (70) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (71) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (77) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (28) soloIf -> . IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    NAME            shift and go to state 12
    RETURN          shift and go to state 19
    FUNCTION        shift and go to state 20
    CONST           shift and go to state 21
    LET             shift and go to state 22
    VAR             shift and go to state 23
    WHILE           shift and go to state 27
    FOR             shift and go to state 28
    IF              shift and go to state 30

    expression                     shift and go to state 123
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    methodsSet                     shift and go to state 5
    mapFunctions                   shift and go to state 6
    arrayFn                        shift and go to state 7
    declaration                    shift and go to state 8
    return                         shift and go to state 9
    function                       shift and go to state 10
    type                           shift and go to state 11
    array                          shift and go to state 13
    set                            shift and go to state 14
    map                            shift and go to state 15
    while                          shift and go to state 16
    for                            shift and go to state 17
    if                             shift and go to state 18
    iniciarMap                     shift and go to state 24
    escribirMap                    shift and go to state 25
    generarMap                     shift and go to state 26
    soloIf                         shift and go to state 29

state 80

    (28) soloIf -> IF OPEN_PARENTHESIS controlArg . CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    CLOSE_PARENTHESIS shift and go to state 124


state 81

    (70) iniciarMap -> variable IGUAL NEW MAP . OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON

    OPEN_PARENTHESIS shift and go to state 125


state 82

    (71) escribirMap -> variable IGUAL OPEN_BRACE claveValor . CLOSE_BRACE

    CLOSE_BRACE     shift and go to state 126


state 83

    (77) generarMap -> variable IGUAL OPEN_BRACE tuplas . CLOSE_BRACE

    CLOSE_BRACE     shift and go to state 127


state 84

    (72) claveValor -> clave . COLON valor
    (73) claveValor -> clave . COLON valor COMMA claveValor

    COLON           shift and go to state 128


state 85

    (78) tuplas -> tupla .
    (79) tuplas -> tupla . COMMA tuplas

    CLOSE_BRACE     reduce using rule 78 (tuplas -> tupla .)
    COMMA           shift and go to state 129


state 86

    (74) clave -> datatype .

    COLON           reduce using rule 74 (clave -> datatype .)
    CLOSE_PARENTHESIS reduce using rule 74 (clave -> datatype .)


state 87

    (80) tupla -> OPEN_BRACKET . datatype CLOSE_BRACKET SEMICOLON
    (81) tupla -> OPEN_BRACKET . datatype COMMA datatype CLOSE_BRACKET SEMICOLON
    (45) datatype -> . NUMBER
    (46) datatype -> . STRING
    (47) datatype -> . CHAR

    NUMBER          shift and go to state 88
    STRING          shift and go to state 89
    CHAR            shift and go to state 58

    datatype                       shift and go to state 130

state 88

    (45) datatype -> NUMBER .

    COLON           reduce using rule 45 (datatype -> NUMBER .)
    CLOSE_BRACKET   reduce using rule 45 (datatype -> NUMBER .)
    COMMA           reduce using rule 45 (datatype -> NUMBER .)
    CLOSE_PARENTHESIS reduce using rule 45 (datatype -> NUMBER .)
    CLOSE_BRACE     reduce using rule 45 (datatype -> NUMBER .)
    SEMICOLON       reduce using rule 45 (datatype -> NUMBER .)


state 89

    (46) datatype -> STRING .

    COLON           reduce using rule 46 (datatype -> STRING .)
    SEMICOLON       reduce using rule 46 (datatype -> STRING .)
    CLOSE_BRACKET   reduce using rule 46 (datatype -> STRING .)
    COMMA           reduce using rule 46 (datatype -> STRING .)
    CLOSE_PARENTHESIS reduce using rule 46 (datatype -> STRING .)
    CLOSE_BRACE     reduce using rule 46 (datatype -> STRING .)


state 90

    (37) operations -> NAME .
    (40) operations -> NAME . operand NUMBER operations
    (42) operations -> NAME . operand NUMBER
    (43) operations -> NAME . operand NAME operations
    (48) operand -> . SUMA
    (49) operand -> . RESTA
    (50) operand -> . MULTIPLICACION
    (51) operand -> . DIVISION

    SEMICOLON       reduce using rule 37 (operations -> NAME .)
    CLOSE_PARENTHESIS reduce using rule 37 (operations -> NAME .)
    SUMA            shift and go to state 132
    RESTA           shift and go to state 133
    MULTIPLICACION  shift and go to state 134
    DIVISION        shift and go to state 135

    operand                        shift and go to state 131

state 91

    (13) variable -> type NAME IGUAL datatype . SEMICOLON

    SEMICOLON       shift and go to state 136


state 92

    (14) variable -> type NAME IGUAL operations . SEMICOLON

    SEMICOLON       shift and go to state 137


state 93

    (65) array -> type NAME IGUAL OPEN_BRACKET . items CLOSE_BRACKET SEMICOLON
    (97) items -> . numeros
    (98) items -> . cadena
    (99) numeros -> . NUMBER
    (100) numeros -> . NUMBER COMMA numeros
    (101) cadena -> . STRING
    (102) cadena -> . STRING COMMA cadena

    NUMBER          shift and go to state 141
    STRING          shift and go to state 142

    items                          shift and go to state 138
    numeros                        shift and go to state 139
    cadena                         shift and go to state 140

state 94

    (66) array -> type NAME IGUAL NEW . ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (88) set -> type NAME IGUAL NEW . SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (89) set -> type NAME IGUAL NEW . SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (90) set -> type NAME IGUAL NEW . SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON

    ARRAY           shift and go to state 143
    SET             shift and go to state 144


state 95

    (45) datatype -> NUMBER .
    (36) operations -> NUMBER . operand NUMBER
    (38) operations -> NUMBER .
    (39) operations -> NUMBER . operand NAME operations
    (41) operations -> NUMBER . operand NAME
    (44) operations -> NUMBER . operand NUMBER operand operations
    (48) operand -> . SUMA
    (49) operand -> . RESTA
    (50) operand -> . MULTIPLICACION
    (51) operand -> . DIVISION

  ! reduce/reduce conflict for SEMICOLON resolved using rule 38 (operations -> NUMBER .)
    SEMICOLON       reduce using rule 38 (operations -> NUMBER .)
    SUMA            shift and go to state 132
    RESTA           shift and go to state 133
    MULTIPLICACION  shift and go to state 134
    DIVISION        shift and go to state 135

  ! SEMICOLON       [ reduce using rule 45 (datatype -> NUMBER .) ]

    operand                        shift and go to state 145

state 96

    (15) variable -> NAME IGUAL datatype SEMICOLON .

    IGUAL           reduce using rule 15 (variable -> NAME IGUAL datatype SEMICOLON .)
    NAME            reduce using rule 15 (variable -> NAME IGUAL datatype SEMICOLON .)
    RETURN          reduce using rule 15 (variable -> NAME IGUAL datatype SEMICOLON .)
    FUNCTION        reduce using rule 15 (variable -> NAME IGUAL datatype SEMICOLON .)
    CONST           reduce using rule 15 (variable -> NAME IGUAL datatype SEMICOLON .)
    LET             reduce using rule 15 (variable -> NAME IGUAL datatype SEMICOLON .)
    VAR             reduce using rule 15 (variable -> NAME IGUAL datatype SEMICOLON .)
    WHILE           reduce using rule 15 (variable -> NAME IGUAL datatype SEMICOLON .)
    FOR             reduce using rule 15 (variable -> NAME IGUAL datatype SEMICOLON .)
    IF              reduce using rule 15 (variable -> NAME IGUAL datatype SEMICOLON .)
    $end            reduce using rule 15 (variable -> NAME IGUAL datatype SEMICOLON .)
    CLOSE_BRACE     reduce using rule 15 (variable -> NAME IGUAL datatype SEMICOLON .)


state 97

    (106) declaration -> NAME IGUAL element SEMICOLON .

    $end            reduce using rule 106 (declaration -> NAME IGUAL element SEMICOLON .)
    CLOSE_BRACE     reduce using rule 106 (declaration -> NAME IGUAL element SEMICOLON .)


state 98

    (91) set -> NAME IGUAL NEW SET . OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (92) set -> NAME IGUAL NEW SET . OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (93) set -> NAME IGUAL NEW SET . OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON

    OPEN_PARENTHESIS shift and go to state 146


state 99

    (94) methodsSet -> NAME POINT ADD OPEN_PARENTHESIS . element CLOSE_PARENTHESIS SEMICOLON
    (103) element -> . STRING
    (104) element -> . NUMBER
    (105) element -> . NAME

    STRING          shift and go to state 39
    NUMBER          shift and go to state 40
    NAME            shift and go to state 41

    element                        shift and go to state 147

state 100

    (95) methodsSet -> NAME POINT DELETE OPEN_PARENTHESIS . element CLOSE_PARENTHESIS SEMICOLON
    (103) element -> . STRING
    (104) element -> . NUMBER
    (105) element -> . NAME

    STRING          shift and go to state 39
    NUMBER          shift and go to state 40
    NAME            shift and go to state 41

    element                        shift and go to state 148

state 101

    (96) methodsSet -> NAME POINT CLEAR OPEN_PARENTHESIS . CLOSE_PARENTHESIS SEMICOLON
    (82) mapFunctions -> NAME POINT CLEAR OPEN_PARENTHESIS . CLOSE_PARENTHESIS SEMICOLON

    CLOSE_PARENTHESIS shift and go to state 149


state 102

    (83) mapFunctions -> NAME POINT GET OPEN_PARENTHESIS . clave CLOSE_PARENTHESIS SEMICOLON
    (74) clave -> . datatype
    (45) datatype -> . NUMBER
    (46) datatype -> . STRING
    (47) datatype -> . CHAR

    NUMBER          shift and go to state 88
    STRING          shift and go to state 89
    CHAR            shift and go to state 58

    clave                          shift and go to state 150
    datatype                       shift and go to state 86

state 103

    (84) mapFunctions -> NAME POINT HAS OPEN_PARENTHESIS . clave CLOSE_PARENTHESIS SEMICOLON
    (74) clave -> . datatype
    (45) datatype -> . NUMBER
    (46) datatype -> . STRING
    (47) datatype -> . CHAR

    NUMBER          shift and go to state 88
    STRING          shift and go to state 89
    CHAR            shift and go to state 58

    clave                          shift and go to state 151
    datatype                       shift and go to state 86

state 104

    (85) arrayFn -> NAME POINT POP OPEN_PARENTHESIS . CLOSE_PARENTHESIS SEMICOLON

    CLOSE_PARENTHESIS shift and go to state 152


state 105

    (86) arrayFn -> NAME POINT PUSH OPEN_PARENTHESIS . element CLOSE_PARENTHESIS SEMICOLON
    (103) element -> . STRING
    (104) element -> . NUMBER
    (105) element -> . NAME

    STRING          shift and go to state 39
    NUMBER          shift and go to state 40
    NAME            shift and go to state 41

    element                        shift and go to state 153

state 106

    (87) arrayFn -> NAME POINT UNSHIFT OPEN_PARENTHESIS . element CLOSE_PARENTHESIS SEMICOLON
    (103) element -> . STRING
    (104) element -> . NUMBER
    (105) element -> . NAME

    STRING          shift and go to state 39
    NUMBER          shift and go to state 40
    NAME            shift and go to state 41

    element                        shift and go to state 154

state 107

    (113) function -> FUNCTION NAME OPEN_PARENTHESIS CLOSE_PARENTHESIS . OPEN_BRACE expression CLOSE_BRACE

    OPEN_BRACE      shift and go to state 155


state 108

    (114) function -> FUNCTION NAME OPEN_PARENTHESIS parameter . CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    CLOSE_PARENTHESIS shift and go to state 156


state 109

    (115) parameter -> element .
    (116) parameter -> element . parameter
    (115) parameter -> . element
    (116) parameter -> . element parameter
    (103) element -> . STRING
    (104) element -> . NUMBER
    (105) element -> . NAME

    CLOSE_PARENTHESIS reduce using rule 115 (parameter -> element .)
    STRING          shift and go to state 39
    NUMBER          shift and go to state 40
    NAME            shift and go to state 41

    element                        shift and go to state 109
    parameter                      shift and go to state 157

state 110

    (22) while -> WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS . OPEN_BRACE expression CLOSE_BRACE

    OPEN_BRACE      shift and go to state 158


state 111

    (23) while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS . OPEN_BRACE expression CLOSE_BRACE

    OPEN_BRACE      shift and go to state 159


state 112

    (32) controlArg -> element clause . element
    (103) element -> . STRING
    (104) element -> . NUMBER
    (105) element -> . NAME

    STRING          shift and go to state 39
    NUMBER          shift and go to state 40
    NAME            shift and go to state 41

    element                        shift and go to state 160

state 113

    (57) clause -> IGUALIGUAL .

    STRING          reduce using rule 57 (clause -> IGUALIGUAL .)
    NUMBER          reduce using rule 57 (clause -> IGUALIGUAL .)
    NAME            reduce using rule 57 (clause -> IGUALIGUAL .)


state 114

    (58) clause -> DIFERENTE .

    STRING          reduce using rule 58 (clause -> DIFERENTE .)
    NUMBER          reduce using rule 58 (clause -> DIFERENTE .)
    NAME            reduce using rule 58 (clause -> DIFERENTE .)


state 115

    (59) clause -> MAYORQUE .

    STRING          reduce using rule 59 (clause -> MAYORQUE .)
    NUMBER          reduce using rule 59 (clause -> MAYORQUE .)
    NAME            reduce using rule 59 (clause -> MAYORQUE .)


state 116

    (60) clause -> MAYORIGUALQUE .

    STRING          reduce using rule 60 (clause -> MAYORIGUALQUE .)
    NUMBER          reduce using rule 60 (clause -> MAYORIGUALQUE .)
    NAME            reduce using rule 60 (clause -> MAYORIGUALQUE .)


state 117

    (61) clause -> MENORQUE .

    STRING          reduce using rule 61 (clause -> MENORQUE .)
    NUMBER          reduce using rule 61 (clause -> MENORQUE .)
    NAME            reduce using rule 61 (clause -> MENORQUE .)


state 118

    (62) clause -> MENORIGUALQUE .

    STRING          reduce using rule 62 (clause -> MENORIGUALQUE .)
    NUMBER          reduce using rule 62 (clause -> MENORIGUALQUE .)
    NAME            reduce using rule 62 (clause -> MENORIGUALQUE .)


state 119

    (33) for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON . expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (109) expBoolean -> . controlArg
    (110) expBoolean -> . bool
    (111) expBoolean -> . NOT expBoolean
    (112) expBoolean -> . expBoolean logicalOperator expBoolean
    (32) controlArg -> . element clause element
    (52) bool -> . TRUE
    (53) bool -> . FALSE
    (103) element -> . STRING
    (104) element -> . NUMBER
    (105) element -> . NAME

    NOT             shift and go to state 164
    TRUE            shift and go to state 72
    FALSE           shift and go to state 73
    STRING          shift and go to state 39
    NUMBER          shift and go to state 40
    NAME            shift and go to state 41

    expBoolean                     shift and go to state 161
    controlArg                     shift and go to state 162
    bool                           shift and go to state 163
    element                        shift and go to state 71

state 120

    (34) inicialization -> type NAME . IGUAL NUMBER

    IGUAL           shift and go to state 165


state 121

    (35) inicialization -> NAME IGUAL . NUMBER

    NUMBER          shift and go to state 166


state 122

    (29) elseIf -> ELSEIF OPEN_PARENTHESIS controlArg . CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (30) elseIf -> ELSEIF OPEN_PARENTHESIS controlArg . CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf

    CLOSE_PARENTHESIS shift and go to state 167


state 123

    (31) else -> ELSE OPEN_BRACE expression . CLOSE_BRACE

    CLOSE_BRACE     shift and go to state 168


state 124

    (28) soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS . OPEN_BRACE expression CLOSE_BRACE

    OPEN_BRACE      shift and go to state 169


state 125

    (70) iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS . CLOSE_PARENTHESIS SEMICOLON

    CLOSE_PARENTHESIS shift and go to state 170


state 126

    (71) escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .

    NAME            reduce using rule 71 (escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .)
    RETURN          reduce using rule 71 (escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .)
    FUNCTION        reduce using rule 71 (escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .)
    CONST           reduce using rule 71 (escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .)
    LET             reduce using rule 71 (escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .)
    VAR             reduce using rule 71 (escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .)
    WHILE           reduce using rule 71 (escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .)
    FOR             reduce using rule 71 (escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .)
    IF              reduce using rule 71 (escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .)
    $end            reduce using rule 71 (escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 71 (escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .)
    COMMA           reduce using rule 71 (escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .)


state 127

    (77) generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .

    NAME            reduce using rule 77 (generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .)
    RETURN          reduce using rule 77 (generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .)
    FUNCTION        reduce using rule 77 (generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .)
    CONST           reduce using rule 77 (generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .)
    LET             reduce using rule 77 (generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .)
    VAR             reduce using rule 77 (generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .)
    WHILE           reduce using rule 77 (generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .)
    FOR             reduce using rule 77 (generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .)
    IF              reduce using rule 77 (generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .)
    $end            reduce using rule 77 (generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 77 (generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .)
    COMMA           reduce using rule 77 (generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .)


state 128

    (72) claveValor -> clave COLON . valor
    (73) claveValor -> clave COLON . valor COMMA claveValor
    (75) valor -> . datatype
    (76) valor -> . dataStruct
    (45) datatype -> . NUMBER
    (46) datatype -> . STRING
    (47) datatype -> . CHAR
    (19) dataStruct -> . array
    (20) dataStruct -> . set
    (21) dataStruct -> . map
    (65) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (66) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (88) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (89) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (90) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (91) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (92) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (93) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (67) map -> . iniciarMap
    (68) map -> . escribirMap
    (69) map -> . generarMap
    (54) type -> . CONST
    (55) type -> . LET
    (56) type -> . VAR
    (70) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (71) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (77) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (13) variable -> . type NAME IGUAL datatype SEMICOLON
    (14) variable -> . type NAME IGUAL operations SEMICOLON
    (15) variable -> . NAME IGUAL datatype SEMICOLON

    NUMBER          shift and go to state 88
    STRING          shift and go to state 89
    CHAR            shift and go to state 58
    NAME            shift and go to state 175
    CONST           shift and go to state 21
    LET             shift and go to state 22
    VAR             shift and go to state 23

    valor                          shift and go to state 171
    datatype                       shift and go to state 172
    dataStruct                     shift and go to state 173
    array                          shift and go to state 13
    set                            shift and go to state 14
    map                            shift and go to state 15
    type                           shift and go to state 174
    iniciarMap                     shift and go to state 24
    escribirMap                    shift and go to state 25
    generarMap                     shift and go to state 26
    variable                       shift and go to state 176

state 129

    (79) tuplas -> tupla COMMA . tuplas
    (78) tuplas -> . tupla
    (79) tuplas -> . tupla COMMA tuplas
    (80) tupla -> . OPEN_BRACKET datatype CLOSE_BRACKET SEMICOLON
    (81) tupla -> . OPEN_BRACKET datatype COMMA datatype CLOSE_BRACKET SEMICOLON

    OPEN_BRACKET    shift and go to state 87

    tupla                          shift and go to state 85
    tuplas                         shift and go to state 177

state 130

    (80) tupla -> OPEN_BRACKET datatype . CLOSE_BRACKET SEMICOLON
    (81) tupla -> OPEN_BRACKET datatype . COMMA datatype CLOSE_BRACKET SEMICOLON

    CLOSE_BRACKET   shift and go to state 178
    COMMA           shift and go to state 179


state 131

    (40) operations -> NAME operand . NUMBER operations
    (42) operations -> NAME operand . NUMBER
    (43) operations -> NAME operand . NAME operations

    NUMBER          shift and go to state 181
    NAME            shift and go to state 180


state 132

    (48) operand -> SUMA .

    NUMBER          reduce using rule 48 (operand -> SUMA .)
    NAME            reduce using rule 48 (operand -> SUMA .)


state 133

    (49) operand -> RESTA .

    NUMBER          reduce using rule 49 (operand -> RESTA .)
    NAME            reduce using rule 49 (operand -> RESTA .)


state 134

    (50) operand -> MULTIPLICACION .

    NUMBER          reduce using rule 50 (operand -> MULTIPLICACION .)
    NAME            reduce using rule 50 (operand -> MULTIPLICACION .)


state 135

    (51) operand -> DIVISION .

    NUMBER          reduce using rule 51 (operand -> DIVISION .)
    NAME            reduce using rule 51 (operand -> DIVISION .)


state 136

    (13) variable -> type NAME IGUAL datatype SEMICOLON .

    IGUAL           reduce using rule 13 (variable -> type NAME IGUAL datatype SEMICOLON .)
    NAME            reduce using rule 13 (variable -> type NAME IGUAL datatype SEMICOLON .)
    RETURN          reduce using rule 13 (variable -> type NAME IGUAL datatype SEMICOLON .)
    FUNCTION        reduce using rule 13 (variable -> type NAME IGUAL datatype SEMICOLON .)
    CONST           reduce using rule 13 (variable -> type NAME IGUAL datatype SEMICOLON .)
    LET             reduce using rule 13 (variable -> type NAME IGUAL datatype SEMICOLON .)
    VAR             reduce using rule 13 (variable -> type NAME IGUAL datatype SEMICOLON .)
    WHILE           reduce using rule 13 (variable -> type NAME IGUAL datatype SEMICOLON .)
    FOR             reduce using rule 13 (variable -> type NAME IGUAL datatype SEMICOLON .)
    IF              reduce using rule 13 (variable -> type NAME IGUAL datatype SEMICOLON .)
    $end            reduce using rule 13 (variable -> type NAME IGUAL datatype SEMICOLON .)
    CLOSE_BRACE     reduce using rule 13 (variable -> type NAME IGUAL datatype SEMICOLON .)


state 137

    (14) variable -> type NAME IGUAL operations SEMICOLON .

    IGUAL           reduce using rule 14 (variable -> type NAME IGUAL operations SEMICOLON .)
    NAME            reduce using rule 14 (variable -> type NAME IGUAL operations SEMICOLON .)
    RETURN          reduce using rule 14 (variable -> type NAME IGUAL operations SEMICOLON .)
    FUNCTION        reduce using rule 14 (variable -> type NAME IGUAL operations SEMICOLON .)
    CONST           reduce using rule 14 (variable -> type NAME IGUAL operations SEMICOLON .)
    LET             reduce using rule 14 (variable -> type NAME IGUAL operations SEMICOLON .)
    VAR             reduce using rule 14 (variable -> type NAME IGUAL operations SEMICOLON .)
    WHILE           reduce using rule 14 (variable -> type NAME IGUAL operations SEMICOLON .)
    FOR             reduce using rule 14 (variable -> type NAME IGUAL operations SEMICOLON .)
    IF              reduce using rule 14 (variable -> type NAME IGUAL operations SEMICOLON .)
    $end            reduce using rule 14 (variable -> type NAME IGUAL operations SEMICOLON .)
    CLOSE_BRACE     reduce using rule 14 (variable -> type NAME IGUAL operations SEMICOLON .)


state 138

    (65) array -> type NAME IGUAL OPEN_BRACKET items . CLOSE_BRACKET SEMICOLON

    CLOSE_BRACKET   shift and go to state 182


state 139

    (97) items -> numeros .

    CLOSE_BRACKET   reduce using rule 97 (items -> numeros .)
    CLOSE_PARENTHESIS reduce using rule 97 (items -> numeros .)


state 140

    (98) items -> cadena .

    CLOSE_BRACKET   reduce using rule 98 (items -> cadena .)
    CLOSE_PARENTHESIS reduce using rule 98 (items -> cadena .)


state 141

    (99) numeros -> NUMBER .
    (100) numeros -> NUMBER . COMMA numeros

    CLOSE_BRACKET   reduce using rule 99 (numeros -> NUMBER .)
    CLOSE_PARENTHESIS reduce using rule 99 (numeros -> NUMBER .)
    COMMA           shift and go to state 183


state 142

    (101) cadena -> STRING .
    (102) cadena -> STRING . COMMA cadena

    CLOSE_BRACKET   reduce using rule 101 (cadena -> STRING .)
    CLOSE_PARENTHESIS reduce using rule 101 (cadena -> STRING .)
    COMMA           shift and go to state 184


state 143

    (66) array -> type NAME IGUAL NEW ARRAY . OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON

    OPEN_PARENTHESIS shift and go to state 185


state 144

    (88) set -> type NAME IGUAL NEW SET . OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (89) set -> type NAME IGUAL NEW SET . OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (90) set -> type NAME IGUAL NEW SET . OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON

    OPEN_PARENTHESIS shift and go to state 186


state 145

    (36) operations -> NUMBER operand . NUMBER
    (39) operations -> NUMBER operand . NAME operations
    (41) operations -> NUMBER operand . NAME
    (44) operations -> NUMBER operand . NUMBER operand operations

    NUMBER          shift and go to state 187
    NAME            shift and go to state 188


state 146

    (91) set -> NAME IGUAL NEW SET OPEN_PARENTHESIS . CLOSE_PARENTHESIS SEMICOLON
    (92) set -> NAME IGUAL NEW SET OPEN_PARENTHESIS . OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (93) set -> NAME IGUAL NEW SET OPEN_PARENTHESIS . element CLOSE_PARENTHESIS SEMICOLON
    (103) element -> . STRING
    (104) element -> . NUMBER
    (105) element -> . NAME

    CLOSE_PARENTHESIS shift and go to state 189
    OPEN_BRACKET    shift and go to state 190
    STRING          shift and go to state 39
    NUMBER          shift and go to state 40
    NAME            shift and go to state 41

    element                        shift and go to state 191

state 147

    (94) methodsSet -> NAME POINT ADD OPEN_PARENTHESIS element . CLOSE_PARENTHESIS SEMICOLON

    CLOSE_PARENTHESIS shift and go to state 192


state 148

    (95) methodsSet -> NAME POINT DELETE OPEN_PARENTHESIS element . CLOSE_PARENTHESIS SEMICOLON

    CLOSE_PARENTHESIS shift and go to state 193


state 149

    (96) methodsSet -> NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS . SEMICOLON
    (82) mapFunctions -> NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 194


state 150

    (83) mapFunctions -> NAME POINT GET OPEN_PARENTHESIS clave . CLOSE_PARENTHESIS SEMICOLON

    CLOSE_PARENTHESIS shift and go to state 195


state 151

    (84) mapFunctions -> NAME POINT HAS OPEN_PARENTHESIS clave . CLOSE_PARENTHESIS SEMICOLON

    CLOSE_PARENTHESIS shift and go to state 196


state 152

    (85) arrayFn -> NAME POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 197


state 153

    (86) arrayFn -> NAME POINT PUSH OPEN_PARENTHESIS element . CLOSE_PARENTHESIS SEMICOLON

    CLOSE_PARENTHESIS shift and go to state 198


state 154

    (87) arrayFn -> NAME POINT UNSHIFT OPEN_PARENTHESIS element . CLOSE_PARENTHESIS SEMICOLON

    CLOSE_PARENTHESIS shift and go to state 199


state 155

    (113) function -> FUNCTION NAME OPEN_PARENTHESIS CLOSE_PARENTHESIS OPEN_BRACE . expression CLOSE_BRACE
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) expression -> . methodsSet
    (8) expression -> . mapFunctions
    (9) expression -> . arrayFn
    (10) expression -> . declaration
    (11) expression -> . return
    (12) expression -> . function
    (13) variable -> . type NAME IGUAL datatype SEMICOLON
    (14) variable -> . type NAME IGUAL operations SEMICOLON
    (15) variable -> . NAME IGUAL datatype SEMICOLON
    (19) dataStruct -> . array
    (20) dataStruct -> . set
    (21) dataStruct -> . map
    (16) controlStruct -> . while
    (17) controlStruct -> . for
    (18) controlStruct -> . if
    (94) methodsSet -> . NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (95) methodsSet -> . NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (96) methodsSet -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (82) mapFunctions -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (83) mapFunctions -> . NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (84) mapFunctions -> . NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (85) arrayFn -> . NAME POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (86) arrayFn -> . NAME POINT PUSH OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (87) arrayFn -> . NAME POINT UNSHIFT OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (106) declaration -> . NAME IGUAL element SEMICOLON
    (117) return -> . RETURN element SEMICOLON
    (113) function -> . FUNCTION NAME OPEN_PARENTHESIS CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (114) function -> . FUNCTION NAME OPEN_PARENTHESIS parameter CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (54) type -> . CONST
    (55) type -> . LET
    (56) type -> . VAR
    (65) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (66) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (88) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (89) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (90) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (91) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (92) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (93) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (67) map -> . iniciarMap
    (68) map -> . escribirMap
    (69) map -> . generarMap
    (22) while -> . WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (23) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (33) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (24) if -> . soloIf
    (25) if -> . soloIf elseIf
    (26) if -> . soloIf elseIf else
    (27) if -> . soloIf else
    (70) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (71) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (77) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (28) soloIf -> . IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    NAME            shift and go to state 12
    RETURN          shift and go to state 19
    FUNCTION        shift and go to state 20
    CONST           shift and go to state 21
    LET             shift and go to state 22
    VAR             shift and go to state 23
    WHILE           shift and go to state 27
    FOR             shift and go to state 28
    IF              shift and go to state 30

    expression                     shift and go to state 200
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    methodsSet                     shift and go to state 5
    mapFunctions                   shift and go to state 6
    arrayFn                        shift and go to state 7
    declaration                    shift and go to state 8
    return                         shift and go to state 9
    function                       shift and go to state 10
    type                           shift and go to state 11
    array                          shift and go to state 13
    set                            shift and go to state 14
    map                            shift and go to state 15
    while                          shift and go to state 16
    for                            shift and go to state 17
    if                             shift and go to state 18
    iniciarMap                     shift and go to state 24
    escribirMap                    shift and go to state 25
    generarMap                     shift and go to state 26
    soloIf                         shift and go to state 29

state 156

    (114) function -> FUNCTION NAME OPEN_PARENTHESIS parameter CLOSE_PARENTHESIS . OPEN_BRACE expression CLOSE_BRACE

    OPEN_BRACE      shift and go to state 201


state 157

    (116) parameter -> element parameter .

    CLOSE_PARENTHESIS reduce using rule 116 (parameter -> element parameter .)


state 158

    (22) while -> WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE . expression CLOSE_BRACE
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) expression -> . methodsSet
    (8) expression -> . mapFunctions
    (9) expression -> . arrayFn
    (10) expression -> . declaration
    (11) expression -> . return
    (12) expression -> . function
    (13) variable -> . type NAME IGUAL datatype SEMICOLON
    (14) variable -> . type NAME IGUAL operations SEMICOLON
    (15) variable -> . NAME IGUAL datatype SEMICOLON
    (19) dataStruct -> . array
    (20) dataStruct -> . set
    (21) dataStruct -> . map
    (16) controlStruct -> . while
    (17) controlStruct -> . for
    (18) controlStruct -> . if
    (94) methodsSet -> . NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (95) methodsSet -> . NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (96) methodsSet -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (82) mapFunctions -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (83) mapFunctions -> . NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (84) mapFunctions -> . NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (85) arrayFn -> . NAME POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (86) arrayFn -> . NAME POINT PUSH OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (87) arrayFn -> . NAME POINT UNSHIFT OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (106) declaration -> . NAME IGUAL element SEMICOLON
    (117) return -> . RETURN element SEMICOLON
    (113) function -> . FUNCTION NAME OPEN_PARENTHESIS CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (114) function -> . FUNCTION NAME OPEN_PARENTHESIS parameter CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (54) type -> . CONST
    (55) type -> . LET
    (56) type -> . VAR
    (65) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (66) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (88) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (89) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (90) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (91) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (92) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (93) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (67) map -> . iniciarMap
    (68) map -> . escribirMap
    (69) map -> . generarMap
    (22) while -> . WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (23) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (33) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (24) if -> . soloIf
    (25) if -> . soloIf elseIf
    (26) if -> . soloIf elseIf else
    (27) if -> . soloIf else
    (70) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (71) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (77) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (28) soloIf -> . IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    NAME            shift and go to state 12
    RETURN          shift and go to state 19
    FUNCTION        shift and go to state 20
    CONST           shift and go to state 21
    LET             shift and go to state 22
    VAR             shift and go to state 23
    WHILE           shift and go to state 27
    FOR             shift and go to state 28
    IF              shift and go to state 30

    expression                     shift and go to state 202
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    methodsSet                     shift and go to state 5
    mapFunctions                   shift and go to state 6
    arrayFn                        shift and go to state 7
    declaration                    shift and go to state 8
    return                         shift and go to state 9
    function                       shift and go to state 10
    type                           shift and go to state 11
    array                          shift and go to state 13
    set                            shift and go to state 14
    map                            shift and go to state 15
    while                          shift and go to state 16
    for                            shift and go to state 17
    if                             shift and go to state 18
    iniciarMap                     shift and go to state 24
    escribirMap                    shift and go to state 25
    generarMap                     shift and go to state 26
    soloIf                         shift and go to state 29

state 159

    (23) while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE . expression CLOSE_BRACE
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) expression -> . methodsSet
    (8) expression -> . mapFunctions
    (9) expression -> . arrayFn
    (10) expression -> . declaration
    (11) expression -> . return
    (12) expression -> . function
    (13) variable -> . type NAME IGUAL datatype SEMICOLON
    (14) variable -> . type NAME IGUAL operations SEMICOLON
    (15) variable -> . NAME IGUAL datatype SEMICOLON
    (19) dataStruct -> . array
    (20) dataStruct -> . set
    (21) dataStruct -> . map
    (16) controlStruct -> . while
    (17) controlStruct -> . for
    (18) controlStruct -> . if
    (94) methodsSet -> . NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (95) methodsSet -> . NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (96) methodsSet -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (82) mapFunctions -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (83) mapFunctions -> . NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (84) mapFunctions -> . NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (85) arrayFn -> . NAME POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (86) arrayFn -> . NAME POINT PUSH OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (87) arrayFn -> . NAME POINT UNSHIFT OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (106) declaration -> . NAME IGUAL element SEMICOLON
    (117) return -> . RETURN element SEMICOLON
    (113) function -> . FUNCTION NAME OPEN_PARENTHESIS CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (114) function -> . FUNCTION NAME OPEN_PARENTHESIS parameter CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (54) type -> . CONST
    (55) type -> . LET
    (56) type -> . VAR
    (65) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (66) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (88) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (89) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (90) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (91) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (92) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (93) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (67) map -> . iniciarMap
    (68) map -> . escribirMap
    (69) map -> . generarMap
    (22) while -> . WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (23) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (33) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (24) if -> . soloIf
    (25) if -> . soloIf elseIf
    (26) if -> . soloIf elseIf else
    (27) if -> . soloIf else
    (70) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (71) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (77) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (28) soloIf -> . IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    NAME            shift and go to state 12
    RETURN          shift and go to state 19
    FUNCTION        shift and go to state 20
    CONST           shift and go to state 21
    LET             shift and go to state 22
    VAR             shift and go to state 23
    WHILE           shift and go to state 27
    FOR             shift and go to state 28
    IF              shift and go to state 30

    expression                     shift and go to state 203
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    methodsSet                     shift and go to state 5
    mapFunctions                   shift and go to state 6
    arrayFn                        shift and go to state 7
    declaration                    shift and go to state 8
    return                         shift and go to state 9
    function                       shift and go to state 10
    type                           shift and go to state 11
    array                          shift and go to state 13
    set                            shift and go to state 14
    map                            shift and go to state 15
    while                          shift and go to state 16
    for                            shift and go to state 17
    if                             shift and go to state 18
    iniciarMap                     shift and go to state 24
    escribirMap                    shift and go to state 25
    generarMap                     shift and go to state 26
    soloIf                         shift and go to state 29

state 160

    (32) controlArg -> element clause element .

    CLOSE_PARENTHESIS reduce using rule 32 (controlArg -> element clause element .)
    SEMICOLON       reduce using rule 32 (controlArg -> element clause element .)
    AND             reduce using rule 32 (controlArg -> element clause element .)
    OR              reduce using rule 32 (controlArg -> element clause element .)


state 161

    (33) for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean . SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (112) expBoolean -> expBoolean . logicalOperator expBoolean
    (107) logicalOperator -> . AND
    (108) logicalOperator -> . OR

    SEMICOLON       shift and go to state 204
    AND             shift and go to state 206
    OR              shift and go to state 207

    logicalOperator                shift and go to state 205

state 162

    (109) expBoolean -> controlArg .

    SEMICOLON       reduce using rule 109 (expBoolean -> controlArg .)
    AND             reduce using rule 109 (expBoolean -> controlArg .)
    OR              reduce using rule 109 (expBoolean -> controlArg .)


state 163

    (110) expBoolean -> bool .

    SEMICOLON       reduce using rule 110 (expBoolean -> bool .)
    AND             reduce using rule 110 (expBoolean -> bool .)
    OR              reduce using rule 110 (expBoolean -> bool .)


state 164

    (111) expBoolean -> NOT . expBoolean
    (109) expBoolean -> . controlArg
    (110) expBoolean -> . bool
    (111) expBoolean -> . NOT expBoolean
    (112) expBoolean -> . expBoolean logicalOperator expBoolean
    (32) controlArg -> . element clause element
    (52) bool -> . TRUE
    (53) bool -> . FALSE
    (103) element -> . STRING
    (104) element -> . NUMBER
    (105) element -> . NAME

    NOT             shift and go to state 164
    TRUE            shift and go to state 72
    FALSE           shift and go to state 73
    STRING          shift and go to state 39
    NUMBER          shift and go to state 40
    NAME            shift and go to state 41

    expBoolean                     shift and go to state 208
    controlArg                     shift and go to state 162
    bool                           shift and go to state 163
    element                        shift and go to state 71

state 165

    (34) inicialization -> type NAME IGUAL . NUMBER

    NUMBER          shift and go to state 209


state 166

    (35) inicialization -> NAME IGUAL NUMBER .

    SEMICOLON       reduce using rule 35 (inicialization -> NAME IGUAL NUMBER .)


state 167

    (29) elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS . OPEN_BRACE expression CLOSE_BRACE
    (30) elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS . OPEN_BRACE expression CLOSE_BRACE soloIf

    OPEN_BRACE      shift and go to state 210


state 168

    (31) else -> ELSE OPEN_BRACE expression CLOSE_BRACE .

    NAME            reduce using rule 31 (else -> ELSE OPEN_BRACE expression CLOSE_BRACE .)
    RETURN          reduce using rule 31 (else -> ELSE OPEN_BRACE expression CLOSE_BRACE .)
    FUNCTION        reduce using rule 31 (else -> ELSE OPEN_BRACE expression CLOSE_BRACE .)
    CONST           reduce using rule 31 (else -> ELSE OPEN_BRACE expression CLOSE_BRACE .)
    LET             reduce using rule 31 (else -> ELSE OPEN_BRACE expression CLOSE_BRACE .)
    VAR             reduce using rule 31 (else -> ELSE OPEN_BRACE expression CLOSE_BRACE .)
    WHILE           reduce using rule 31 (else -> ELSE OPEN_BRACE expression CLOSE_BRACE .)
    FOR             reduce using rule 31 (else -> ELSE OPEN_BRACE expression CLOSE_BRACE .)
    IF              reduce using rule 31 (else -> ELSE OPEN_BRACE expression CLOSE_BRACE .)
    $end            reduce using rule 31 (else -> ELSE OPEN_BRACE expression CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 31 (else -> ELSE OPEN_BRACE expression CLOSE_BRACE .)


state 169

    (28) soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE . expression CLOSE_BRACE
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) expression -> . methodsSet
    (8) expression -> . mapFunctions
    (9) expression -> . arrayFn
    (10) expression -> . declaration
    (11) expression -> . return
    (12) expression -> . function
    (13) variable -> . type NAME IGUAL datatype SEMICOLON
    (14) variable -> . type NAME IGUAL operations SEMICOLON
    (15) variable -> . NAME IGUAL datatype SEMICOLON
    (19) dataStruct -> . array
    (20) dataStruct -> . set
    (21) dataStruct -> . map
    (16) controlStruct -> . while
    (17) controlStruct -> . for
    (18) controlStruct -> . if
    (94) methodsSet -> . NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (95) methodsSet -> . NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (96) methodsSet -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (82) mapFunctions -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (83) mapFunctions -> . NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (84) mapFunctions -> . NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (85) arrayFn -> . NAME POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (86) arrayFn -> . NAME POINT PUSH OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (87) arrayFn -> . NAME POINT UNSHIFT OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (106) declaration -> . NAME IGUAL element SEMICOLON
    (117) return -> . RETURN element SEMICOLON
    (113) function -> . FUNCTION NAME OPEN_PARENTHESIS CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (114) function -> . FUNCTION NAME OPEN_PARENTHESIS parameter CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (54) type -> . CONST
    (55) type -> . LET
    (56) type -> . VAR
    (65) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (66) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (88) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (89) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (90) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (91) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (92) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (93) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (67) map -> . iniciarMap
    (68) map -> . escribirMap
    (69) map -> . generarMap
    (22) while -> . WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (23) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (33) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (24) if -> . soloIf
    (25) if -> . soloIf elseIf
    (26) if -> . soloIf elseIf else
    (27) if -> . soloIf else
    (70) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (71) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (77) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (28) soloIf -> . IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    NAME            shift and go to state 12
    RETURN          shift and go to state 19
    FUNCTION        shift and go to state 20
    CONST           shift and go to state 21
    LET             shift and go to state 22
    VAR             shift and go to state 23
    WHILE           shift and go to state 27
    FOR             shift and go to state 28
    IF              shift and go to state 30

    expression                     shift and go to state 211
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    methodsSet                     shift and go to state 5
    mapFunctions                   shift and go to state 6
    arrayFn                        shift and go to state 7
    declaration                    shift and go to state 8
    return                         shift and go to state 9
    function                       shift and go to state 10
    type                           shift and go to state 11
    array                          shift and go to state 13
    set                            shift and go to state 14
    map                            shift and go to state 15
    while                          shift and go to state 16
    for                            shift and go to state 17
    if                             shift and go to state 18
    iniciarMap                     shift and go to state 24
    escribirMap                    shift and go to state 25
    generarMap                     shift and go to state 26
    soloIf                         shift and go to state 29

state 170

    (70) iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 212


state 171

    (72) claveValor -> clave COLON valor .
    (73) claveValor -> clave COLON valor . COMMA claveValor

    CLOSE_BRACE     reduce using rule 72 (claveValor -> clave COLON valor .)
    COMMA           shift and go to state 213


state 172

    (75) valor -> datatype .

    COMMA           reduce using rule 75 (valor -> datatype .)
    CLOSE_BRACE     reduce using rule 75 (valor -> datatype .)


state 173

    (76) valor -> dataStruct .

    COMMA           reduce using rule 76 (valor -> dataStruct .)
    CLOSE_BRACE     reduce using rule 76 (valor -> dataStruct .)


state 174

    (65) array -> type . NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (66) array -> type . NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (88) set -> type . NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (89) set -> type . NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (90) set -> type . NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (13) variable -> type . NAME IGUAL datatype SEMICOLON
    (14) variable -> type . NAME IGUAL operations SEMICOLON

    NAME            shift and go to state 214


state 175

    (91) set -> NAME . IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (92) set -> NAME . IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (93) set -> NAME . IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (15) variable -> NAME . IGUAL datatype SEMICOLON

    IGUAL           shift and go to state 215


state 176

    (70) iniciarMap -> variable . IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (71) escribirMap -> variable . IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (77) generarMap -> variable . IGUAL OPEN_BRACE tuplas CLOSE_BRACE

    IGUAL           shift and go to state 32


state 177

    (79) tuplas -> tupla COMMA tuplas .

    CLOSE_BRACE     reduce using rule 79 (tuplas -> tupla COMMA tuplas .)


state 178

    (80) tupla -> OPEN_BRACKET datatype CLOSE_BRACKET . SEMICOLON

    SEMICOLON       shift and go to state 216


state 179

    (81) tupla -> OPEN_BRACKET datatype COMMA . datatype CLOSE_BRACKET SEMICOLON
    (45) datatype -> . NUMBER
    (46) datatype -> . STRING
    (47) datatype -> . CHAR

    NUMBER          shift and go to state 88
    STRING          shift and go to state 89
    CHAR            shift and go to state 58

    datatype                       shift and go to state 217

state 180

    (43) operations -> NAME operand NAME . operations
    (36) operations -> . NUMBER operand NUMBER
    (37) operations -> . NAME
    (38) operations -> . NUMBER
    (39) operations -> . NUMBER operand NAME operations
    (40) operations -> . NAME operand NUMBER operations
    (41) operations -> . NUMBER operand NAME
    (42) operations -> . NAME operand NUMBER
    (43) operations -> . NAME operand NAME operations
    (44) operations -> . NUMBER operand NUMBER operand operations

    NUMBER          shift and go to state 219
    NAME            shift and go to state 90

    operations                     shift and go to state 218

state 181

    (40) operations -> NAME operand NUMBER . operations
    (42) operations -> NAME operand NUMBER .
    (36) operations -> . NUMBER operand NUMBER
    (37) operations -> . NAME
    (38) operations -> . NUMBER
    (39) operations -> . NUMBER operand NAME operations
    (40) operations -> . NAME operand NUMBER operations
    (41) operations -> . NUMBER operand NAME
    (42) operations -> . NAME operand NUMBER
    (43) operations -> . NAME operand NAME operations
    (44) operations -> . NUMBER operand NUMBER operand operations

    SEMICOLON       reduce using rule 42 (operations -> NAME operand NUMBER .)
    CLOSE_PARENTHESIS reduce using rule 42 (operations -> NAME operand NUMBER .)
    NUMBER          shift and go to state 219
    NAME            shift and go to state 90

    operations                     shift and go to state 220

state 182

    (65) array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET . SEMICOLON

    SEMICOLON       shift and go to state 221


state 183

    (100) numeros -> NUMBER COMMA . numeros
    (99) numeros -> . NUMBER
    (100) numeros -> . NUMBER COMMA numeros

    NUMBER          shift and go to state 141

    numeros                        shift and go to state 222

state 184

    (102) cadena -> STRING COMMA . cadena
    (101) cadena -> . STRING
    (102) cadena -> . STRING COMMA cadena

    STRING          shift and go to state 142

    cadena                         shift and go to state 223

state 185

    (66) array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS . items CLOSE_PARENTHESIS SEMICOLON
    (97) items -> . numeros
    (98) items -> . cadena
    (99) numeros -> . NUMBER
    (100) numeros -> . NUMBER COMMA numeros
    (101) cadena -> . STRING
    (102) cadena -> . STRING COMMA cadena

    NUMBER          shift and go to state 141
    STRING          shift and go to state 142

    items                          shift and go to state 224
    numeros                        shift and go to state 139
    cadena                         shift and go to state 140

state 186

    (88) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS . CLOSE_PARENTHESIS SEMICOLON
    (89) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS . OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (90) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS . element CLOSE_PARENTHESIS SEMICOLON
    (103) element -> . STRING
    (104) element -> . NUMBER
    (105) element -> . NAME

    CLOSE_PARENTHESIS shift and go to state 225
    OPEN_BRACKET    shift and go to state 226
    STRING          shift and go to state 39
    NUMBER          shift and go to state 40
    NAME            shift and go to state 41

    element                        shift and go to state 227

state 187

    (36) operations -> NUMBER operand NUMBER .
    (44) operations -> NUMBER operand NUMBER . operand operations
    (48) operand -> . SUMA
    (49) operand -> . RESTA
    (50) operand -> . MULTIPLICACION
    (51) operand -> . DIVISION

    SEMICOLON       reduce using rule 36 (operations -> NUMBER operand NUMBER .)
    CLOSE_PARENTHESIS reduce using rule 36 (operations -> NUMBER operand NUMBER .)
    SUMA            shift and go to state 132
    RESTA           shift and go to state 133
    MULTIPLICACION  shift and go to state 134
    DIVISION        shift and go to state 135

    operand                        shift and go to state 228

state 188

    (39) operations -> NUMBER operand NAME . operations
    (41) operations -> NUMBER operand NAME .
    (36) operations -> . NUMBER operand NUMBER
    (37) operations -> . NAME
    (38) operations -> . NUMBER
    (39) operations -> . NUMBER operand NAME operations
    (40) operations -> . NAME operand NUMBER operations
    (41) operations -> . NUMBER operand NAME
    (42) operations -> . NAME operand NUMBER
    (43) operations -> . NAME operand NAME operations
    (44) operations -> . NUMBER operand NUMBER operand operations

    SEMICOLON       reduce using rule 41 (operations -> NUMBER operand NAME .)
    CLOSE_PARENTHESIS reduce using rule 41 (operations -> NUMBER operand NAME .)
    NUMBER          shift and go to state 219
    NAME            shift and go to state 90

    operations                     shift and go to state 229

state 189

    (91) set -> NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 230


state 190

    (92) set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET . items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (97) items -> . numeros
    (98) items -> . cadena
    (99) numeros -> . NUMBER
    (100) numeros -> . NUMBER COMMA numeros
    (101) cadena -> . STRING
    (102) cadena -> . STRING COMMA cadena

    NUMBER          shift and go to state 141
    STRING          shift and go to state 142

    items                          shift and go to state 231
    numeros                        shift and go to state 139
    cadena                         shift and go to state 140

state 191

    (93) set -> NAME IGUAL NEW SET OPEN_PARENTHESIS element . CLOSE_PARENTHESIS SEMICOLON

    CLOSE_PARENTHESIS shift and go to state 232


state 192

    (94) methodsSet -> NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 233


state 193

    (95) methodsSet -> NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 234


state 194

    (96) methodsSet -> NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .
    (82) mapFunctions -> NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .

  ! reduce/reduce conflict for $end resolved using rule 82 (mapFunctions -> NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
  ! reduce/reduce conflict for CLOSE_BRACE resolved using rule 82 (mapFunctions -> NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    $end            reduce using rule 82 (mapFunctions -> NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 82 (mapFunctions -> NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)

  ! $end            [ reduce using rule 96 (methodsSet -> NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .) ]
  ! CLOSE_BRACE     [ reduce using rule 96 (methodsSet -> NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .) ]


state 195

    (83) mapFunctions -> NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 235


state 196

    (84) mapFunctions -> NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 236


state 197

    (85) arrayFn -> NAME POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .

    $end            reduce using rule 85 (arrayFn -> NAME POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 85 (arrayFn -> NAME POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)


state 198

    (86) arrayFn -> NAME POINT PUSH OPEN_PARENTHESIS element CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 237


state 199

    (87) arrayFn -> NAME POINT UNSHIFT OPEN_PARENTHESIS element CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 238


state 200

    (113) function -> FUNCTION NAME OPEN_PARENTHESIS CLOSE_PARENTHESIS OPEN_BRACE expression . CLOSE_BRACE

    CLOSE_BRACE     shift and go to state 239


state 201

    (114) function -> FUNCTION NAME OPEN_PARENTHESIS parameter CLOSE_PARENTHESIS OPEN_BRACE . expression CLOSE_BRACE
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) expression -> . methodsSet
    (8) expression -> . mapFunctions
    (9) expression -> . arrayFn
    (10) expression -> . declaration
    (11) expression -> . return
    (12) expression -> . function
    (13) variable -> . type NAME IGUAL datatype SEMICOLON
    (14) variable -> . type NAME IGUAL operations SEMICOLON
    (15) variable -> . NAME IGUAL datatype SEMICOLON
    (19) dataStruct -> . array
    (20) dataStruct -> . set
    (21) dataStruct -> . map
    (16) controlStruct -> . while
    (17) controlStruct -> . for
    (18) controlStruct -> . if
    (94) methodsSet -> . NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (95) methodsSet -> . NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (96) methodsSet -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (82) mapFunctions -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (83) mapFunctions -> . NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (84) mapFunctions -> . NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (85) arrayFn -> . NAME POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (86) arrayFn -> . NAME POINT PUSH OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (87) arrayFn -> . NAME POINT UNSHIFT OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (106) declaration -> . NAME IGUAL element SEMICOLON
    (117) return -> . RETURN element SEMICOLON
    (113) function -> . FUNCTION NAME OPEN_PARENTHESIS CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (114) function -> . FUNCTION NAME OPEN_PARENTHESIS parameter CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (54) type -> . CONST
    (55) type -> . LET
    (56) type -> . VAR
    (65) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (66) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (88) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (89) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (90) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (91) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (92) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (93) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (67) map -> . iniciarMap
    (68) map -> . escribirMap
    (69) map -> . generarMap
    (22) while -> . WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (23) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (33) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (24) if -> . soloIf
    (25) if -> . soloIf elseIf
    (26) if -> . soloIf elseIf else
    (27) if -> . soloIf else
    (70) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (71) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (77) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (28) soloIf -> . IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    NAME            shift and go to state 12
    RETURN          shift and go to state 19
    FUNCTION        shift and go to state 20
    CONST           shift and go to state 21
    LET             shift and go to state 22
    VAR             shift and go to state 23
    WHILE           shift and go to state 27
    FOR             shift and go to state 28
    IF              shift and go to state 30

    expression                     shift and go to state 240
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    methodsSet                     shift and go to state 5
    mapFunctions                   shift and go to state 6
    arrayFn                        shift and go to state 7
    declaration                    shift and go to state 8
    return                         shift and go to state 9
    function                       shift and go to state 10
    type                           shift and go to state 11
    array                          shift and go to state 13
    set                            shift and go to state 14
    map                            shift and go to state 15
    while                          shift and go to state 16
    for                            shift and go to state 17
    if                             shift and go to state 18
    iniciarMap                     shift and go to state 24
    escribirMap                    shift and go to state 25
    generarMap                     shift and go to state 26
    soloIf                         shift and go to state 29

state 202

    (22) while -> WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression . CLOSE_BRACE

    CLOSE_BRACE     shift and go to state 241


state 203

    (23) while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression . CLOSE_BRACE

    CLOSE_BRACE     shift and go to state 242


state 204

    (33) for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON . operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (36) operations -> . NUMBER operand NUMBER
    (37) operations -> . NAME
    (38) operations -> . NUMBER
    (39) operations -> . NUMBER operand NAME operations
    (40) operations -> . NAME operand NUMBER operations
    (41) operations -> . NUMBER operand NAME
    (42) operations -> . NAME operand NUMBER
    (43) operations -> . NAME operand NAME operations
    (44) operations -> . NUMBER operand NUMBER operand operations

    NUMBER          shift and go to state 219
    NAME            shift and go to state 90

    operations                     shift and go to state 243

state 205

    (112) expBoolean -> expBoolean logicalOperator . expBoolean
    (109) expBoolean -> . controlArg
    (110) expBoolean -> . bool
    (111) expBoolean -> . NOT expBoolean
    (112) expBoolean -> . expBoolean logicalOperator expBoolean
    (32) controlArg -> . element clause element
    (52) bool -> . TRUE
    (53) bool -> . FALSE
    (103) element -> . STRING
    (104) element -> . NUMBER
    (105) element -> . NAME

    NOT             shift and go to state 164
    TRUE            shift and go to state 72
    FALSE           shift and go to state 73
    STRING          shift and go to state 39
    NUMBER          shift and go to state 40
    NAME            shift and go to state 41

    expBoolean                     shift and go to state 244
    controlArg                     shift and go to state 162
    bool                           shift and go to state 163
    element                        shift and go to state 71

state 206

    (107) logicalOperator -> AND .

    NOT             reduce using rule 107 (logicalOperator -> AND .)
    TRUE            reduce using rule 107 (logicalOperator -> AND .)
    FALSE           reduce using rule 107 (logicalOperator -> AND .)
    STRING          reduce using rule 107 (logicalOperator -> AND .)
    NUMBER          reduce using rule 107 (logicalOperator -> AND .)
    NAME            reduce using rule 107 (logicalOperator -> AND .)


state 207

    (108) logicalOperator -> OR .

    NOT             reduce using rule 108 (logicalOperator -> OR .)
    TRUE            reduce using rule 108 (logicalOperator -> OR .)
    FALSE           reduce using rule 108 (logicalOperator -> OR .)
    STRING          reduce using rule 108 (logicalOperator -> OR .)
    NUMBER          reduce using rule 108 (logicalOperator -> OR .)
    NAME            reduce using rule 108 (logicalOperator -> OR .)


state 208

    (111) expBoolean -> NOT expBoolean .
    (112) expBoolean -> expBoolean . logicalOperator expBoolean
    (107) logicalOperator -> . AND
    (108) logicalOperator -> . OR

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 111 (expBoolean -> NOT expBoolean .)
    AND             shift and go to state 206
    OR              shift and go to state 207

  ! AND             [ reduce using rule 111 (expBoolean -> NOT expBoolean .) ]
  ! OR              [ reduce using rule 111 (expBoolean -> NOT expBoolean .) ]

    logicalOperator                shift and go to state 205

state 209

    (34) inicialization -> type NAME IGUAL NUMBER .

    SEMICOLON       reduce using rule 34 (inicialization -> type NAME IGUAL NUMBER .)


state 210

    (29) elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE . expression CLOSE_BRACE
    (30) elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE . expression CLOSE_BRACE soloIf
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) expression -> . methodsSet
    (8) expression -> . mapFunctions
    (9) expression -> . arrayFn
    (10) expression -> . declaration
    (11) expression -> . return
    (12) expression -> . function
    (13) variable -> . type NAME IGUAL datatype SEMICOLON
    (14) variable -> . type NAME IGUAL operations SEMICOLON
    (15) variable -> . NAME IGUAL datatype SEMICOLON
    (19) dataStruct -> . array
    (20) dataStruct -> . set
    (21) dataStruct -> . map
    (16) controlStruct -> . while
    (17) controlStruct -> . for
    (18) controlStruct -> . if
    (94) methodsSet -> . NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (95) methodsSet -> . NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (96) methodsSet -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (82) mapFunctions -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (83) mapFunctions -> . NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (84) mapFunctions -> . NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (85) arrayFn -> . NAME POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (86) arrayFn -> . NAME POINT PUSH OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (87) arrayFn -> . NAME POINT UNSHIFT OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (106) declaration -> . NAME IGUAL element SEMICOLON
    (117) return -> . RETURN element SEMICOLON
    (113) function -> . FUNCTION NAME OPEN_PARENTHESIS CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (114) function -> . FUNCTION NAME OPEN_PARENTHESIS parameter CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (54) type -> . CONST
    (55) type -> . LET
    (56) type -> . VAR
    (65) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (66) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (88) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (89) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (90) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (91) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (92) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (93) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (67) map -> . iniciarMap
    (68) map -> . escribirMap
    (69) map -> . generarMap
    (22) while -> . WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (23) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (33) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (24) if -> . soloIf
    (25) if -> . soloIf elseIf
    (26) if -> . soloIf elseIf else
    (27) if -> . soloIf else
    (70) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (71) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (77) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (28) soloIf -> . IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    NAME            shift and go to state 12
    RETURN          shift and go to state 19
    FUNCTION        shift and go to state 20
    CONST           shift and go to state 21
    LET             shift and go to state 22
    VAR             shift and go to state 23
    WHILE           shift and go to state 27
    FOR             shift and go to state 28
    IF              shift and go to state 30

    expression                     shift and go to state 245
    soloIf                         shift and go to state 29
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    methodsSet                     shift and go to state 5
    mapFunctions                   shift and go to state 6
    arrayFn                        shift and go to state 7
    declaration                    shift and go to state 8
    return                         shift and go to state 9
    function                       shift and go to state 10
    type                           shift and go to state 11
    array                          shift and go to state 13
    set                            shift and go to state 14
    map                            shift and go to state 15
    while                          shift and go to state 16
    for                            shift and go to state 17
    if                             shift and go to state 18
    iniciarMap                     shift and go to state 24
    escribirMap                    shift and go to state 25
    generarMap                     shift and go to state 26

state 211

    (28) soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression . CLOSE_BRACE

    CLOSE_BRACE     shift and go to state 246


state 212

    (70) iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .

    NAME            reduce using rule 70 (iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    RETURN          reduce using rule 70 (iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    FUNCTION        reduce using rule 70 (iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    CONST           reduce using rule 70 (iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    LET             reduce using rule 70 (iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    VAR             reduce using rule 70 (iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    WHILE           reduce using rule 70 (iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    FOR             reduce using rule 70 (iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    IF              reduce using rule 70 (iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    $end            reduce using rule 70 (iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 70 (iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    COMMA           reduce using rule 70 (iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)


state 213

    (73) claveValor -> clave COLON valor COMMA . claveValor
    (72) claveValor -> . clave COLON valor
    (73) claveValor -> . clave COLON valor COMMA claveValor
    (74) clave -> . datatype
    (45) datatype -> . NUMBER
    (46) datatype -> . STRING
    (47) datatype -> . CHAR

    NUMBER          shift and go to state 88
    STRING          shift and go to state 89
    CHAR            shift and go to state 58

    clave                          shift and go to state 84
    claveValor                     shift and go to state 247
    datatype                       shift and go to state 86

state 214

    (65) array -> type NAME . IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (66) array -> type NAME . IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (88) set -> type NAME . IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (89) set -> type NAME . IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (90) set -> type NAME . IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (13) variable -> type NAME . IGUAL datatype SEMICOLON
    (14) variable -> type NAME . IGUAL operations SEMICOLON

    IGUAL           shift and go to state 248


state 215

    (91) set -> NAME IGUAL . NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (92) set -> NAME IGUAL . NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (93) set -> NAME IGUAL . NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (15) variable -> NAME IGUAL . datatype SEMICOLON
    (45) datatype -> . NUMBER
    (46) datatype -> . STRING
    (47) datatype -> . CHAR

    NEW             shift and go to state 55
    NUMBER          shift and go to state 88
    STRING          shift and go to state 89
    CHAR            shift and go to state 58

    datatype                       shift and go to state 53

state 216

    (80) tupla -> OPEN_BRACKET datatype CLOSE_BRACKET SEMICOLON .

    COMMA           reduce using rule 80 (tupla -> OPEN_BRACKET datatype CLOSE_BRACKET SEMICOLON .)
    CLOSE_BRACE     reduce using rule 80 (tupla -> OPEN_BRACKET datatype CLOSE_BRACKET SEMICOLON .)


state 217

    (81) tupla -> OPEN_BRACKET datatype COMMA datatype . CLOSE_BRACKET SEMICOLON

    CLOSE_BRACKET   shift and go to state 249


state 218

    (43) operations -> NAME operand NAME operations .

    SEMICOLON       reduce using rule 43 (operations -> NAME operand NAME operations .)
    CLOSE_PARENTHESIS reduce using rule 43 (operations -> NAME operand NAME operations .)


state 219

    (36) operations -> NUMBER . operand NUMBER
    (38) operations -> NUMBER .
    (39) operations -> NUMBER . operand NAME operations
    (41) operations -> NUMBER . operand NAME
    (44) operations -> NUMBER . operand NUMBER operand operations
    (48) operand -> . SUMA
    (49) operand -> . RESTA
    (50) operand -> . MULTIPLICACION
    (51) operand -> . DIVISION

    SEMICOLON       reduce using rule 38 (operations -> NUMBER .)
    CLOSE_PARENTHESIS reduce using rule 38 (operations -> NUMBER .)
    SUMA            shift and go to state 132
    RESTA           shift and go to state 133
    MULTIPLICACION  shift and go to state 134
    DIVISION        shift and go to state 135

    operand                        shift and go to state 145

state 220

    (40) operations -> NAME operand NUMBER operations .

    SEMICOLON       reduce using rule 40 (operations -> NAME operand NUMBER operations .)
    CLOSE_PARENTHESIS reduce using rule 40 (operations -> NAME operand NUMBER operations .)


state 221

    (65) array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .

    NAME            reduce using rule 65 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    RETURN          reduce using rule 65 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    FUNCTION        reduce using rule 65 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    CONST           reduce using rule 65 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    LET             reduce using rule 65 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    VAR             reduce using rule 65 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    WHILE           reduce using rule 65 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    FOR             reduce using rule 65 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    IF              reduce using rule 65 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    $end            reduce using rule 65 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    CLOSE_BRACE     reduce using rule 65 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    COMMA           reduce using rule 65 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)


state 222

    (100) numeros -> NUMBER COMMA numeros .

    CLOSE_BRACKET   reduce using rule 100 (numeros -> NUMBER COMMA numeros .)
    CLOSE_PARENTHESIS reduce using rule 100 (numeros -> NUMBER COMMA numeros .)


state 223

    (102) cadena -> STRING COMMA cadena .

    CLOSE_BRACKET   reduce using rule 102 (cadena -> STRING COMMA cadena .)
    CLOSE_PARENTHESIS reduce using rule 102 (cadena -> STRING COMMA cadena .)


state 224

    (66) array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items . CLOSE_PARENTHESIS SEMICOLON

    CLOSE_PARENTHESIS shift and go to state 250


state 225

    (88) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 251


state 226

    (89) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET . items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (97) items -> . numeros
    (98) items -> . cadena
    (99) numeros -> . NUMBER
    (100) numeros -> . NUMBER COMMA numeros
    (101) cadena -> . STRING
    (102) cadena -> . STRING COMMA cadena

    NUMBER          shift and go to state 141
    STRING          shift and go to state 142

    items                          shift and go to state 252
    numeros                        shift and go to state 139
    cadena                         shift and go to state 140

state 227

    (90) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element . CLOSE_PARENTHESIS SEMICOLON

    CLOSE_PARENTHESIS shift and go to state 253


state 228

    (44) operations -> NUMBER operand NUMBER operand . operations
    (36) operations -> . NUMBER operand NUMBER
    (37) operations -> . NAME
    (38) operations -> . NUMBER
    (39) operations -> . NUMBER operand NAME operations
    (40) operations -> . NAME operand NUMBER operations
    (41) operations -> . NUMBER operand NAME
    (42) operations -> . NAME operand NUMBER
    (43) operations -> . NAME operand NAME operations
    (44) operations -> . NUMBER operand NUMBER operand operations

    NUMBER          shift and go to state 219
    NAME            shift and go to state 90

    operations                     shift and go to state 254

state 229

    (39) operations -> NUMBER operand NAME operations .

    SEMICOLON       reduce using rule 39 (operations -> NUMBER operand NAME operations .)
    CLOSE_PARENTHESIS reduce using rule 39 (operations -> NUMBER operand NAME operations .)


state 230

    (91) set -> NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .

    NAME            reduce using rule 91 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    RETURN          reduce using rule 91 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    FUNCTION        reduce using rule 91 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    CONST           reduce using rule 91 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    LET             reduce using rule 91 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    VAR             reduce using rule 91 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    WHILE           reduce using rule 91 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    FOR             reduce using rule 91 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    IF              reduce using rule 91 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    $end            reduce using rule 91 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 91 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    COMMA           reduce using rule 91 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)


state 231

    (92) set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items . CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON

    CLOSE_BRACKET   shift and go to state 255


state 232

    (93) set -> NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 256


state 233

    (94) methodsSet -> NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .

    $end            reduce using rule 94 (methodsSet -> NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 94 (methodsSet -> NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)


state 234

    (95) methodsSet -> NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .

    $end            reduce using rule 95 (methodsSet -> NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 95 (methodsSet -> NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)


state 235

    (83) mapFunctions -> NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON .

    $end            reduce using rule 83 (mapFunctions -> NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 83 (mapFunctions -> NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON .)


state 236

    (84) mapFunctions -> NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON .

    $end            reduce using rule 84 (mapFunctions -> NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 84 (mapFunctions -> NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON .)


state 237

    (86) arrayFn -> NAME POINT PUSH OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .

    $end            reduce using rule 86 (arrayFn -> NAME POINT PUSH OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 86 (arrayFn -> NAME POINT PUSH OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)


state 238

    (87) arrayFn -> NAME POINT UNSHIFT OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .

    $end            reduce using rule 87 (arrayFn -> NAME POINT UNSHIFT OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 87 (arrayFn -> NAME POINT UNSHIFT OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)


state 239

    (113) function -> FUNCTION NAME OPEN_PARENTHESIS CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .

    $end            reduce using rule 113 (function -> FUNCTION NAME OPEN_PARENTHESIS CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 113 (function -> FUNCTION NAME OPEN_PARENTHESIS CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)


state 240

    (114) function -> FUNCTION NAME OPEN_PARENTHESIS parameter CLOSE_PARENTHESIS OPEN_BRACE expression . CLOSE_BRACE

    CLOSE_BRACE     shift and go to state 257


state 241

    (22) while -> WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .

    NAME            reduce using rule 22 (while -> WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    RETURN          reduce using rule 22 (while -> WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    FUNCTION        reduce using rule 22 (while -> WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CONST           reduce using rule 22 (while -> WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    LET             reduce using rule 22 (while -> WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    VAR             reduce using rule 22 (while -> WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    WHILE           reduce using rule 22 (while -> WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    FOR             reduce using rule 22 (while -> WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    IF              reduce using rule 22 (while -> WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    $end            reduce using rule 22 (while -> WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 22 (while -> WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)


state 242

    (23) while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .

    NAME            reduce using rule 23 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    RETURN          reduce using rule 23 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    FUNCTION        reduce using rule 23 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CONST           reduce using rule 23 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    LET             reduce using rule 23 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    VAR             reduce using rule 23 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    WHILE           reduce using rule 23 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    FOR             reduce using rule 23 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    IF              reduce using rule 23 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    $end            reduce using rule 23 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 23 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)


state 243

    (33) for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations . CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    CLOSE_PARENTHESIS shift and go to state 258


state 244

    (112) expBoolean -> expBoolean logicalOperator expBoolean .
    (112) expBoolean -> expBoolean . logicalOperator expBoolean
    (107) logicalOperator -> . AND
    (108) logicalOperator -> . OR

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 112 (expBoolean -> expBoolean logicalOperator expBoolean .)
    AND             shift and go to state 206
    OR              shift and go to state 207

  ! AND             [ reduce using rule 112 (expBoolean -> expBoolean logicalOperator expBoolean .) ]
  ! OR              [ reduce using rule 112 (expBoolean -> expBoolean logicalOperator expBoolean .) ]

    logicalOperator                shift and go to state 205

state 245

    (29) elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression . CLOSE_BRACE
    (30) elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression . CLOSE_BRACE soloIf

    CLOSE_BRACE     shift and go to state 259


state 246

    (28) soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .

    ELSEIF          reduce using rule 28 (soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    ELSE            reduce using rule 28 (soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    NAME            reduce using rule 28 (soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    RETURN          reduce using rule 28 (soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    FUNCTION        reduce using rule 28 (soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CONST           reduce using rule 28 (soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    LET             reduce using rule 28 (soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    VAR             reduce using rule 28 (soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    WHILE           reduce using rule 28 (soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    FOR             reduce using rule 28 (soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    IF              reduce using rule 28 (soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    $end            reduce using rule 28 (soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 28 (soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)


state 247

    (73) claveValor -> clave COLON valor COMMA claveValor .

    CLOSE_BRACE     reduce using rule 73 (claveValor -> clave COLON valor COMMA claveValor .)


state 248

    (65) array -> type NAME IGUAL . OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (66) array -> type NAME IGUAL . NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (88) set -> type NAME IGUAL . NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (89) set -> type NAME IGUAL . NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (90) set -> type NAME IGUAL . NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (13) variable -> type NAME IGUAL . datatype SEMICOLON
    (14) variable -> type NAME IGUAL . operations SEMICOLON
    (45) datatype -> . NUMBER
    (46) datatype -> . STRING
    (47) datatype -> . CHAR
    (36) operations -> . NUMBER operand NUMBER
    (37) operations -> . NAME
    (38) operations -> . NUMBER
    (39) operations -> . NUMBER operand NAME operations
    (40) operations -> . NAME operand NUMBER operations
    (41) operations -> . NUMBER operand NAME
    (42) operations -> . NAME operand NUMBER
    (43) operations -> . NAME operand NAME operations
    (44) operations -> . NUMBER operand NUMBER operand operations

    OPEN_BRACKET    shift and go to state 93
    NEW             shift and go to state 94
    NUMBER          shift and go to state 95
    STRING          shift and go to state 89
    CHAR            shift and go to state 58
    NAME            shift and go to state 90

    datatype                       shift and go to state 91
    operations                     shift and go to state 92

state 249

    (81) tupla -> OPEN_BRACKET datatype COMMA datatype CLOSE_BRACKET . SEMICOLON

    SEMICOLON       shift and go to state 260


state 250

    (66) array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 261


state 251

    (88) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .

    NAME            reduce using rule 88 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    RETURN          reduce using rule 88 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    FUNCTION        reduce using rule 88 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    CONST           reduce using rule 88 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    LET             reduce using rule 88 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    VAR             reduce using rule 88 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    WHILE           reduce using rule 88 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    FOR             reduce using rule 88 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    IF              reduce using rule 88 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    $end            reduce using rule 88 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 88 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    COMMA           reduce using rule 88 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)


state 252

    (89) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items . CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON

    CLOSE_BRACKET   shift and go to state 262


state 253

    (90) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 263


state 254

    (44) operations -> NUMBER operand NUMBER operand operations .

    SEMICOLON       reduce using rule 44 (operations -> NUMBER operand NUMBER operand operations .)
    CLOSE_PARENTHESIS reduce using rule 44 (operations -> NUMBER operand NUMBER operand operations .)


state 255

    (92) set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET . CLOSE_PARENTHESIS SEMICOLON

    CLOSE_PARENTHESIS shift and go to state 264


state 256

    (93) set -> NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .

    NAME            reduce using rule 93 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    RETURN          reduce using rule 93 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    FUNCTION        reduce using rule 93 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    CONST           reduce using rule 93 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    LET             reduce using rule 93 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    VAR             reduce using rule 93 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    WHILE           reduce using rule 93 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    FOR             reduce using rule 93 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    IF              reduce using rule 93 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    $end            reduce using rule 93 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 93 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    COMMA           reduce using rule 93 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)


state 257

    (114) function -> FUNCTION NAME OPEN_PARENTHESIS parameter CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .

    $end            reduce using rule 114 (function -> FUNCTION NAME OPEN_PARENTHESIS parameter CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 114 (function -> FUNCTION NAME OPEN_PARENTHESIS parameter CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)


state 258

    (33) for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS . OPEN_BRACE expression CLOSE_BRACE

    OPEN_BRACE      shift and go to state 265


state 259

    (29) elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .
    (30) elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE . soloIf
    (28) soloIf -> . IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

  ! shift/reduce conflict for IF resolved as shift
    ELSE            reduce using rule 29 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    NAME            reduce using rule 29 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    RETURN          reduce using rule 29 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    FUNCTION        reduce using rule 29 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CONST           reduce using rule 29 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    LET             reduce using rule 29 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    VAR             reduce using rule 29 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    WHILE           reduce using rule 29 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    FOR             reduce using rule 29 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    $end            reduce using rule 29 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 29 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    IF              shift and go to state 30

  ! IF              [ reduce using rule 29 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .) ]

    soloIf                         shift and go to state 266

state 260

    (81) tupla -> OPEN_BRACKET datatype COMMA datatype CLOSE_BRACKET SEMICOLON .

    COMMA           reduce using rule 81 (tupla -> OPEN_BRACKET datatype COMMA datatype CLOSE_BRACKET SEMICOLON .)
    CLOSE_BRACE     reduce using rule 81 (tupla -> OPEN_BRACKET datatype COMMA datatype CLOSE_BRACKET SEMICOLON .)


state 261

    (66) array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .

    NAME            reduce using rule 66 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    RETURN          reduce using rule 66 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    FUNCTION        reduce using rule 66 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    CONST           reduce using rule 66 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    LET             reduce using rule 66 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    VAR             reduce using rule 66 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    WHILE           reduce using rule 66 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    FOR             reduce using rule 66 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    IF              reduce using rule 66 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    $end            reduce using rule 66 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 66 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    COMMA           reduce using rule 66 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)


state 262

    (89) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET . CLOSE_PARENTHESIS SEMICOLON

    CLOSE_PARENTHESIS shift and go to state 267


state 263

    (90) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .

    NAME            reduce using rule 90 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    RETURN          reduce using rule 90 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    FUNCTION        reduce using rule 90 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    CONST           reduce using rule 90 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    LET             reduce using rule 90 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    VAR             reduce using rule 90 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    WHILE           reduce using rule 90 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    FOR             reduce using rule 90 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    IF              reduce using rule 90 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    $end            reduce using rule 90 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 90 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    COMMA           reduce using rule 90 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)


state 264

    (92) set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 268


state 265

    (33) for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE . expression CLOSE_BRACE
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) expression -> . methodsSet
    (8) expression -> . mapFunctions
    (9) expression -> . arrayFn
    (10) expression -> . declaration
    (11) expression -> . return
    (12) expression -> . function
    (13) variable -> . type NAME IGUAL datatype SEMICOLON
    (14) variable -> . type NAME IGUAL operations SEMICOLON
    (15) variable -> . NAME IGUAL datatype SEMICOLON
    (19) dataStruct -> . array
    (20) dataStruct -> . set
    (21) dataStruct -> . map
    (16) controlStruct -> . while
    (17) controlStruct -> . for
    (18) controlStruct -> . if
    (94) methodsSet -> . NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (95) methodsSet -> . NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (96) methodsSet -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (82) mapFunctions -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (83) mapFunctions -> . NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (84) mapFunctions -> . NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (85) arrayFn -> . NAME POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (86) arrayFn -> . NAME POINT PUSH OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (87) arrayFn -> . NAME POINT UNSHIFT OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (106) declaration -> . NAME IGUAL element SEMICOLON
    (117) return -> . RETURN element SEMICOLON
    (113) function -> . FUNCTION NAME OPEN_PARENTHESIS CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (114) function -> . FUNCTION NAME OPEN_PARENTHESIS parameter CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (54) type -> . CONST
    (55) type -> . LET
    (56) type -> . VAR
    (65) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (66) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (88) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (89) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (90) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (91) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (92) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (93) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (67) map -> . iniciarMap
    (68) map -> . escribirMap
    (69) map -> . generarMap
    (22) while -> . WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (23) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (33) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (24) if -> . soloIf
    (25) if -> . soloIf elseIf
    (26) if -> . soloIf elseIf else
    (27) if -> . soloIf else
    (70) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (71) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (77) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (28) soloIf -> . IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    NAME            shift and go to state 12
    RETURN          shift and go to state 19
    FUNCTION        shift and go to state 20
    CONST           shift and go to state 21
    LET             shift and go to state 22
    VAR             shift and go to state 23
    WHILE           shift and go to state 27
    FOR             shift and go to state 28
    IF              shift and go to state 30

    expression                     shift and go to state 269
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    methodsSet                     shift and go to state 5
    mapFunctions                   shift and go to state 6
    arrayFn                        shift and go to state 7
    declaration                    shift and go to state 8
    return                         shift and go to state 9
    function                       shift and go to state 10
    type                           shift and go to state 11
    array                          shift and go to state 13
    set                            shift and go to state 14
    map                            shift and go to state 15
    while                          shift and go to state 16
    for                            shift and go to state 17
    if                             shift and go to state 18
    iniciarMap                     shift and go to state 24
    escribirMap                    shift and go to state 25
    generarMap                     shift and go to state 26
    soloIf                         shift and go to state 29

state 266

    (30) elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .

    ELSE            reduce using rule 30 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .)
    NAME            reduce using rule 30 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .)
    RETURN          reduce using rule 30 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .)
    FUNCTION        reduce using rule 30 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .)
    CONST           reduce using rule 30 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .)
    LET             reduce using rule 30 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .)
    VAR             reduce using rule 30 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .)
    WHILE           reduce using rule 30 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .)
    FOR             reduce using rule 30 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .)
    IF              reduce using rule 30 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .)
    $end            reduce using rule 30 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .)
    CLOSE_BRACE     reduce using rule 30 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .)


state 267

    (89) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 270


state 268

    (92) set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .

    NAME            reduce using rule 92 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    RETURN          reduce using rule 92 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    FUNCTION        reduce using rule 92 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    CONST           reduce using rule 92 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    LET             reduce using rule 92 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    VAR             reduce using rule 92 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    WHILE           reduce using rule 92 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    FOR             reduce using rule 92 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    IF              reduce using rule 92 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    $end            reduce using rule 92 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 92 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    COMMA           reduce using rule 92 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)


state 269

    (33) for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression . CLOSE_BRACE

    CLOSE_BRACE     shift and go to state 271


state 270

    (89) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .

    NAME            reduce using rule 89 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    RETURN          reduce using rule 89 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    FUNCTION        reduce using rule 89 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    CONST           reduce using rule 89 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    LET             reduce using rule 89 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    VAR             reduce using rule 89 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    WHILE           reduce using rule 89 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    FOR             reduce using rule 89 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    IF              reduce using rule 89 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    $end            reduce using rule 89 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 89 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    COMMA           reduce using rule 89 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)


state 271

    (33) for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .

    NAME            reduce using rule 33 (for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    RETURN          reduce using rule 33 (for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    FUNCTION        reduce using rule 33 (for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CONST           reduce using rule 33 (for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    LET             reduce using rule 33 (for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    VAR             reduce using rule 33 (for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    WHILE           reduce using rule 33 (for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    FOR             reduce using rule 33 (for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    IF              reduce using rule 33 (for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    $end            reduce using rule 33 (for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 33 (for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for AND in state 208 resolved as shift
WARNING: shift/reduce conflict for OR in state 208 resolved as shift
WARNING: shift/reduce conflict for AND in state 244 resolved as shift
WARNING: shift/reduce conflict for OR in state 244 resolved as shift
WARNING: shift/reduce conflict for IF in state 259 resolved as shift
WARNING: reduce/reduce conflict in state 56 resolved using rule (datatype -> NUMBER)
WARNING: rejected rule (element -> NUMBER) in state 56
WARNING: reduce/reduce conflict in state 57 resolved using rule (datatype -> STRING)
WARNING: rejected rule (element -> STRING) in state 57
WARNING: reduce/reduce conflict in state 95 resolved using rule (operations -> NUMBER)
WARNING: rejected rule (datatype -> NUMBER) in state 95
WARNING: reduce/reduce conflict in state 194 resolved using rule (mapFunctions -> NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON)
WARNING: rejected rule (methodsSet -> NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON) in state 194
WARNING: Rule (methodsSet -> NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON) is never reduced
