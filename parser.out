Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BACKSLASH
    BOOLEAN
    BREAK
    CASE
    CLASS
    COMMENTS
    DEFAULT
    DIVIGUAL
    DOUBLE_QUOTES
    FLOAT
    FUNCTION
    INT
    LENGTH
    LINE_BREAK
    LONGCOMMENT
    MASIGUAL
    MENOSIGUAL
    MODIGUAL
    NULL
    PORIGUAL
    POTIGUAL
    RETURN
    SINGLE_QUOTE
    STATIC
    SWITCH
    THEN
    TOSTRING
    TYPEOF
    UNDEFINED

Grammar

Rule 0     S' -> expression
Rule 1     expression -> variable
Rule 2     expression -> variable expression
Rule 3     expression -> dataStruct
Rule 4     expression -> dataStruct expression
Rule 5     expression -> controlStruct
Rule 6     expression -> controlStruct expression
Rule 7     expression -> methodsSet
Rule 8     expression -> mapFunctions
Rule 9     expression -> arrayFn
Rule 10    expression -> declaration
Rule 11    variable -> type NAME IGUAL datatype SEMICOLON
Rule 12    variable -> type NAME IGUAL operations SEMICOLON
Rule 13    variable -> NAME IGUAL datatype SEMICOLON
Rule 14    controlStruct -> while
Rule 15    controlStruct -> for
Rule 16    controlStruct -> if
Rule 17    dataStruct -> array
Rule 18    dataStruct -> set
Rule 19    dataStruct -> map
Rule 20    while -> WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
Rule 21    while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
Rule 22    if -> soloIf
Rule 23    if -> soloIf elseIf
Rule 24    if -> soloIf elseIf else
Rule 25    if -> soloIf else
Rule 26    soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
Rule 27    elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
Rule 28    elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf
Rule 29    else -> ELSE OPEN_BRACE expression CLOSE_BRACE
Rule 30    controlArg -> element clause element
Rule 31    for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
Rule 32    inicialization -> type NAME IGUAL NUMBER
Rule 33    inicialization -> NAME IGUAL NUMBER
Rule 34    operations -> NUMBER operand NUMBER
Rule 35    operations -> NAME
Rule 36    operations -> NUMBER
Rule 37    operations -> NUMBER operand NAME operations
Rule 38    operations -> NAME operand NUMBER operations
Rule 39    operations -> NUMBER operand NAME
Rule 40    operations -> NAME operand NUMBER
Rule 41    operations -> NAME operand NAME operations
Rule 42    operations -> OPEN_PARENTHESIS NAME operand NAME CLOSE_PARENTHESIS operand operations
Rule 43    operations -> OPEN_PARENTHESIS NUMBER operand NUMBER CLOSE_PARENTHESIS operand operations
Rule 44    datatype -> NUMBER
Rule 45    datatype -> STRING
Rule 46    datatype -> CHAR
Rule 47    operand -> SUMA
Rule 48    operand -> RESTA
Rule 49    operand -> MULTIPLICACION
Rule 50    operand -> DIVISION
Rule 51    bool -> TRUE
Rule 52    bool -> FALSE
Rule 53    type -> CONST
Rule 54    type -> LET
Rule 55    type -> VAR
Rule 56    clause -> IGUALIGUAL
Rule 57    clause -> DIFERENTE
Rule 58    clause -> MAYORQUE
Rule 59    clause -> MAYORIGUALQUE
Rule 60    clause -> MENORQUE
Rule 61    clause -> MENORIGUALQUE
Rule 62    value -> NAME
Rule 63    value -> NUMBER
Rule 64    array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
Rule 65    array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
Rule 66    map -> iniciarMap
Rule 67    map -> escribirMap
Rule 68    map -> generarMap
Rule 69    iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
Rule 70    escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
Rule 71    claveValor -> clave COLON valor
Rule 72    claveValor -> clave COLON valor COMMA claveValor
Rule 73    clave -> datatype
Rule 74    valor -> datatype
Rule 75    valor -> dataStruct
Rule 76    generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
Rule 77    tuplas -> tupla
Rule 78    tuplas -> tupla COMMA tuplas
Rule 79    tupla -> OPEN_BRACKET datatype CLOSE_BRACKET
Rule 80    tupla -> OPEN_BRACKET datatype COMMA datatype CLOSE_BRACKET
Rule 81    mapFunctions -> NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
Rule 82    mapFunctions -> NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
Rule 83    mapFunctions -> NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
Rule 84    arrayFn -> NAME POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS
Rule 85    arrayFn -> NAME POINT PUSH OPEN_PARENTHESIS element CLOSE_PARENTHESIS
Rule 86    arrayFn -> NAME POINT UNSHIFT OPEN_PARENTHESIS element CLOSE_PARENTHESIS
Rule 87    set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
Rule 88    set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
Rule 89    set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
Rule 90    set -> NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
Rule 91    set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
Rule 92    set -> NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
Rule 93    methodsSet -> NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
Rule 94    methodsSet -> NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
Rule 95    methodsSet -> NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
Rule 96    items -> numeros
Rule 97    items -> cadena
Rule 98    numeros -> NUMBER
Rule 99    numeros -> NUMBER COMMA numeros
Rule 100   cadena -> STRING
Rule 101   cadena -> STRING COMMA cadena
Rule 102   element -> STRING
Rule 103   element -> NUMBER
Rule 104   element -> NAME
Rule 105   declaration -> NAME IGUAL element SEMICOLON
Rule 106   logicalOperator -> AND
Rule 107   logicalOperator -> OR
Rule 108   expBoolean -> controlArg
Rule 109   expBoolean -> bool
Rule 110   expBoolean -> NOT expBoolean
Rule 111   expBoolean -> expBoolean logicalOperator expBoolean

Terminals, with rules where they appear

ADD                  : 93
AND                  : 106
ARRAY                : 65
BACKSLASH            : 
BOOLEAN              : 
BREAK                : 
CASE                 : 
CHAR                 : 46
CLASS                : 
CLEAR                : 81 95
CLOSE_BRACE          : 20 21 26 27 28 29 31 70 76
CLOSE_BRACKET        : 64 79 80 88 91
CLOSE_PARENTHESIS    : 20 21 26 27 28 31 42 43 65 69 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95
COLON                : 71 72
COMMA                : 72 78 80 99 101
COMMENTS             : 
CONST                : 53
DEFAULT              : 
DELETE               : 94
DIFERENTE            : 57
DIVIGUAL             : 
DIVISION             : 50
DOUBLE_QUOTES        : 
ELSE                 : 29
ELSEIF               : 27 28
FALSE                : 52
FLOAT                : 
FOR                  : 31
FUNCTION             : 
GET                  : 82
HAS                  : 83
IF                   : 26
IGUAL                : 11 12 13 32 33 64 65 69 70 76 87 88 89 90 91 92 105
IGUALIGUAL           : 56
INT                  : 
LENGTH               : 
LET                  : 54
LINE_BREAK           : 
LONGCOMMENT          : 
MAP                  : 69
MASIGUAL             : 
MAYORIGUALQUE        : 59
MAYORQUE             : 58
MENORIGUALQUE        : 61
MENORQUE             : 60
MENOSIGUAL           : 
MODIGUAL             : 
MULTIPLICACION       : 49
NAME                 : 11 12 13 32 33 35 37 38 39 40 41 41 42 42 62 64 65 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 104 105
NEW                  : 65 69 87 88 89 90 91 92
NOT                  : 110
NULL                 : 
NUMBER               : 32 33 34 34 36 37 38 39 40 43 43 44 63 98 99 103
OPEN_BRACE           : 20 21 26 27 28 29 31 70 76
OPEN_BRACKET         : 64 79 80 88 91
OPEN_PARENTHESIS     : 20 21 26 27 28 31 42 43 65 69 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95
OR                   : 107
POINT                : 81 82 83 84 85 86 93 94 95
POP                  : 84
PORIGUAL             : 
POTIGUAL             : 
PUSH                 : 85
RESTA                : 48
RETURN               : 
SEMICOLON            : 11 12 13 31 31 64 65 69 81 82 83 87 88 89 90 91 92 93 94 95 105
SET                  : 87 88 89 90 91 92
SINGLE_QUOTE         : 
STATIC               : 
STRING               : 45 100 101 102
SUMA                 : 47
SWITCH               : 
THEN                 : 
TOSTRING             : 
TRUE                 : 51
TYPEOF               : 
UNDEFINED            : 
UNSHIFT              : 86
VAR                  : 55
WHILE                : 20 21
error                : 

Nonterminals, with rules where they appear

array                : 17
arrayFn              : 9
bool                 : 21 109
cadena               : 97 101
clause               : 30
clave                : 71 72 82 83
claveValor           : 70 72
controlArg           : 20 26 27 28 108
controlStruct        : 5 6
dataStruct           : 3 4 75
datatype             : 11 13 73 74 79 80 80
declaration          : 10
element              : 30 30 85 86 89 92 93 94 105
else                 : 24 25
elseIf               : 23 24
escribirMap          : 67
expBoolean           : 31 110 111 111
expression           : 2 4 6 20 21 26 27 28 29 31 0
for                  : 15
generarMap           : 68
if                   : 16
inicialization       : 31
iniciarMap           : 66
items                : 64 65 88 91
logicalOperator      : 111
map                  : 19
mapFunctions         : 8
methodsSet           : 7
numeros              : 96 99
operand              : 34 37 38 39 40 41 42 42 43 43
operations           : 12 31 37 38 41 42 43
set                  : 18
soloIf               : 22 23 24 25 28
tupla                : 77 78
tuplas               : 76 78
type                 : 11 12 32 64 65 87 88 89
valor                : 71 72
value                : 
variable             : 1 2 69 70 76
while                : 14

Parsing method: LALR

state 0

    (0) S' -> . expression
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) expression -> . methodsSet
    (8) expression -> . mapFunctions
    (9) expression -> . arrayFn
    (10) expression -> . declaration
    (11) variable -> . type NAME IGUAL datatype SEMICOLON
    (12) variable -> . type NAME IGUAL operations SEMICOLON
    (13) variable -> . NAME IGUAL datatype SEMICOLON
    (17) dataStruct -> . array
    (18) dataStruct -> . set
    (19) dataStruct -> . map
    (14) controlStruct -> . while
    (15) controlStruct -> . for
    (16) controlStruct -> . if
    (93) methodsSet -> . NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (94) methodsSet -> . NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (95) methodsSet -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (81) mapFunctions -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (82) mapFunctions -> . NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (83) mapFunctions -> . NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (84) arrayFn -> . NAME POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS
    (85) arrayFn -> . NAME POINT PUSH OPEN_PARENTHESIS element CLOSE_PARENTHESIS
    (86) arrayFn -> . NAME POINT UNSHIFT OPEN_PARENTHESIS element CLOSE_PARENTHESIS
    (105) declaration -> . NAME IGUAL element SEMICOLON
    (53) type -> . CONST
    (54) type -> . LET
    (55) type -> . VAR
    (64) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (65) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (87) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (88) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (89) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (90) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (91) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (92) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (66) map -> . iniciarMap
    (67) map -> . escribirMap
    (68) map -> . generarMap
    (20) while -> . WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (21) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (31) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (22) if -> . soloIf
    (23) if -> . soloIf elseIf
    (24) if -> . soloIf elseIf else
    (25) if -> . soloIf else
    (69) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (70) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (76) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (26) soloIf -> . IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    NAME            shift and go to state 10
    CONST           shift and go to state 17
    LET             shift and go to state 18
    VAR             shift and go to state 19
    WHILE           shift and go to state 23
    FOR             shift and go to state 24
    IF              shift and go to state 26

    expression                     shift and go to state 1
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    methodsSet                     shift and go to state 5
    mapFunctions                   shift and go to state 6
    arrayFn                        shift and go to state 7
    declaration                    shift and go to state 8
    type                           shift and go to state 9
    array                          shift and go to state 11
    set                            shift and go to state 12
    map                            shift and go to state 13
    while                          shift and go to state 14
    for                            shift and go to state 15
    if                             shift and go to state 16
    iniciarMap                     shift and go to state 20
    escribirMap                    shift and go to state 21
    generarMap                     shift and go to state 22
    soloIf                         shift and go to state 25

state 1

    (0) S' -> expression .



state 2

    (1) expression -> variable .
    (2) expression -> variable . expression
    (69) iniciarMap -> variable . IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (70) escribirMap -> variable . IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (76) generarMap -> variable . IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) expression -> . methodsSet
    (8) expression -> . mapFunctions
    (9) expression -> . arrayFn
    (10) expression -> . declaration
    (11) variable -> . type NAME IGUAL datatype SEMICOLON
    (12) variable -> . type NAME IGUAL operations SEMICOLON
    (13) variable -> . NAME IGUAL datatype SEMICOLON
    (17) dataStruct -> . array
    (18) dataStruct -> . set
    (19) dataStruct -> . map
    (14) controlStruct -> . while
    (15) controlStruct -> . for
    (16) controlStruct -> . if
    (93) methodsSet -> . NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (94) methodsSet -> . NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (95) methodsSet -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (81) mapFunctions -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (82) mapFunctions -> . NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (83) mapFunctions -> . NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (84) arrayFn -> . NAME POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS
    (85) arrayFn -> . NAME POINT PUSH OPEN_PARENTHESIS element CLOSE_PARENTHESIS
    (86) arrayFn -> . NAME POINT UNSHIFT OPEN_PARENTHESIS element CLOSE_PARENTHESIS
    (105) declaration -> . NAME IGUAL element SEMICOLON
    (53) type -> . CONST
    (54) type -> . LET
    (55) type -> . VAR
    (64) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (65) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (87) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (88) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (89) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (90) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (91) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (92) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (66) map -> . iniciarMap
    (67) map -> . escribirMap
    (68) map -> . generarMap
    (20) while -> . WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (21) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (31) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (22) if -> . soloIf
    (23) if -> . soloIf elseIf
    (24) if -> . soloIf elseIf else
    (25) if -> . soloIf else
    (69) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (70) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (76) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (26) soloIf -> . IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    $end            reduce using rule 1 (expression -> variable .)
    CLOSE_BRACE     reduce using rule 1 (expression -> variable .)
    IGUAL           shift and go to state 28
    NAME            shift and go to state 10
    CONST           shift and go to state 17
    LET             shift and go to state 18
    VAR             shift and go to state 19
    WHILE           shift and go to state 23
    FOR             shift and go to state 24
    IF              shift and go to state 26

    variable                       shift and go to state 2
    expression                     shift and go to state 27
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    methodsSet                     shift and go to state 5
    mapFunctions                   shift and go to state 6
    arrayFn                        shift and go to state 7
    declaration                    shift and go to state 8
    type                           shift and go to state 9
    array                          shift and go to state 11
    set                            shift and go to state 12
    map                            shift and go to state 13
    while                          shift and go to state 14
    for                            shift and go to state 15
    if                             shift and go to state 16
    iniciarMap                     shift and go to state 20
    escribirMap                    shift and go to state 21
    generarMap                     shift and go to state 22
    soloIf                         shift and go to state 25

state 3

    (3) expression -> dataStruct .
    (4) expression -> dataStruct . expression
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) expression -> . methodsSet
    (8) expression -> . mapFunctions
    (9) expression -> . arrayFn
    (10) expression -> . declaration
    (11) variable -> . type NAME IGUAL datatype SEMICOLON
    (12) variable -> . type NAME IGUAL operations SEMICOLON
    (13) variable -> . NAME IGUAL datatype SEMICOLON
    (17) dataStruct -> . array
    (18) dataStruct -> . set
    (19) dataStruct -> . map
    (14) controlStruct -> . while
    (15) controlStruct -> . for
    (16) controlStruct -> . if
    (93) methodsSet -> . NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (94) methodsSet -> . NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (95) methodsSet -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (81) mapFunctions -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (82) mapFunctions -> . NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (83) mapFunctions -> . NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (84) arrayFn -> . NAME POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS
    (85) arrayFn -> . NAME POINT PUSH OPEN_PARENTHESIS element CLOSE_PARENTHESIS
    (86) arrayFn -> . NAME POINT UNSHIFT OPEN_PARENTHESIS element CLOSE_PARENTHESIS
    (105) declaration -> . NAME IGUAL element SEMICOLON
    (53) type -> . CONST
    (54) type -> . LET
    (55) type -> . VAR
    (64) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (65) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (87) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (88) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (89) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (90) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (91) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (92) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (66) map -> . iniciarMap
    (67) map -> . escribirMap
    (68) map -> . generarMap
    (20) while -> . WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (21) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (31) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (22) if -> . soloIf
    (23) if -> . soloIf elseIf
    (24) if -> . soloIf elseIf else
    (25) if -> . soloIf else
    (69) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (70) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (76) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (26) soloIf -> . IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    $end            reduce using rule 3 (expression -> dataStruct .)
    CLOSE_BRACE     reduce using rule 3 (expression -> dataStruct .)
    NAME            shift and go to state 10
    CONST           shift and go to state 17
    LET             shift and go to state 18
    VAR             shift and go to state 19
    WHILE           shift and go to state 23
    FOR             shift and go to state 24
    IF              shift and go to state 26

    dataStruct                     shift and go to state 3
    expression                     shift and go to state 29
    variable                       shift and go to state 2
    controlStruct                  shift and go to state 4
    methodsSet                     shift and go to state 5
    mapFunctions                   shift and go to state 6
    arrayFn                        shift and go to state 7
    declaration                    shift and go to state 8
    type                           shift and go to state 9
    array                          shift and go to state 11
    set                            shift and go to state 12
    map                            shift and go to state 13
    while                          shift and go to state 14
    for                            shift and go to state 15
    if                             shift and go to state 16
    iniciarMap                     shift and go to state 20
    escribirMap                    shift and go to state 21
    generarMap                     shift and go to state 22
    soloIf                         shift and go to state 25

state 4

    (5) expression -> controlStruct .
    (6) expression -> controlStruct . expression
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) expression -> . methodsSet
    (8) expression -> . mapFunctions
    (9) expression -> . arrayFn
    (10) expression -> . declaration
    (11) variable -> . type NAME IGUAL datatype SEMICOLON
    (12) variable -> . type NAME IGUAL operations SEMICOLON
    (13) variable -> . NAME IGUAL datatype SEMICOLON
    (17) dataStruct -> . array
    (18) dataStruct -> . set
    (19) dataStruct -> . map
    (14) controlStruct -> . while
    (15) controlStruct -> . for
    (16) controlStruct -> . if
    (93) methodsSet -> . NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (94) methodsSet -> . NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (95) methodsSet -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (81) mapFunctions -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (82) mapFunctions -> . NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (83) mapFunctions -> . NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (84) arrayFn -> . NAME POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS
    (85) arrayFn -> . NAME POINT PUSH OPEN_PARENTHESIS element CLOSE_PARENTHESIS
    (86) arrayFn -> . NAME POINT UNSHIFT OPEN_PARENTHESIS element CLOSE_PARENTHESIS
    (105) declaration -> . NAME IGUAL element SEMICOLON
    (53) type -> . CONST
    (54) type -> . LET
    (55) type -> . VAR
    (64) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (65) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (87) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (88) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (89) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (90) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (91) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (92) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (66) map -> . iniciarMap
    (67) map -> . escribirMap
    (68) map -> . generarMap
    (20) while -> . WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (21) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (31) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (22) if -> . soloIf
    (23) if -> . soloIf elseIf
    (24) if -> . soloIf elseIf else
    (25) if -> . soloIf else
    (69) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (70) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (76) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (26) soloIf -> . IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    $end            reduce using rule 5 (expression -> controlStruct .)
    CLOSE_BRACE     reduce using rule 5 (expression -> controlStruct .)
    NAME            shift and go to state 10
    CONST           shift and go to state 17
    LET             shift and go to state 18
    VAR             shift and go to state 19
    WHILE           shift and go to state 23
    FOR             shift and go to state 24
    IF              shift and go to state 26

    controlStruct                  shift and go to state 4
    expression                     shift and go to state 30
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    methodsSet                     shift and go to state 5
    mapFunctions                   shift and go to state 6
    arrayFn                        shift and go to state 7
    declaration                    shift and go to state 8
    type                           shift and go to state 9
    array                          shift and go to state 11
    set                            shift and go to state 12
    map                            shift and go to state 13
    while                          shift and go to state 14
    for                            shift and go to state 15
    if                             shift and go to state 16
    iniciarMap                     shift and go to state 20
    escribirMap                    shift and go to state 21
    generarMap                     shift and go to state 22
    soloIf                         shift and go to state 25

state 5

    (7) expression -> methodsSet .

    $end            reduce using rule 7 (expression -> methodsSet .)
    CLOSE_BRACE     reduce using rule 7 (expression -> methodsSet .)


state 6

    (8) expression -> mapFunctions .

    $end            reduce using rule 8 (expression -> mapFunctions .)
    CLOSE_BRACE     reduce using rule 8 (expression -> mapFunctions .)


state 7

    (9) expression -> arrayFn .

    $end            reduce using rule 9 (expression -> arrayFn .)
    CLOSE_BRACE     reduce using rule 9 (expression -> arrayFn .)


state 8

    (10) expression -> declaration .

    $end            reduce using rule 10 (expression -> declaration .)
    CLOSE_BRACE     reduce using rule 10 (expression -> declaration .)


state 9

    (11) variable -> type . NAME IGUAL datatype SEMICOLON
    (12) variable -> type . NAME IGUAL operations SEMICOLON
    (64) array -> type . NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (65) array -> type . NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (87) set -> type . NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (88) set -> type . NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (89) set -> type . NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON

    NAME            shift and go to state 31


state 10

    (13) variable -> NAME . IGUAL datatype SEMICOLON
    (93) methodsSet -> NAME . POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (94) methodsSet -> NAME . POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (95) methodsSet -> NAME . POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (81) mapFunctions -> NAME . POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (82) mapFunctions -> NAME . POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (83) mapFunctions -> NAME . POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (84) arrayFn -> NAME . POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS
    (85) arrayFn -> NAME . POINT PUSH OPEN_PARENTHESIS element CLOSE_PARENTHESIS
    (86) arrayFn -> NAME . POINT UNSHIFT OPEN_PARENTHESIS element CLOSE_PARENTHESIS
    (105) declaration -> NAME . IGUAL element SEMICOLON
    (90) set -> NAME . IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (91) set -> NAME . IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (92) set -> NAME . IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON

    IGUAL           shift and go to state 32
    POINT           shift and go to state 33


state 11

    (17) dataStruct -> array .

    NAME            reduce using rule 17 (dataStruct -> array .)
    CONST           reduce using rule 17 (dataStruct -> array .)
    LET             reduce using rule 17 (dataStruct -> array .)
    VAR             reduce using rule 17 (dataStruct -> array .)
    WHILE           reduce using rule 17 (dataStruct -> array .)
    FOR             reduce using rule 17 (dataStruct -> array .)
    IF              reduce using rule 17 (dataStruct -> array .)
    $end            reduce using rule 17 (dataStruct -> array .)
    CLOSE_BRACE     reduce using rule 17 (dataStruct -> array .)
    COMMA           reduce using rule 17 (dataStruct -> array .)


state 12

    (18) dataStruct -> set .

    NAME            reduce using rule 18 (dataStruct -> set .)
    CONST           reduce using rule 18 (dataStruct -> set .)
    LET             reduce using rule 18 (dataStruct -> set .)
    VAR             reduce using rule 18 (dataStruct -> set .)
    WHILE           reduce using rule 18 (dataStruct -> set .)
    FOR             reduce using rule 18 (dataStruct -> set .)
    IF              reduce using rule 18 (dataStruct -> set .)
    $end            reduce using rule 18 (dataStruct -> set .)
    CLOSE_BRACE     reduce using rule 18 (dataStruct -> set .)
    COMMA           reduce using rule 18 (dataStruct -> set .)


state 13

    (19) dataStruct -> map .

    NAME            reduce using rule 19 (dataStruct -> map .)
    CONST           reduce using rule 19 (dataStruct -> map .)
    LET             reduce using rule 19 (dataStruct -> map .)
    VAR             reduce using rule 19 (dataStruct -> map .)
    WHILE           reduce using rule 19 (dataStruct -> map .)
    FOR             reduce using rule 19 (dataStruct -> map .)
    IF              reduce using rule 19 (dataStruct -> map .)
    $end            reduce using rule 19 (dataStruct -> map .)
    CLOSE_BRACE     reduce using rule 19 (dataStruct -> map .)
    COMMA           reduce using rule 19 (dataStruct -> map .)


state 14

    (14) controlStruct -> while .

    NAME            reduce using rule 14 (controlStruct -> while .)
    CONST           reduce using rule 14 (controlStruct -> while .)
    LET             reduce using rule 14 (controlStruct -> while .)
    VAR             reduce using rule 14 (controlStruct -> while .)
    WHILE           reduce using rule 14 (controlStruct -> while .)
    FOR             reduce using rule 14 (controlStruct -> while .)
    IF              reduce using rule 14 (controlStruct -> while .)
    $end            reduce using rule 14 (controlStruct -> while .)
    CLOSE_BRACE     reduce using rule 14 (controlStruct -> while .)


state 15

    (15) controlStruct -> for .

    NAME            reduce using rule 15 (controlStruct -> for .)
    CONST           reduce using rule 15 (controlStruct -> for .)
    LET             reduce using rule 15 (controlStruct -> for .)
    VAR             reduce using rule 15 (controlStruct -> for .)
    WHILE           reduce using rule 15 (controlStruct -> for .)
    FOR             reduce using rule 15 (controlStruct -> for .)
    IF              reduce using rule 15 (controlStruct -> for .)
    $end            reduce using rule 15 (controlStruct -> for .)
    CLOSE_BRACE     reduce using rule 15 (controlStruct -> for .)


state 16

    (16) controlStruct -> if .

    NAME            reduce using rule 16 (controlStruct -> if .)
    CONST           reduce using rule 16 (controlStruct -> if .)
    LET             reduce using rule 16 (controlStruct -> if .)
    VAR             reduce using rule 16 (controlStruct -> if .)
    WHILE           reduce using rule 16 (controlStruct -> if .)
    FOR             reduce using rule 16 (controlStruct -> if .)
    IF              reduce using rule 16 (controlStruct -> if .)
    $end            reduce using rule 16 (controlStruct -> if .)
    CLOSE_BRACE     reduce using rule 16 (controlStruct -> if .)


state 17

    (53) type -> CONST .

    NAME            reduce using rule 53 (type -> CONST .)


state 18

    (54) type -> LET .

    NAME            reduce using rule 54 (type -> LET .)


state 19

    (55) type -> VAR .

    NAME            reduce using rule 55 (type -> VAR .)


state 20

    (66) map -> iniciarMap .

    NAME            reduce using rule 66 (map -> iniciarMap .)
    CONST           reduce using rule 66 (map -> iniciarMap .)
    LET             reduce using rule 66 (map -> iniciarMap .)
    VAR             reduce using rule 66 (map -> iniciarMap .)
    WHILE           reduce using rule 66 (map -> iniciarMap .)
    FOR             reduce using rule 66 (map -> iniciarMap .)
    IF              reduce using rule 66 (map -> iniciarMap .)
    $end            reduce using rule 66 (map -> iniciarMap .)
    CLOSE_BRACE     reduce using rule 66 (map -> iniciarMap .)
    COMMA           reduce using rule 66 (map -> iniciarMap .)


state 21

    (67) map -> escribirMap .

    NAME            reduce using rule 67 (map -> escribirMap .)
    CONST           reduce using rule 67 (map -> escribirMap .)
    LET             reduce using rule 67 (map -> escribirMap .)
    VAR             reduce using rule 67 (map -> escribirMap .)
    WHILE           reduce using rule 67 (map -> escribirMap .)
    FOR             reduce using rule 67 (map -> escribirMap .)
    IF              reduce using rule 67 (map -> escribirMap .)
    $end            reduce using rule 67 (map -> escribirMap .)
    CLOSE_BRACE     reduce using rule 67 (map -> escribirMap .)
    COMMA           reduce using rule 67 (map -> escribirMap .)


state 22

    (68) map -> generarMap .

    NAME            reduce using rule 68 (map -> generarMap .)
    CONST           reduce using rule 68 (map -> generarMap .)
    LET             reduce using rule 68 (map -> generarMap .)
    VAR             reduce using rule 68 (map -> generarMap .)
    WHILE           reduce using rule 68 (map -> generarMap .)
    FOR             reduce using rule 68 (map -> generarMap .)
    IF              reduce using rule 68 (map -> generarMap .)
    $end            reduce using rule 68 (map -> generarMap .)
    CLOSE_BRACE     reduce using rule 68 (map -> generarMap .)
    COMMA           reduce using rule 68 (map -> generarMap .)


state 23

    (20) while -> WHILE . OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (21) while -> WHILE . OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    OPEN_PARENTHESIS shift and go to state 34


state 24

    (31) for -> FOR . OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    OPEN_PARENTHESIS shift and go to state 35


state 25

    (22) if -> soloIf .
    (23) if -> soloIf . elseIf
    (24) if -> soloIf . elseIf else
    (25) if -> soloIf . else
    (27) elseIf -> . ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (28) elseIf -> . ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf
    (29) else -> . ELSE OPEN_BRACE expression CLOSE_BRACE

    NAME            reduce using rule 22 (if -> soloIf .)
    CONST           reduce using rule 22 (if -> soloIf .)
    LET             reduce using rule 22 (if -> soloIf .)
    VAR             reduce using rule 22 (if -> soloIf .)
    WHILE           reduce using rule 22 (if -> soloIf .)
    FOR             reduce using rule 22 (if -> soloIf .)
    IF              reduce using rule 22 (if -> soloIf .)
    $end            reduce using rule 22 (if -> soloIf .)
    CLOSE_BRACE     reduce using rule 22 (if -> soloIf .)
    ELSEIF          shift and go to state 38
    ELSE            shift and go to state 39

    elseIf                         shift and go to state 36
    else                           shift and go to state 37

state 26

    (26) soloIf -> IF . OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    OPEN_PARENTHESIS shift and go to state 40


state 27

    (2) expression -> variable expression .

    $end            reduce using rule 2 (expression -> variable expression .)
    CLOSE_BRACE     reduce using rule 2 (expression -> variable expression .)


state 28

    (69) iniciarMap -> variable IGUAL . NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (70) escribirMap -> variable IGUAL . OPEN_BRACE claveValor CLOSE_BRACE
    (76) generarMap -> variable IGUAL . OPEN_BRACE tuplas CLOSE_BRACE

    NEW             shift and go to state 41
    OPEN_BRACE      shift and go to state 42


state 29

    (4) expression -> dataStruct expression .

    $end            reduce using rule 4 (expression -> dataStruct expression .)
    CLOSE_BRACE     reduce using rule 4 (expression -> dataStruct expression .)


state 30

    (6) expression -> controlStruct expression .

    $end            reduce using rule 6 (expression -> controlStruct expression .)
    CLOSE_BRACE     reduce using rule 6 (expression -> controlStruct expression .)


state 31

    (11) variable -> type NAME . IGUAL datatype SEMICOLON
    (12) variable -> type NAME . IGUAL operations SEMICOLON
    (64) array -> type NAME . IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (65) array -> type NAME . IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (87) set -> type NAME . IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (88) set -> type NAME . IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (89) set -> type NAME . IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON

    IGUAL           shift and go to state 43


state 32

    (13) variable -> NAME IGUAL . datatype SEMICOLON
    (105) declaration -> NAME IGUAL . element SEMICOLON
    (90) set -> NAME IGUAL . NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (91) set -> NAME IGUAL . NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (92) set -> NAME IGUAL . NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (44) datatype -> . NUMBER
    (45) datatype -> . STRING
    (46) datatype -> . CHAR
    (102) element -> . STRING
    (103) element -> . NUMBER
    (104) element -> . NAME

    NEW             shift and go to state 47
    NUMBER          shift and go to state 48
    STRING          shift and go to state 49
    CHAR            shift and go to state 50
    NAME            shift and go to state 44

    datatype                       shift and go to state 45
    element                        shift and go to state 46

state 33

    (93) methodsSet -> NAME POINT . ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (94) methodsSet -> NAME POINT . DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (95) methodsSet -> NAME POINT . CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (81) mapFunctions -> NAME POINT . CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (82) mapFunctions -> NAME POINT . GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (83) mapFunctions -> NAME POINT . HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (84) arrayFn -> NAME POINT . POP OPEN_PARENTHESIS CLOSE_PARENTHESIS
    (85) arrayFn -> NAME POINT . PUSH OPEN_PARENTHESIS element CLOSE_PARENTHESIS
    (86) arrayFn -> NAME POINT . UNSHIFT OPEN_PARENTHESIS element CLOSE_PARENTHESIS

    ADD             shift and go to state 51
    DELETE          shift and go to state 52
    CLEAR           shift and go to state 53
    GET             shift and go to state 54
    HAS             shift and go to state 55
    POP             shift and go to state 56
    PUSH            shift and go to state 57
    UNSHIFT         shift and go to state 58


state 34

    (20) while -> WHILE OPEN_PARENTHESIS . controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (21) while -> WHILE OPEN_PARENTHESIS . bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (30) controlArg -> . element clause element
    (51) bool -> . TRUE
    (52) bool -> . FALSE
    (102) element -> . STRING
    (103) element -> . NUMBER
    (104) element -> . NAME

    TRUE            shift and go to state 62
    FALSE           shift and go to state 63
    STRING          shift and go to state 64
    NUMBER          shift and go to state 65
    NAME            shift and go to state 44

    controlArg                     shift and go to state 59
    bool                           shift and go to state 60
    element                        shift and go to state 61

state 35

    (31) for -> FOR OPEN_PARENTHESIS . inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (32) inicialization -> . type NAME IGUAL NUMBER
    (33) inicialization -> . NAME IGUAL NUMBER
    (53) type -> . CONST
    (54) type -> . LET
    (55) type -> . VAR

    NAME            shift and go to state 68
    CONST           shift and go to state 17
    LET             shift and go to state 18
    VAR             shift and go to state 19

    inicialization                 shift and go to state 66
    type                           shift and go to state 67

state 36

    (23) if -> soloIf elseIf .
    (24) if -> soloIf elseIf . else
    (29) else -> . ELSE OPEN_BRACE expression CLOSE_BRACE

    NAME            reduce using rule 23 (if -> soloIf elseIf .)
    CONST           reduce using rule 23 (if -> soloIf elseIf .)
    LET             reduce using rule 23 (if -> soloIf elseIf .)
    VAR             reduce using rule 23 (if -> soloIf elseIf .)
    WHILE           reduce using rule 23 (if -> soloIf elseIf .)
    FOR             reduce using rule 23 (if -> soloIf elseIf .)
    IF              reduce using rule 23 (if -> soloIf elseIf .)
    $end            reduce using rule 23 (if -> soloIf elseIf .)
    CLOSE_BRACE     reduce using rule 23 (if -> soloIf elseIf .)
    ELSE            shift and go to state 39

    else                           shift and go to state 69

state 37

    (25) if -> soloIf else .

    NAME            reduce using rule 25 (if -> soloIf else .)
    CONST           reduce using rule 25 (if -> soloIf else .)
    LET             reduce using rule 25 (if -> soloIf else .)
    VAR             reduce using rule 25 (if -> soloIf else .)
    WHILE           reduce using rule 25 (if -> soloIf else .)
    FOR             reduce using rule 25 (if -> soloIf else .)
    IF              reduce using rule 25 (if -> soloIf else .)
    $end            reduce using rule 25 (if -> soloIf else .)
    CLOSE_BRACE     reduce using rule 25 (if -> soloIf else .)


state 38

    (27) elseIf -> ELSEIF . OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (28) elseIf -> ELSEIF . OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf

    OPEN_PARENTHESIS shift and go to state 70


state 39

    (29) else -> ELSE . OPEN_BRACE expression CLOSE_BRACE

    OPEN_BRACE      shift and go to state 71


state 40

    (26) soloIf -> IF OPEN_PARENTHESIS . controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (30) controlArg -> . element clause element
    (102) element -> . STRING
    (103) element -> . NUMBER
    (104) element -> . NAME

    STRING          shift and go to state 64
    NUMBER          shift and go to state 65
    NAME            shift and go to state 44

    controlArg                     shift and go to state 72
    element                        shift and go to state 61

state 41

    (69) iniciarMap -> variable IGUAL NEW . MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON

    MAP             shift and go to state 73


state 42

    (70) escribirMap -> variable IGUAL OPEN_BRACE . claveValor CLOSE_BRACE
    (76) generarMap -> variable IGUAL OPEN_BRACE . tuplas CLOSE_BRACE
    (71) claveValor -> . clave COLON valor
    (72) claveValor -> . clave COLON valor COMMA claveValor
    (77) tuplas -> . tupla
    (78) tuplas -> . tupla COMMA tuplas
    (73) clave -> . datatype
    (79) tupla -> . OPEN_BRACKET datatype CLOSE_BRACKET
    (80) tupla -> . OPEN_BRACKET datatype COMMA datatype CLOSE_BRACKET
    (44) datatype -> . NUMBER
    (45) datatype -> . STRING
    (46) datatype -> . CHAR

    OPEN_BRACKET    shift and go to state 79
    NUMBER          shift and go to state 80
    STRING          shift and go to state 81
    CHAR            shift and go to state 50

    claveValor                     shift and go to state 74
    tuplas                         shift and go to state 75
    clave                          shift and go to state 76
    tupla                          shift and go to state 77
    datatype                       shift and go to state 78

state 43

    (11) variable -> type NAME IGUAL . datatype SEMICOLON
    (12) variable -> type NAME IGUAL . operations SEMICOLON
    (64) array -> type NAME IGUAL . OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (65) array -> type NAME IGUAL . NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (87) set -> type NAME IGUAL . NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (88) set -> type NAME IGUAL . NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (89) set -> type NAME IGUAL . NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (44) datatype -> . NUMBER
    (45) datatype -> . STRING
    (46) datatype -> . CHAR
    (34) operations -> . NUMBER operand NUMBER
    (35) operations -> . NAME
    (36) operations -> . NUMBER
    (37) operations -> . NUMBER operand NAME operations
    (38) operations -> . NAME operand NUMBER operations
    (39) operations -> . NUMBER operand NAME
    (40) operations -> . NAME operand NUMBER
    (41) operations -> . NAME operand NAME operations
    (42) operations -> . OPEN_PARENTHESIS NAME operand NAME CLOSE_PARENTHESIS operand operations
    (43) operations -> . OPEN_PARENTHESIS NUMBER operand NUMBER CLOSE_PARENTHESIS operand operations

    OPEN_BRACKET    shift and go to state 85
    NEW             shift and go to state 86
    NUMBER          shift and go to state 88
    STRING          shift and go to state 81
    CHAR            shift and go to state 50
    NAME            shift and go to state 82
    OPEN_PARENTHESIS shift and go to state 87

    datatype                       shift and go to state 83
    operations                     shift and go to state 84

state 44

    (104) element -> NAME .

    SEMICOLON       reduce using rule 104 (element -> NAME .)
    IGUALIGUAL      reduce using rule 104 (element -> NAME .)
    DIFERENTE       reduce using rule 104 (element -> NAME .)
    MAYORQUE        reduce using rule 104 (element -> NAME .)
    MAYORIGUALQUE   reduce using rule 104 (element -> NAME .)
    MENORQUE        reduce using rule 104 (element -> NAME .)
    MENORIGUALQUE   reduce using rule 104 (element -> NAME .)
    CLOSE_PARENTHESIS reduce using rule 104 (element -> NAME .)
    AND             reduce using rule 104 (element -> NAME .)
    OR              reduce using rule 104 (element -> NAME .)


state 45

    (13) variable -> NAME IGUAL datatype . SEMICOLON

    SEMICOLON       shift and go to state 89


state 46

    (105) declaration -> NAME IGUAL element . SEMICOLON

    SEMICOLON       shift and go to state 90


state 47

    (90) set -> NAME IGUAL NEW . SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (91) set -> NAME IGUAL NEW . SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (92) set -> NAME IGUAL NEW . SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON

    SET             shift and go to state 91


state 48

    (44) datatype -> NUMBER .
    (103) element -> NUMBER .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 44 (datatype -> NUMBER .)
    SEMICOLON       reduce using rule 44 (datatype -> NUMBER .)

  ! SEMICOLON       [ reduce using rule 103 (element -> NUMBER .) ]


state 49

    (45) datatype -> STRING .
    (102) element -> STRING .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 45 (datatype -> STRING .)
    SEMICOLON       reduce using rule 45 (datatype -> STRING .)

  ! SEMICOLON       [ reduce using rule 102 (element -> STRING .) ]


state 50

    (46) datatype -> CHAR .

    SEMICOLON       reduce using rule 46 (datatype -> CHAR .)
    COLON           reduce using rule 46 (datatype -> CHAR .)
    CLOSE_BRACKET   reduce using rule 46 (datatype -> CHAR .)
    COMMA           reduce using rule 46 (datatype -> CHAR .)
    CLOSE_PARENTHESIS reduce using rule 46 (datatype -> CHAR .)
    CLOSE_BRACE     reduce using rule 46 (datatype -> CHAR .)


state 51

    (93) methodsSet -> NAME POINT ADD . OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON

    OPEN_PARENTHESIS shift and go to state 92


state 52

    (94) methodsSet -> NAME POINT DELETE . OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON

    OPEN_PARENTHESIS shift and go to state 93


state 53

    (95) methodsSet -> NAME POINT CLEAR . OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (81) mapFunctions -> NAME POINT CLEAR . OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON

    OPEN_PARENTHESIS shift and go to state 94


state 54

    (82) mapFunctions -> NAME POINT GET . OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON

    OPEN_PARENTHESIS shift and go to state 95


state 55

    (83) mapFunctions -> NAME POINT HAS . OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON

    OPEN_PARENTHESIS shift and go to state 96


state 56

    (84) arrayFn -> NAME POINT POP . OPEN_PARENTHESIS CLOSE_PARENTHESIS

    OPEN_PARENTHESIS shift and go to state 97


state 57

    (85) arrayFn -> NAME POINT PUSH . OPEN_PARENTHESIS element CLOSE_PARENTHESIS

    OPEN_PARENTHESIS shift and go to state 98


state 58

    (86) arrayFn -> NAME POINT UNSHIFT . OPEN_PARENTHESIS element CLOSE_PARENTHESIS

    OPEN_PARENTHESIS shift and go to state 99


state 59

    (20) while -> WHILE OPEN_PARENTHESIS controlArg . CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    CLOSE_PARENTHESIS shift and go to state 100


state 60

    (21) while -> WHILE OPEN_PARENTHESIS bool . CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    CLOSE_PARENTHESIS shift and go to state 101


state 61

    (30) controlArg -> element . clause element
    (56) clause -> . IGUALIGUAL
    (57) clause -> . DIFERENTE
    (58) clause -> . MAYORQUE
    (59) clause -> . MAYORIGUALQUE
    (60) clause -> . MENORQUE
    (61) clause -> . MENORIGUALQUE

    IGUALIGUAL      shift and go to state 103
    DIFERENTE       shift and go to state 104
    MAYORQUE        shift and go to state 105
    MAYORIGUALQUE   shift and go to state 106
    MENORQUE        shift and go to state 107
    MENORIGUALQUE   shift and go to state 108

    clause                         shift and go to state 102

state 62

    (51) bool -> TRUE .

    CLOSE_PARENTHESIS reduce using rule 51 (bool -> TRUE .)
    SEMICOLON       reduce using rule 51 (bool -> TRUE .)
    AND             reduce using rule 51 (bool -> TRUE .)
    OR              reduce using rule 51 (bool -> TRUE .)


state 63

    (52) bool -> FALSE .

    CLOSE_PARENTHESIS reduce using rule 52 (bool -> FALSE .)
    SEMICOLON       reduce using rule 52 (bool -> FALSE .)
    AND             reduce using rule 52 (bool -> FALSE .)
    OR              reduce using rule 52 (bool -> FALSE .)


state 64

    (102) element -> STRING .

    IGUALIGUAL      reduce using rule 102 (element -> STRING .)
    DIFERENTE       reduce using rule 102 (element -> STRING .)
    MAYORQUE        reduce using rule 102 (element -> STRING .)
    MAYORIGUALQUE   reduce using rule 102 (element -> STRING .)
    MENORQUE        reduce using rule 102 (element -> STRING .)
    MENORIGUALQUE   reduce using rule 102 (element -> STRING .)
    CLOSE_PARENTHESIS reduce using rule 102 (element -> STRING .)
    SEMICOLON       reduce using rule 102 (element -> STRING .)
    AND             reduce using rule 102 (element -> STRING .)
    OR              reduce using rule 102 (element -> STRING .)


state 65

    (103) element -> NUMBER .

    IGUALIGUAL      reduce using rule 103 (element -> NUMBER .)
    DIFERENTE       reduce using rule 103 (element -> NUMBER .)
    MAYORQUE        reduce using rule 103 (element -> NUMBER .)
    MAYORIGUALQUE   reduce using rule 103 (element -> NUMBER .)
    MENORQUE        reduce using rule 103 (element -> NUMBER .)
    MENORIGUALQUE   reduce using rule 103 (element -> NUMBER .)
    CLOSE_PARENTHESIS reduce using rule 103 (element -> NUMBER .)
    SEMICOLON       reduce using rule 103 (element -> NUMBER .)
    AND             reduce using rule 103 (element -> NUMBER .)
    OR              reduce using rule 103 (element -> NUMBER .)


state 66

    (31) for -> FOR OPEN_PARENTHESIS inicialization . SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    SEMICOLON       shift and go to state 109


state 67

    (32) inicialization -> type . NAME IGUAL NUMBER

    NAME            shift and go to state 110


state 68

    (33) inicialization -> NAME . IGUAL NUMBER

    IGUAL           shift and go to state 111


state 69

    (24) if -> soloIf elseIf else .

    NAME            reduce using rule 24 (if -> soloIf elseIf else .)
    CONST           reduce using rule 24 (if -> soloIf elseIf else .)
    LET             reduce using rule 24 (if -> soloIf elseIf else .)
    VAR             reduce using rule 24 (if -> soloIf elseIf else .)
    WHILE           reduce using rule 24 (if -> soloIf elseIf else .)
    FOR             reduce using rule 24 (if -> soloIf elseIf else .)
    IF              reduce using rule 24 (if -> soloIf elseIf else .)
    $end            reduce using rule 24 (if -> soloIf elseIf else .)
    CLOSE_BRACE     reduce using rule 24 (if -> soloIf elseIf else .)


state 70

    (27) elseIf -> ELSEIF OPEN_PARENTHESIS . controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (28) elseIf -> ELSEIF OPEN_PARENTHESIS . controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf
    (30) controlArg -> . element clause element
    (102) element -> . STRING
    (103) element -> . NUMBER
    (104) element -> . NAME

    STRING          shift and go to state 64
    NUMBER          shift and go to state 65
    NAME            shift and go to state 44

    controlArg                     shift and go to state 112
    element                        shift and go to state 61

state 71

    (29) else -> ELSE OPEN_BRACE . expression CLOSE_BRACE
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) expression -> . methodsSet
    (8) expression -> . mapFunctions
    (9) expression -> . arrayFn
    (10) expression -> . declaration
    (11) variable -> . type NAME IGUAL datatype SEMICOLON
    (12) variable -> . type NAME IGUAL operations SEMICOLON
    (13) variable -> . NAME IGUAL datatype SEMICOLON
    (17) dataStruct -> . array
    (18) dataStruct -> . set
    (19) dataStruct -> . map
    (14) controlStruct -> . while
    (15) controlStruct -> . for
    (16) controlStruct -> . if
    (93) methodsSet -> . NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (94) methodsSet -> . NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (95) methodsSet -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (81) mapFunctions -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (82) mapFunctions -> . NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (83) mapFunctions -> . NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (84) arrayFn -> . NAME POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS
    (85) arrayFn -> . NAME POINT PUSH OPEN_PARENTHESIS element CLOSE_PARENTHESIS
    (86) arrayFn -> . NAME POINT UNSHIFT OPEN_PARENTHESIS element CLOSE_PARENTHESIS
    (105) declaration -> . NAME IGUAL element SEMICOLON
    (53) type -> . CONST
    (54) type -> . LET
    (55) type -> . VAR
    (64) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (65) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (87) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (88) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (89) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (90) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (91) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (92) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (66) map -> . iniciarMap
    (67) map -> . escribirMap
    (68) map -> . generarMap
    (20) while -> . WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (21) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (31) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (22) if -> . soloIf
    (23) if -> . soloIf elseIf
    (24) if -> . soloIf elseIf else
    (25) if -> . soloIf else
    (69) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (70) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (76) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (26) soloIf -> . IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    NAME            shift and go to state 10
    CONST           shift and go to state 17
    LET             shift and go to state 18
    VAR             shift and go to state 19
    WHILE           shift and go to state 23
    FOR             shift and go to state 24
    IF              shift and go to state 26

    expression                     shift and go to state 113
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    methodsSet                     shift and go to state 5
    mapFunctions                   shift and go to state 6
    arrayFn                        shift and go to state 7
    declaration                    shift and go to state 8
    type                           shift and go to state 9
    array                          shift and go to state 11
    set                            shift and go to state 12
    map                            shift and go to state 13
    while                          shift and go to state 14
    for                            shift and go to state 15
    if                             shift and go to state 16
    iniciarMap                     shift and go to state 20
    escribirMap                    shift and go to state 21
    generarMap                     shift and go to state 22
    soloIf                         shift and go to state 25

state 72

    (26) soloIf -> IF OPEN_PARENTHESIS controlArg . CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    CLOSE_PARENTHESIS shift and go to state 114


state 73

    (69) iniciarMap -> variable IGUAL NEW MAP . OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON

    OPEN_PARENTHESIS shift and go to state 115


state 74

    (70) escribirMap -> variable IGUAL OPEN_BRACE claveValor . CLOSE_BRACE

    CLOSE_BRACE     shift and go to state 116


state 75

    (76) generarMap -> variable IGUAL OPEN_BRACE tuplas . CLOSE_BRACE

    CLOSE_BRACE     shift and go to state 117


state 76

    (71) claveValor -> clave . COLON valor
    (72) claveValor -> clave . COLON valor COMMA claveValor

    COLON           shift and go to state 118


state 77

    (77) tuplas -> tupla .
    (78) tuplas -> tupla . COMMA tuplas

    CLOSE_BRACE     reduce using rule 77 (tuplas -> tupla .)
    COMMA           shift and go to state 119


state 78

    (73) clave -> datatype .

    COLON           reduce using rule 73 (clave -> datatype .)
    CLOSE_PARENTHESIS reduce using rule 73 (clave -> datatype .)


state 79

    (79) tupla -> OPEN_BRACKET . datatype CLOSE_BRACKET
    (80) tupla -> OPEN_BRACKET . datatype COMMA datatype CLOSE_BRACKET
    (44) datatype -> . NUMBER
    (45) datatype -> . STRING
    (46) datatype -> . CHAR

    NUMBER          shift and go to state 80
    STRING          shift and go to state 81
    CHAR            shift and go to state 50

    datatype                       shift and go to state 120

state 80

    (44) datatype -> NUMBER .

    COLON           reduce using rule 44 (datatype -> NUMBER .)
    CLOSE_BRACKET   reduce using rule 44 (datatype -> NUMBER .)
    COMMA           reduce using rule 44 (datatype -> NUMBER .)
    CLOSE_PARENTHESIS reduce using rule 44 (datatype -> NUMBER .)
    CLOSE_BRACE     reduce using rule 44 (datatype -> NUMBER .)
    SEMICOLON       reduce using rule 44 (datatype -> NUMBER .)


state 81

    (45) datatype -> STRING .

    COLON           reduce using rule 45 (datatype -> STRING .)
    SEMICOLON       reduce using rule 45 (datatype -> STRING .)
    CLOSE_BRACKET   reduce using rule 45 (datatype -> STRING .)
    COMMA           reduce using rule 45 (datatype -> STRING .)
    CLOSE_PARENTHESIS reduce using rule 45 (datatype -> STRING .)
    CLOSE_BRACE     reduce using rule 45 (datatype -> STRING .)


state 82

    (35) operations -> NAME .
    (38) operations -> NAME . operand NUMBER operations
    (40) operations -> NAME . operand NUMBER
    (41) operations -> NAME . operand NAME operations
    (47) operand -> . SUMA
    (48) operand -> . RESTA
    (49) operand -> . MULTIPLICACION
    (50) operand -> . DIVISION

    SEMICOLON       reduce using rule 35 (operations -> NAME .)
    CLOSE_PARENTHESIS reduce using rule 35 (operations -> NAME .)
    SUMA            shift and go to state 122
    RESTA           shift and go to state 123
    MULTIPLICACION  shift and go to state 124
    DIVISION        shift and go to state 125

    operand                        shift and go to state 121

state 83

    (11) variable -> type NAME IGUAL datatype . SEMICOLON

    SEMICOLON       shift and go to state 126


state 84

    (12) variable -> type NAME IGUAL operations . SEMICOLON

    SEMICOLON       shift and go to state 127


state 85

    (64) array -> type NAME IGUAL OPEN_BRACKET . items CLOSE_BRACKET SEMICOLON
    (96) items -> . numeros
    (97) items -> . cadena
    (98) numeros -> . NUMBER
    (99) numeros -> . NUMBER COMMA numeros
    (100) cadena -> . STRING
    (101) cadena -> . STRING COMMA cadena

    NUMBER          shift and go to state 131
    STRING          shift and go to state 132

    items                          shift and go to state 128
    numeros                        shift and go to state 129
    cadena                         shift and go to state 130

state 86

    (65) array -> type NAME IGUAL NEW . ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (87) set -> type NAME IGUAL NEW . SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (88) set -> type NAME IGUAL NEW . SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (89) set -> type NAME IGUAL NEW . SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON

    ARRAY           shift and go to state 133
    SET             shift and go to state 134


state 87

    (42) operations -> OPEN_PARENTHESIS . NAME operand NAME CLOSE_PARENTHESIS operand operations
    (43) operations -> OPEN_PARENTHESIS . NUMBER operand NUMBER CLOSE_PARENTHESIS operand operations

    NAME            shift and go to state 135
    NUMBER          shift and go to state 136


state 88

    (44) datatype -> NUMBER .
    (34) operations -> NUMBER . operand NUMBER
    (36) operations -> NUMBER .
    (37) operations -> NUMBER . operand NAME operations
    (39) operations -> NUMBER . operand NAME
    (47) operand -> . SUMA
    (48) operand -> . RESTA
    (49) operand -> . MULTIPLICACION
    (50) operand -> . DIVISION

  ! reduce/reduce conflict for SEMICOLON resolved using rule 36 (operations -> NUMBER .)
    SEMICOLON       reduce using rule 36 (operations -> NUMBER .)
    SUMA            shift and go to state 122
    RESTA           shift and go to state 123
    MULTIPLICACION  shift and go to state 124
    DIVISION        shift and go to state 125

  ! SEMICOLON       [ reduce using rule 44 (datatype -> NUMBER .) ]

    operand                        shift and go to state 137

state 89

    (13) variable -> NAME IGUAL datatype SEMICOLON .

    IGUAL           reduce using rule 13 (variable -> NAME IGUAL datatype SEMICOLON .)
    NAME            reduce using rule 13 (variable -> NAME IGUAL datatype SEMICOLON .)
    CONST           reduce using rule 13 (variable -> NAME IGUAL datatype SEMICOLON .)
    LET             reduce using rule 13 (variable -> NAME IGUAL datatype SEMICOLON .)
    VAR             reduce using rule 13 (variable -> NAME IGUAL datatype SEMICOLON .)
    WHILE           reduce using rule 13 (variable -> NAME IGUAL datatype SEMICOLON .)
    FOR             reduce using rule 13 (variable -> NAME IGUAL datatype SEMICOLON .)
    IF              reduce using rule 13 (variable -> NAME IGUAL datatype SEMICOLON .)
    $end            reduce using rule 13 (variable -> NAME IGUAL datatype SEMICOLON .)
    CLOSE_BRACE     reduce using rule 13 (variable -> NAME IGUAL datatype SEMICOLON .)


state 90

    (105) declaration -> NAME IGUAL element SEMICOLON .

    $end            reduce using rule 105 (declaration -> NAME IGUAL element SEMICOLON .)
    CLOSE_BRACE     reduce using rule 105 (declaration -> NAME IGUAL element SEMICOLON .)


state 91

    (90) set -> NAME IGUAL NEW SET . OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (91) set -> NAME IGUAL NEW SET . OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (92) set -> NAME IGUAL NEW SET . OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON

    OPEN_PARENTHESIS shift and go to state 138


state 92

    (93) methodsSet -> NAME POINT ADD OPEN_PARENTHESIS . element CLOSE_PARENTHESIS SEMICOLON
    (102) element -> . STRING
    (103) element -> . NUMBER
    (104) element -> . NAME

    STRING          shift and go to state 64
    NUMBER          shift and go to state 65
    NAME            shift and go to state 44

    element                        shift and go to state 139

state 93

    (94) methodsSet -> NAME POINT DELETE OPEN_PARENTHESIS . element CLOSE_PARENTHESIS SEMICOLON
    (102) element -> . STRING
    (103) element -> . NUMBER
    (104) element -> . NAME

    STRING          shift and go to state 64
    NUMBER          shift and go to state 65
    NAME            shift and go to state 44

    element                        shift and go to state 140

state 94

    (95) methodsSet -> NAME POINT CLEAR OPEN_PARENTHESIS . CLOSE_PARENTHESIS SEMICOLON
    (81) mapFunctions -> NAME POINT CLEAR OPEN_PARENTHESIS . CLOSE_PARENTHESIS SEMICOLON

    CLOSE_PARENTHESIS shift and go to state 141


state 95

    (82) mapFunctions -> NAME POINT GET OPEN_PARENTHESIS . clave CLOSE_PARENTHESIS SEMICOLON
    (73) clave -> . datatype
    (44) datatype -> . NUMBER
    (45) datatype -> . STRING
    (46) datatype -> . CHAR

    NUMBER          shift and go to state 80
    STRING          shift and go to state 81
    CHAR            shift and go to state 50

    clave                          shift and go to state 142
    datatype                       shift and go to state 78

state 96

    (83) mapFunctions -> NAME POINT HAS OPEN_PARENTHESIS . clave CLOSE_PARENTHESIS SEMICOLON
    (73) clave -> . datatype
    (44) datatype -> . NUMBER
    (45) datatype -> . STRING
    (46) datatype -> . CHAR

    NUMBER          shift and go to state 80
    STRING          shift and go to state 81
    CHAR            shift and go to state 50

    clave                          shift and go to state 143
    datatype                       shift and go to state 78

state 97

    (84) arrayFn -> NAME POINT POP OPEN_PARENTHESIS . CLOSE_PARENTHESIS

    CLOSE_PARENTHESIS shift and go to state 144


state 98

    (85) arrayFn -> NAME POINT PUSH OPEN_PARENTHESIS . element CLOSE_PARENTHESIS
    (102) element -> . STRING
    (103) element -> . NUMBER
    (104) element -> . NAME

    STRING          shift and go to state 64
    NUMBER          shift and go to state 65
    NAME            shift and go to state 44

    element                        shift and go to state 145

state 99

    (86) arrayFn -> NAME POINT UNSHIFT OPEN_PARENTHESIS . element CLOSE_PARENTHESIS
    (102) element -> . STRING
    (103) element -> . NUMBER
    (104) element -> . NAME

    STRING          shift and go to state 64
    NUMBER          shift and go to state 65
    NAME            shift and go to state 44

    element                        shift and go to state 146

state 100

    (20) while -> WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS . OPEN_BRACE expression CLOSE_BRACE

    OPEN_BRACE      shift and go to state 147


state 101

    (21) while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS . OPEN_BRACE expression CLOSE_BRACE

    OPEN_BRACE      shift and go to state 148


state 102

    (30) controlArg -> element clause . element
    (102) element -> . STRING
    (103) element -> . NUMBER
    (104) element -> . NAME

    STRING          shift and go to state 64
    NUMBER          shift and go to state 65
    NAME            shift and go to state 44

    element                        shift and go to state 149

state 103

    (56) clause -> IGUALIGUAL .

    STRING          reduce using rule 56 (clause -> IGUALIGUAL .)
    NUMBER          reduce using rule 56 (clause -> IGUALIGUAL .)
    NAME            reduce using rule 56 (clause -> IGUALIGUAL .)


state 104

    (57) clause -> DIFERENTE .

    STRING          reduce using rule 57 (clause -> DIFERENTE .)
    NUMBER          reduce using rule 57 (clause -> DIFERENTE .)
    NAME            reduce using rule 57 (clause -> DIFERENTE .)


state 105

    (58) clause -> MAYORQUE .

    STRING          reduce using rule 58 (clause -> MAYORQUE .)
    NUMBER          reduce using rule 58 (clause -> MAYORQUE .)
    NAME            reduce using rule 58 (clause -> MAYORQUE .)


state 106

    (59) clause -> MAYORIGUALQUE .

    STRING          reduce using rule 59 (clause -> MAYORIGUALQUE .)
    NUMBER          reduce using rule 59 (clause -> MAYORIGUALQUE .)
    NAME            reduce using rule 59 (clause -> MAYORIGUALQUE .)


state 107

    (60) clause -> MENORQUE .

    STRING          reduce using rule 60 (clause -> MENORQUE .)
    NUMBER          reduce using rule 60 (clause -> MENORQUE .)
    NAME            reduce using rule 60 (clause -> MENORQUE .)


state 108

    (61) clause -> MENORIGUALQUE .

    STRING          reduce using rule 61 (clause -> MENORIGUALQUE .)
    NUMBER          reduce using rule 61 (clause -> MENORIGUALQUE .)
    NAME            reduce using rule 61 (clause -> MENORIGUALQUE .)


state 109

    (31) for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON . expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (108) expBoolean -> . controlArg
    (109) expBoolean -> . bool
    (110) expBoolean -> . NOT expBoolean
    (111) expBoolean -> . expBoolean logicalOperator expBoolean
    (30) controlArg -> . element clause element
    (51) bool -> . TRUE
    (52) bool -> . FALSE
    (102) element -> . STRING
    (103) element -> . NUMBER
    (104) element -> . NAME

    NOT             shift and go to state 153
    TRUE            shift and go to state 62
    FALSE           shift and go to state 63
    STRING          shift and go to state 64
    NUMBER          shift and go to state 65
    NAME            shift and go to state 44

    expBoolean                     shift and go to state 150
    controlArg                     shift and go to state 151
    bool                           shift and go to state 152
    element                        shift and go to state 61

state 110

    (32) inicialization -> type NAME . IGUAL NUMBER

    IGUAL           shift and go to state 154


state 111

    (33) inicialization -> NAME IGUAL . NUMBER

    NUMBER          shift and go to state 155


state 112

    (27) elseIf -> ELSEIF OPEN_PARENTHESIS controlArg . CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (28) elseIf -> ELSEIF OPEN_PARENTHESIS controlArg . CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf

    CLOSE_PARENTHESIS shift and go to state 156


state 113

    (29) else -> ELSE OPEN_BRACE expression . CLOSE_BRACE

    CLOSE_BRACE     shift and go to state 157


state 114

    (26) soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS . OPEN_BRACE expression CLOSE_BRACE

    OPEN_BRACE      shift and go to state 158


state 115

    (69) iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS . CLOSE_PARENTHESIS SEMICOLON

    CLOSE_PARENTHESIS shift and go to state 159


state 116

    (70) escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .

    NAME            reduce using rule 70 (escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .)
    CONST           reduce using rule 70 (escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .)
    LET             reduce using rule 70 (escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .)
    VAR             reduce using rule 70 (escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .)
    WHILE           reduce using rule 70 (escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .)
    FOR             reduce using rule 70 (escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .)
    IF              reduce using rule 70 (escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .)
    $end            reduce using rule 70 (escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 70 (escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .)
    COMMA           reduce using rule 70 (escribirMap -> variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE .)


state 117

    (76) generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .

    NAME            reduce using rule 76 (generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .)
    CONST           reduce using rule 76 (generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .)
    LET             reduce using rule 76 (generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .)
    VAR             reduce using rule 76 (generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .)
    WHILE           reduce using rule 76 (generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .)
    FOR             reduce using rule 76 (generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .)
    IF              reduce using rule 76 (generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .)
    $end            reduce using rule 76 (generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 76 (generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .)
    COMMA           reduce using rule 76 (generarMap -> variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE .)


state 118

    (71) claveValor -> clave COLON . valor
    (72) claveValor -> clave COLON . valor COMMA claveValor
    (74) valor -> . datatype
    (75) valor -> . dataStruct
    (44) datatype -> . NUMBER
    (45) datatype -> . STRING
    (46) datatype -> . CHAR
    (17) dataStruct -> . array
    (18) dataStruct -> . set
    (19) dataStruct -> . map
    (64) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (65) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (87) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (88) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (89) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (90) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (91) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (92) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (66) map -> . iniciarMap
    (67) map -> . escribirMap
    (68) map -> . generarMap
    (53) type -> . CONST
    (54) type -> . LET
    (55) type -> . VAR
    (69) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (70) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (76) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (11) variable -> . type NAME IGUAL datatype SEMICOLON
    (12) variable -> . type NAME IGUAL operations SEMICOLON
    (13) variable -> . NAME IGUAL datatype SEMICOLON

    NUMBER          shift and go to state 80
    STRING          shift and go to state 81
    CHAR            shift and go to state 50
    NAME            shift and go to state 164
    CONST           shift and go to state 17
    LET             shift and go to state 18
    VAR             shift and go to state 19

    valor                          shift and go to state 160
    datatype                       shift and go to state 161
    dataStruct                     shift and go to state 162
    array                          shift and go to state 11
    set                            shift and go to state 12
    map                            shift and go to state 13
    type                           shift and go to state 163
    iniciarMap                     shift and go to state 20
    escribirMap                    shift and go to state 21
    generarMap                     shift and go to state 22
    variable                       shift and go to state 165

state 119

    (78) tuplas -> tupla COMMA . tuplas
    (77) tuplas -> . tupla
    (78) tuplas -> . tupla COMMA tuplas
    (79) tupla -> . OPEN_BRACKET datatype CLOSE_BRACKET
    (80) tupla -> . OPEN_BRACKET datatype COMMA datatype CLOSE_BRACKET

    OPEN_BRACKET    shift and go to state 79

    tupla                          shift and go to state 77
    tuplas                         shift and go to state 166

state 120

    (79) tupla -> OPEN_BRACKET datatype . CLOSE_BRACKET
    (80) tupla -> OPEN_BRACKET datatype . COMMA datatype CLOSE_BRACKET

    CLOSE_BRACKET   shift and go to state 167
    COMMA           shift and go to state 168


state 121

    (38) operations -> NAME operand . NUMBER operations
    (40) operations -> NAME operand . NUMBER
    (41) operations -> NAME operand . NAME operations

    NUMBER          shift and go to state 170
    NAME            shift and go to state 169


state 122

    (47) operand -> SUMA .

    NUMBER          reduce using rule 47 (operand -> SUMA .)
    NAME            reduce using rule 47 (operand -> SUMA .)
    OPEN_PARENTHESIS reduce using rule 47 (operand -> SUMA .)


state 123

    (48) operand -> RESTA .

    NUMBER          reduce using rule 48 (operand -> RESTA .)
    NAME            reduce using rule 48 (operand -> RESTA .)
    OPEN_PARENTHESIS reduce using rule 48 (operand -> RESTA .)


state 124

    (49) operand -> MULTIPLICACION .

    NUMBER          reduce using rule 49 (operand -> MULTIPLICACION .)
    NAME            reduce using rule 49 (operand -> MULTIPLICACION .)
    OPEN_PARENTHESIS reduce using rule 49 (operand -> MULTIPLICACION .)


state 125

    (50) operand -> DIVISION .

    NUMBER          reduce using rule 50 (operand -> DIVISION .)
    NAME            reduce using rule 50 (operand -> DIVISION .)
    OPEN_PARENTHESIS reduce using rule 50 (operand -> DIVISION .)


state 126

    (11) variable -> type NAME IGUAL datatype SEMICOLON .

    IGUAL           reduce using rule 11 (variable -> type NAME IGUAL datatype SEMICOLON .)
    NAME            reduce using rule 11 (variable -> type NAME IGUAL datatype SEMICOLON .)
    CONST           reduce using rule 11 (variable -> type NAME IGUAL datatype SEMICOLON .)
    LET             reduce using rule 11 (variable -> type NAME IGUAL datatype SEMICOLON .)
    VAR             reduce using rule 11 (variable -> type NAME IGUAL datatype SEMICOLON .)
    WHILE           reduce using rule 11 (variable -> type NAME IGUAL datatype SEMICOLON .)
    FOR             reduce using rule 11 (variable -> type NAME IGUAL datatype SEMICOLON .)
    IF              reduce using rule 11 (variable -> type NAME IGUAL datatype SEMICOLON .)
    $end            reduce using rule 11 (variable -> type NAME IGUAL datatype SEMICOLON .)
    CLOSE_BRACE     reduce using rule 11 (variable -> type NAME IGUAL datatype SEMICOLON .)


state 127

    (12) variable -> type NAME IGUAL operations SEMICOLON .

    IGUAL           reduce using rule 12 (variable -> type NAME IGUAL operations SEMICOLON .)
    NAME            reduce using rule 12 (variable -> type NAME IGUAL operations SEMICOLON .)
    CONST           reduce using rule 12 (variable -> type NAME IGUAL operations SEMICOLON .)
    LET             reduce using rule 12 (variable -> type NAME IGUAL operations SEMICOLON .)
    VAR             reduce using rule 12 (variable -> type NAME IGUAL operations SEMICOLON .)
    WHILE           reduce using rule 12 (variable -> type NAME IGUAL operations SEMICOLON .)
    FOR             reduce using rule 12 (variable -> type NAME IGUAL operations SEMICOLON .)
    IF              reduce using rule 12 (variable -> type NAME IGUAL operations SEMICOLON .)
    $end            reduce using rule 12 (variable -> type NAME IGUAL operations SEMICOLON .)
    CLOSE_BRACE     reduce using rule 12 (variable -> type NAME IGUAL operations SEMICOLON .)


state 128

    (64) array -> type NAME IGUAL OPEN_BRACKET items . CLOSE_BRACKET SEMICOLON

    CLOSE_BRACKET   shift and go to state 171


state 129

    (96) items -> numeros .

    CLOSE_BRACKET   reduce using rule 96 (items -> numeros .)
    CLOSE_PARENTHESIS reduce using rule 96 (items -> numeros .)


state 130

    (97) items -> cadena .

    CLOSE_BRACKET   reduce using rule 97 (items -> cadena .)
    CLOSE_PARENTHESIS reduce using rule 97 (items -> cadena .)


state 131

    (98) numeros -> NUMBER .
    (99) numeros -> NUMBER . COMMA numeros

    CLOSE_BRACKET   reduce using rule 98 (numeros -> NUMBER .)
    CLOSE_PARENTHESIS reduce using rule 98 (numeros -> NUMBER .)
    COMMA           shift and go to state 172


state 132

    (100) cadena -> STRING .
    (101) cadena -> STRING . COMMA cadena

    CLOSE_BRACKET   reduce using rule 100 (cadena -> STRING .)
    CLOSE_PARENTHESIS reduce using rule 100 (cadena -> STRING .)
    COMMA           shift and go to state 173


state 133

    (65) array -> type NAME IGUAL NEW ARRAY . OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON

    OPEN_PARENTHESIS shift and go to state 174


state 134

    (87) set -> type NAME IGUAL NEW SET . OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (88) set -> type NAME IGUAL NEW SET . OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (89) set -> type NAME IGUAL NEW SET . OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON

    OPEN_PARENTHESIS shift and go to state 175


state 135

    (42) operations -> OPEN_PARENTHESIS NAME . operand NAME CLOSE_PARENTHESIS operand operations
    (47) operand -> . SUMA
    (48) operand -> . RESTA
    (49) operand -> . MULTIPLICACION
    (50) operand -> . DIVISION

    SUMA            shift and go to state 122
    RESTA           shift and go to state 123
    MULTIPLICACION  shift and go to state 124
    DIVISION        shift and go to state 125

    operand                        shift and go to state 176

state 136

    (43) operations -> OPEN_PARENTHESIS NUMBER . operand NUMBER CLOSE_PARENTHESIS operand operations
    (47) operand -> . SUMA
    (48) operand -> . RESTA
    (49) operand -> . MULTIPLICACION
    (50) operand -> . DIVISION

    SUMA            shift and go to state 122
    RESTA           shift and go to state 123
    MULTIPLICACION  shift and go to state 124
    DIVISION        shift and go to state 125

    operand                        shift and go to state 177

state 137

    (34) operations -> NUMBER operand . NUMBER
    (37) operations -> NUMBER operand . NAME operations
    (39) operations -> NUMBER operand . NAME

    NUMBER          shift and go to state 178
    NAME            shift and go to state 179


state 138

    (90) set -> NAME IGUAL NEW SET OPEN_PARENTHESIS . CLOSE_PARENTHESIS SEMICOLON
    (91) set -> NAME IGUAL NEW SET OPEN_PARENTHESIS . OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (92) set -> NAME IGUAL NEW SET OPEN_PARENTHESIS . element CLOSE_PARENTHESIS SEMICOLON
    (102) element -> . STRING
    (103) element -> . NUMBER
    (104) element -> . NAME

    CLOSE_PARENTHESIS shift and go to state 180
    OPEN_BRACKET    shift and go to state 181
    STRING          shift and go to state 64
    NUMBER          shift and go to state 65
    NAME            shift and go to state 44

    element                        shift and go to state 182

state 139

    (93) methodsSet -> NAME POINT ADD OPEN_PARENTHESIS element . CLOSE_PARENTHESIS SEMICOLON

    CLOSE_PARENTHESIS shift and go to state 183


state 140

    (94) methodsSet -> NAME POINT DELETE OPEN_PARENTHESIS element . CLOSE_PARENTHESIS SEMICOLON

    CLOSE_PARENTHESIS shift and go to state 184


state 141

    (95) methodsSet -> NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS . SEMICOLON
    (81) mapFunctions -> NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 185


state 142

    (82) mapFunctions -> NAME POINT GET OPEN_PARENTHESIS clave . CLOSE_PARENTHESIS SEMICOLON

    CLOSE_PARENTHESIS shift and go to state 186


state 143

    (83) mapFunctions -> NAME POINT HAS OPEN_PARENTHESIS clave . CLOSE_PARENTHESIS SEMICOLON

    CLOSE_PARENTHESIS shift and go to state 187


state 144

    (84) arrayFn -> NAME POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS .

    $end            reduce using rule 84 (arrayFn -> NAME POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS .)
    CLOSE_BRACE     reduce using rule 84 (arrayFn -> NAME POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS .)


state 145

    (85) arrayFn -> NAME POINT PUSH OPEN_PARENTHESIS element . CLOSE_PARENTHESIS

    CLOSE_PARENTHESIS shift and go to state 188


state 146

    (86) arrayFn -> NAME POINT UNSHIFT OPEN_PARENTHESIS element . CLOSE_PARENTHESIS

    CLOSE_PARENTHESIS shift and go to state 189


state 147

    (20) while -> WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE . expression CLOSE_BRACE
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) expression -> . methodsSet
    (8) expression -> . mapFunctions
    (9) expression -> . arrayFn
    (10) expression -> . declaration
    (11) variable -> . type NAME IGUAL datatype SEMICOLON
    (12) variable -> . type NAME IGUAL operations SEMICOLON
    (13) variable -> . NAME IGUAL datatype SEMICOLON
    (17) dataStruct -> . array
    (18) dataStruct -> . set
    (19) dataStruct -> . map
    (14) controlStruct -> . while
    (15) controlStruct -> . for
    (16) controlStruct -> . if
    (93) methodsSet -> . NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (94) methodsSet -> . NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (95) methodsSet -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (81) mapFunctions -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (82) mapFunctions -> . NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (83) mapFunctions -> . NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (84) arrayFn -> . NAME POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS
    (85) arrayFn -> . NAME POINT PUSH OPEN_PARENTHESIS element CLOSE_PARENTHESIS
    (86) arrayFn -> . NAME POINT UNSHIFT OPEN_PARENTHESIS element CLOSE_PARENTHESIS
    (105) declaration -> . NAME IGUAL element SEMICOLON
    (53) type -> . CONST
    (54) type -> . LET
    (55) type -> . VAR
    (64) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (65) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (87) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (88) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (89) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (90) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (91) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (92) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (66) map -> . iniciarMap
    (67) map -> . escribirMap
    (68) map -> . generarMap
    (20) while -> . WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (21) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (31) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (22) if -> . soloIf
    (23) if -> . soloIf elseIf
    (24) if -> . soloIf elseIf else
    (25) if -> . soloIf else
    (69) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (70) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (76) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (26) soloIf -> . IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    NAME            shift and go to state 10
    CONST           shift and go to state 17
    LET             shift and go to state 18
    VAR             shift and go to state 19
    WHILE           shift and go to state 23
    FOR             shift and go to state 24
    IF              shift and go to state 26

    expression                     shift and go to state 190
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    methodsSet                     shift and go to state 5
    mapFunctions                   shift and go to state 6
    arrayFn                        shift and go to state 7
    declaration                    shift and go to state 8
    type                           shift and go to state 9
    array                          shift and go to state 11
    set                            shift and go to state 12
    map                            shift and go to state 13
    while                          shift and go to state 14
    for                            shift and go to state 15
    if                             shift and go to state 16
    iniciarMap                     shift and go to state 20
    escribirMap                    shift and go to state 21
    generarMap                     shift and go to state 22
    soloIf                         shift and go to state 25

state 148

    (21) while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE . expression CLOSE_BRACE
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) expression -> . methodsSet
    (8) expression -> . mapFunctions
    (9) expression -> . arrayFn
    (10) expression -> . declaration
    (11) variable -> . type NAME IGUAL datatype SEMICOLON
    (12) variable -> . type NAME IGUAL operations SEMICOLON
    (13) variable -> . NAME IGUAL datatype SEMICOLON
    (17) dataStruct -> . array
    (18) dataStruct -> . set
    (19) dataStruct -> . map
    (14) controlStruct -> . while
    (15) controlStruct -> . for
    (16) controlStruct -> . if
    (93) methodsSet -> . NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (94) methodsSet -> . NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (95) methodsSet -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (81) mapFunctions -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (82) mapFunctions -> . NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (83) mapFunctions -> . NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (84) arrayFn -> . NAME POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS
    (85) arrayFn -> . NAME POINT PUSH OPEN_PARENTHESIS element CLOSE_PARENTHESIS
    (86) arrayFn -> . NAME POINT UNSHIFT OPEN_PARENTHESIS element CLOSE_PARENTHESIS
    (105) declaration -> . NAME IGUAL element SEMICOLON
    (53) type -> . CONST
    (54) type -> . LET
    (55) type -> . VAR
    (64) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (65) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (87) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (88) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (89) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (90) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (91) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (92) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (66) map -> . iniciarMap
    (67) map -> . escribirMap
    (68) map -> . generarMap
    (20) while -> . WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (21) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (31) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (22) if -> . soloIf
    (23) if -> . soloIf elseIf
    (24) if -> . soloIf elseIf else
    (25) if -> . soloIf else
    (69) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (70) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (76) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (26) soloIf -> . IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    NAME            shift and go to state 10
    CONST           shift and go to state 17
    LET             shift and go to state 18
    VAR             shift and go to state 19
    WHILE           shift and go to state 23
    FOR             shift and go to state 24
    IF              shift and go to state 26

    expression                     shift and go to state 191
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    methodsSet                     shift and go to state 5
    mapFunctions                   shift and go to state 6
    arrayFn                        shift and go to state 7
    declaration                    shift and go to state 8
    type                           shift and go to state 9
    array                          shift and go to state 11
    set                            shift and go to state 12
    map                            shift and go to state 13
    while                          shift and go to state 14
    for                            shift and go to state 15
    if                             shift and go to state 16
    iniciarMap                     shift and go to state 20
    escribirMap                    shift and go to state 21
    generarMap                     shift and go to state 22
    soloIf                         shift and go to state 25

state 149

    (30) controlArg -> element clause element .

    CLOSE_PARENTHESIS reduce using rule 30 (controlArg -> element clause element .)
    SEMICOLON       reduce using rule 30 (controlArg -> element clause element .)
    AND             reduce using rule 30 (controlArg -> element clause element .)
    OR              reduce using rule 30 (controlArg -> element clause element .)


state 150

    (31) for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean . SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (111) expBoolean -> expBoolean . logicalOperator expBoolean
    (106) logicalOperator -> . AND
    (107) logicalOperator -> . OR

    SEMICOLON       shift and go to state 192
    AND             shift and go to state 194
    OR              shift and go to state 195

    logicalOperator                shift and go to state 193

state 151

    (108) expBoolean -> controlArg .

    SEMICOLON       reduce using rule 108 (expBoolean -> controlArg .)
    AND             reduce using rule 108 (expBoolean -> controlArg .)
    OR              reduce using rule 108 (expBoolean -> controlArg .)


state 152

    (109) expBoolean -> bool .

    SEMICOLON       reduce using rule 109 (expBoolean -> bool .)
    AND             reduce using rule 109 (expBoolean -> bool .)
    OR              reduce using rule 109 (expBoolean -> bool .)


state 153

    (110) expBoolean -> NOT . expBoolean
    (108) expBoolean -> . controlArg
    (109) expBoolean -> . bool
    (110) expBoolean -> . NOT expBoolean
    (111) expBoolean -> . expBoolean logicalOperator expBoolean
    (30) controlArg -> . element clause element
    (51) bool -> . TRUE
    (52) bool -> . FALSE
    (102) element -> . STRING
    (103) element -> . NUMBER
    (104) element -> . NAME

    NOT             shift and go to state 153
    TRUE            shift and go to state 62
    FALSE           shift and go to state 63
    STRING          shift and go to state 64
    NUMBER          shift and go to state 65
    NAME            shift and go to state 44

    expBoolean                     shift and go to state 196
    controlArg                     shift and go to state 151
    bool                           shift and go to state 152
    element                        shift and go to state 61

state 154

    (32) inicialization -> type NAME IGUAL . NUMBER

    NUMBER          shift and go to state 197


state 155

    (33) inicialization -> NAME IGUAL NUMBER .

    SEMICOLON       reduce using rule 33 (inicialization -> NAME IGUAL NUMBER .)


state 156

    (27) elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS . OPEN_BRACE expression CLOSE_BRACE
    (28) elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS . OPEN_BRACE expression CLOSE_BRACE soloIf

    OPEN_BRACE      shift and go to state 198


state 157

    (29) else -> ELSE OPEN_BRACE expression CLOSE_BRACE .

    NAME            reduce using rule 29 (else -> ELSE OPEN_BRACE expression CLOSE_BRACE .)
    CONST           reduce using rule 29 (else -> ELSE OPEN_BRACE expression CLOSE_BRACE .)
    LET             reduce using rule 29 (else -> ELSE OPEN_BRACE expression CLOSE_BRACE .)
    VAR             reduce using rule 29 (else -> ELSE OPEN_BRACE expression CLOSE_BRACE .)
    WHILE           reduce using rule 29 (else -> ELSE OPEN_BRACE expression CLOSE_BRACE .)
    FOR             reduce using rule 29 (else -> ELSE OPEN_BRACE expression CLOSE_BRACE .)
    IF              reduce using rule 29 (else -> ELSE OPEN_BRACE expression CLOSE_BRACE .)
    $end            reduce using rule 29 (else -> ELSE OPEN_BRACE expression CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 29 (else -> ELSE OPEN_BRACE expression CLOSE_BRACE .)


state 158

    (26) soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE . expression CLOSE_BRACE
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) expression -> . methodsSet
    (8) expression -> . mapFunctions
    (9) expression -> . arrayFn
    (10) expression -> . declaration
    (11) variable -> . type NAME IGUAL datatype SEMICOLON
    (12) variable -> . type NAME IGUAL operations SEMICOLON
    (13) variable -> . NAME IGUAL datatype SEMICOLON
    (17) dataStruct -> . array
    (18) dataStruct -> . set
    (19) dataStruct -> . map
    (14) controlStruct -> . while
    (15) controlStruct -> . for
    (16) controlStruct -> . if
    (93) methodsSet -> . NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (94) methodsSet -> . NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (95) methodsSet -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (81) mapFunctions -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (82) mapFunctions -> . NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (83) mapFunctions -> . NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (84) arrayFn -> . NAME POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS
    (85) arrayFn -> . NAME POINT PUSH OPEN_PARENTHESIS element CLOSE_PARENTHESIS
    (86) arrayFn -> . NAME POINT UNSHIFT OPEN_PARENTHESIS element CLOSE_PARENTHESIS
    (105) declaration -> . NAME IGUAL element SEMICOLON
    (53) type -> . CONST
    (54) type -> . LET
    (55) type -> . VAR
    (64) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (65) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (87) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (88) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (89) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (90) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (91) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (92) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (66) map -> . iniciarMap
    (67) map -> . escribirMap
    (68) map -> . generarMap
    (20) while -> . WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (21) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (31) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (22) if -> . soloIf
    (23) if -> . soloIf elseIf
    (24) if -> . soloIf elseIf else
    (25) if -> . soloIf else
    (69) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (70) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (76) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (26) soloIf -> . IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    NAME            shift and go to state 10
    CONST           shift and go to state 17
    LET             shift and go to state 18
    VAR             shift and go to state 19
    WHILE           shift and go to state 23
    FOR             shift and go to state 24
    IF              shift and go to state 26

    expression                     shift and go to state 199
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    methodsSet                     shift and go to state 5
    mapFunctions                   shift and go to state 6
    arrayFn                        shift and go to state 7
    declaration                    shift and go to state 8
    type                           shift and go to state 9
    array                          shift and go to state 11
    set                            shift and go to state 12
    map                            shift and go to state 13
    while                          shift and go to state 14
    for                            shift and go to state 15
    if                             shift and go to state 16
    iniciarMap                     shift and go to state 20
    escribirMap                    shift and go to state 21
    generarMap                     shift and go to state 22
    soloIf                         shift and go to state 25

state 159

    (69) iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 200


state 160

    (71) claveValor -> clave COLON valor .
    (72) claveValor -> clave COLON valor . COMMA claveValor

    CLOSE_BRACE     reduce using rule 71 (claveValor -> clave COLON valor .)
    COMMA           shift and go to state 201


state 161

    (74) valor -> datatype .

    COMMA           reduce using rule 74 (valor -> datatype .)
    CLOSE_BRACE     reduce using rule 74 (valor -> datatype .)


state 162

    (75) valor -> dataStruct .

    COMMA           reduce using rule 75 (valor -> dataStruct .)
    CLOSE_BRACE     reduce using rule 75 (valor -> dataStruct .)


state 163

    (64) array -> type . NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (65) array -> type . NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (87) set -> type . NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (88) set -> type . NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (89) set -> type . NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (11) variable -> type . NAME IGUAL datatype SEMICOLON
    (12) variable -> type . NAME IGUAL operations SEMICOLON

    NAME            shift and go to state 202


state 164

    (90) set -> NAME . IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (91) set -> NAME . IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (92) set -> NAME . IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (13) variable -> NAME . IGUAL datatype SEMICOLON

    IGUAL           shift and go to state 203


state 165

    (69) iniciarMap -> variable . IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (70) escribirMap -> variable . IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (76) generarMap -> variable . IGUAL OPEN_BRACE tuplas CLOSE_BRACE

    IGUAL           shift and go to state 28


state 166

    (78) tuplas -> tupla COMMA tuplas .

    CLOSE_BRACE     reduce using rule 78 (tuplas -> tupla COMMA tuplas .)


state 167

    (79) tupla -> OPEN_BRACKET datatype CLOSE_BRACKET .

    COMMA           reduce using rule 79 (tupla -> OPEN_BRACKET datatype CLOSE_BRACKET .)
    CLOSE_BRACE     reduce using rule 79 (tupla -> OPEN_BRACKET datatype CLOSE_BRACKET .)


state 168

    (80) tupla -> OPEN_BRACKET datatype COMMA . datatype CLOSE_BRACKET
    (44) datatype -> . NUMBER
    (45) datatype -> . STRING
    (46) datatype -> . CHAR

    NUMBER          shift and go to state 80
    STRING          shift and go to state 81
    CHAR            shift and go to state 50

    datatype                       shift and go to state 204

state 169

    (41) operations -> NAME operand NAME . operations
    (34) operations -> . NUMBER operand NUMBER
    (35) operations -> . NAME
    (36) operations -> . NUMBER
    (37) operations -> . NUMBER operand NAME operations
    (38) operations -> . NAME operand NUMBER operations
    (39) operations -> . NUMBER operand NAME
    (40) operations -> . NAME operand NUMBER
    (41) operations -> . NAME operand NAME operations
    (42) operations -> . OPEN_PARENTHESIS NAME operand NAME CLOSE_PARENTHESIS operand operations
    (43) operations -> . OPEN_PARENTHESIS NUMBER operand NUMBER CLOSE_PARENTHESIS operand operations

    NUMBER          shift and go to state 206
    NAME            shift and go to state 82
    OPEN_PARENTHESIS shift and go to state 87

    operations                     shift and go to state 205

state 170

    (38) operations -> NAME operand NUMBER . operations
    (40) operations -> NAME operand NUMBER .
    (34) operations -> . NUMBER operand NUMBER
    (35) operations -> . NAME
    (36) operations -> . NUMBER
    (37) operations -> . NUMBER operand NAME operations
    (38) operations -> . NAME operand NUMBER operations
    (39) operations -> . NUMBER operand NAME
    (40) operations -> . NAME operand NUMBER
    (41) operations -> . NAME operand NAME operations
    (42) operations -> . OPEN_PARENTHESIS NAME operand NAME CLOSE_PARENTHESIS operand operations
    (43) operations -> . OPEN_PARENTHESIS NUMBER operand NUMBER CLOSE_PARENTHESIS operand operations

    SEMICOLON       reduce using rule 40 (operations -> NAME operand NUMBER .)
    CLOSE_PARENTHESIS reduce using rule 40 (operations -> NAME operand NUMBER .)
    NUMBER          shift and go to state 206
    NAME            shift and go to state 82
    OPEN_PARENTHESIS shift and go to state 87

    operations                     shift and go to state 207

state 171

    (64) array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET . SEMICOLON

    SEMICOLON       shift and go to state 208


state 172

    (99) numeros -> NUMBER COMMA . numeros
    (98) numeros -> . NUMBER
    (99) numeros -> . NUMBER COMMA numeros

    NUMBER          shift and go to state 131

    numeros                        shift and go to state 209

state 173

    (101) cadena -> STRING COMMA . cadena
    (100) cadena -> . STRING
    (101) cadena -> . STRING COMMA cadena

    STRING          shift and go to state 132

    cadena                         shift and go to state 210

state 174

    (65) array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS . items CLOSE_PARENTHESIS SEMICOLON
    (96) items -> . numeros
    (97) items -> . cadena
    (98) numeros -> . NUMBER
    (99) numeros -> . NUMBER COMMA numeros
    (100) cadena -> . STRING
    (101) cadena -> . STRING COMMA cadena

    NUMBER          shift and go to state 131
    STRING          shift and go to state 132

    items                          shift and go to state 211
    numeros                        shift and go to state 129
    cadena                         shift and go to state 130

state 175

    (87) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS . CLOSE_PARENTHESIS SEMICOLON
    (88) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS . OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (89) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS . element CLOSE_PARENTHESIS SEMICOLON
    (102) element -> . STRING
    (103) element -> . NUMBER
    (104) element -> . NAME

    CLOSE_PARENTHESIS shift and go to state 212
    OPEN_BRACKET    shift and go to state 213
    STRING          shift and go to state 64
    NUMBER          shift and go to state 65
    NAME            shift and go to state 44

    element                        shift and go to state 214

state 176

    (42) operations -> OPEN_PARENTHESIS NAME operand . NAME CLOSE_PARENTHESIS operand operations

    NAME            shift and go to state 215


state 177

    (43) operations -> OPEN_PARENTHESIS NUMBER operand . NUMBER CLOSE_PARENTHESIS operand operations

    NUMBER          shift and go to state 216


state 178

    (34) operations -> NUMBER operand NUMBER .

    SEMICOLON       reduce using rule 34 (operations -> NUMBER operand NUMBER .)
    CLOSE_PARENTHESIS reduce using rule 34 (operations -> NUMBER operand NUMBER .)


state 179

    (37) operations -> NUMBER operand NAME . operations
    (39) operations -> NUMBER operand NAME .
    (34) operations -> . NUMBER operand NUMBER
    (35) operations -> . NAME
    (36) operations -> . NUMBER
    (37) operations -> . NUMBER operand NAME operations
    (38) operations -> . NAME operand NUMBER operations
    (39) operations -> . NUMBER operand NAME
    (40) operations -> . NAME operand NUMBER
    (41) operations -> . NAME operand NAME operations
    (42) operations -> . OPEN_PARENTHESIS NAME operand NAME CLOSE_PARENTHESIS operand operations
    (43) operations -> . OPEN_PARENTHESIS NUMBER operand NUMBER CLOSE_PARENTHESIS operand operations

    SEMICOLON       reduce using rule 39 (operations -> NUMBER operand NAME .)
    CLOSE_PARENTHESIS reduce using rule 39 (operations -> NUMBER operand NAME .)
    NUMBER          shift and go to state 206
    NAME            shift and go to state 82
    OPEN_PARENTHESIS shift and go to state 87

    operations                     shift and go to state 217

state 180

    (90) set -> NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 218


state 181

    (91) set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET . items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (96) items -> . numeros
    (97) items -> . cadena
    (98) numeros -> . NUMBER
    (99) numeros -> . NUMBER COMMA numeros
    (100) cadena -> . STRING
    (101) cadena -> . STRING COMMA cadena

    NUMBER          shift and go to state 131
    STRING          shift and go to state 132

    items                          shift and go to state 219
    numeros                        shift and go to state 129
    cadena                         shift and go to state 130

state 182

    (92) set -> NAME IGUAL NEW SET OPEN_PARENTHESIS element . CLOSE_PARENTHESIS SEMICOLON

    CLOSE_PARENTHESIS shift and go to state 220


state 183

    (93) methodsSet -> NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 221


state 184

    (94) methodsSet -> NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 222


state 185

    (95) methodsSet -> NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .
    (81) mapFunctions -> NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .

  ! reduce/reduce conflict for $end resolved using rule 81 (mapFunctions -> NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
  ! reduce/reduce conflict for CLOSE_BRACE resolved using rule 81 (mapFunctions -> NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    $end            reduce using rule 81 (mapFunctions -> NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 81 (mapFunctions -> NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)

  ! $end            [ reduce using rule 95 (methodsSet -> NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .) ]
  ! CLOSE_BRACE     [ reduce using rule 95 (methodsSet -> NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .) ]


state 186

    (82) mapFunctions -> NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 223


state 187

    (83) mapFunctions -> NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 224


state 188

    (85) arrayFn -> NAME POINT PUSH OPEN_PARENTHESIS element CLOSE_PARENTHESIS .

    $end            reduce using rule 85 (arrayFn -> NAME POINT PUSH OPEN_PARENTHESIS element CLOSE_PARENTHESIS .)
    CLOSE_BRACE     reduce using rule 85 (arrayFn -> NAME POINT PUSH OPEN_PARENTHESIS element CLOSE_PARENTHESIS .)


state 189

    (86) arrayFn -> NAME POINT UNSHIFT OPEN_PARENTHESIS element CLOSE_PARENTHESIS .

    $end            reduce using rule 86 (arrayFn -> NAME POINT UNSHIFT OPEN_PARENTHESIS element CLOSE_PARENTHESIS .)
    CLOSE_BRACE     reduce using rule 86 (arrayFn -> NAME POINT UNSHIFT OPEN_PARENTHESIS element CLOSE_PARENTHESIS .)


state 190

    (20) while -> WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression . CLOSE_BRACE

    CLOSE_BRACE     shift and go to state 225


state 191

    (21) while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression . CLOSE_BRACE

    CLOSE_BRACE     shift and go to state 226


state 192

    (31) for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON . operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (34) operations -> . NUMBER operand NUMBER
    (35) operations -> . NAME
    (36) operations -> . NUMBER
    (37) operations -> . NUMBER operand NAME operations
    (38) operations -> . NAME operand NUMBER operations
    (39) operations -> . NUMBER operand NAME
    (40) operations -> . NAME operand NUMBER
    (41) operations -> . NAME operand NAME operations
    (42) operations -> . OPEN_PARENTHESIS NAME operand NAME CLOSE_PARENTHESIS operand operations
    (43) operations -> . OPEN_PARENTHESIS NUMBER operand NUMBER CLOSE_PARENTHESIS operand operations

    NUMBER          shift and go to state 206
    NAME            shift and go to state 82
    OPEN_PARENTHESIS shift and go to state 87

    operations                     shift and go to state 227

state 193

    (111) expBoolean -> expBoolean logicalOperator . expBoolean
    (108) expBoolean -> . controlArg
    (109) expBoolean -> . bool
    (110) expBoolean -> . NOT expBoolean
    (111) expBoolean -> . expBoolean logicalOperator expBoolean
    (30) controlArg -> . element clause element
    (51) bool -> . TRUE
    (52) bool -> . FALSE
    (102) element -> . STRING
    (103) element -> . NUMBER
    (104) element -> . NAME

    NOT             shift and go to state 153
    TRUE            shift and go to state 62
    FALSE           shift and go to state 63
    STRING          shift and go to state 64
    NUMBER          shift and go to state 65
    NAME            shift and go to state 44

    expBoolean                     shift and go to state 228
    controlArg                     shift and go to state 151
    bool                           shift and go to state 152
    element                        shift and go to state 61

state 194

    (106) logicalOperator -> AND .

    NOT             reduce using rule 106 (logicalOperator -> AND .)
    TRUE            reduce using rule 106 (logicalOperator -> AND .)
    FALSE           reduce using rule 106 (logicalOperator -> AND .)
    STRING          reduce using rule 106 (logicalOperator -> AND .)
    NUMBER          reduce using rule 106 (logicalOperator -> AND .)
    NAME            reduce using rule 106 (logicalOperator -> AND .)


state 195

    (107) logicalOperator -> OR .

    NOT             reduce using rule 107 (logicalOperator -> OR .)
    TRUE            reduce using rule 107 (logicalOperator -> OR .)
    FALSE           reduce using rule 107 (logicalOperator -> OR .)
    STRING          reduce using rule 107 (logicalOperator -> OR .)
    NUMBER          reduce using rule 107 (logicalOperator -> OR .)
    NAME            reduce using rule 107 (logicalOperator -> OR .)


state 196

    (110) expBoolean -> NOT expBoolean .
    (111) expBoolean -> expBoolean . logicalOperator expBoolean
    (106) logicalOperator -> . AND
    (107) logicalOperator -> . OR

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 110 (expBoolean -> NOT expBoolean .)
    AND             shift and go to state 194
    OR              shift and go to state 195

  ! AND             [ reduce using rule 110 (expBoolean -> NOT expBoolean .) ]
  ! OR              [ reduce using rule 110 (expBoolean -> NOT expBoolean .) ]

    logicalOperator                shift and go to state 193

state 197

    (32) inicialization -> type NAME IGUAL NUMBER .

    SEMICOLON       reduce using rule 32 (inicialization -> type NAME IGUAL NUMBER .)


state 198

    (27) elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE . expression CLOSE_BRACE
    (28) elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE . expression CLOSE_BRACE soloIf
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) expression -> . methodsSet
    (8) expression -> . mapFunctions
    (9) expression -> . arrayFn
    (10) expression -> . declaration
    (11) variable -> . type NAME IGUAL datatype SEMICOLON
    (12) variable -> . type NAME IGUAL operations SEMICOLON
    (13) variable -> . NAME IGUAL datatype SEMICOLON
    (17) dataStruct -> . array
    (18) dataStruct -> . set
    (19) dataStruct -> . map
    (14) controlStruct -> . while
    (15) controlStruct -> . for
    (16) controlStruct -> . if
    (93) methodsSet -> . NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (94) methodsSet -> . NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (95) methodsSet -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (81) mapFunctions -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (82) mapFunctions -> . NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (83) mapFunctions -> . NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (84) arrayFn -> . NAME POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS
    (85) arrayFn -> . NAME POINT PUSH OPEN_PARENTHESIS element CLOSE_PARENTHESIS
    (86) arrayFn -> . NAME POINT UNSHIFT OPEN_PARENTHESIS element CLOSE_PARENTHESIS
    (105) declaration -> . NAME IGUAL element SEMICOLON
    (53) type -> . CONST
    (54) type -> . LET
    (55) type -> . VAR
    (64) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (65) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (87) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (88) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (89) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (90) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (91) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (92) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (66) map -> . iniciarMap
    (67) map -> . escribirMap
    (68) map -> . generarMap
    (20) while -> . WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (21) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (31) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (22) if -> . soloIf
    (23) if -> . soloIf elseIf
    (24) if -> . soloIf elseIf else
    (25) if -> . soloIf else
    (69) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (70) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (76) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (26) soloIf -> . IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    NAME            shift and go to state 10
    CONST           shift and go to state 17
    LET             shift and go to state 18
    VAR             shift and go to state 19
    WHILE           shift and go to state 23
    FOR             shift and go to state 24
    IF              shift and go to state 26

    expression                     shift and go to state 229
    soloIf                         shift and go to state 25
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    methodsSet                     shift and go to state 5
    mapFunctions                   shift and go to state 6
    arrayFn                        shift and go to state 7
    declaration                    shift and go to state 8
    type                           shift and go to state 9
    array                          shift and go to state 11
    set                            shift and go to state 12
    map                            shift and go to state 13
    while                          shift and go to state 14
    for                            shift and go to state 15
    if                             shift and go to state 16
    iniciarMap                     shift and go to state 20
    escribirMap                    shift and go to state 21
    generarMap                     shift and go to state 22

state 199

    (26) soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression . CLOSE_BRACE

    CLOSE_BRACE     shift and go to state 230


state 200

    (69) iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .

    NAME            reduce using rule 69 (iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    CONST           reduce using rule 69 (iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    LET             reduce using rule 69 (iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    VAR             reduce using rule 69 (iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    WHILE           reduce using rule 69 (iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    FOR             reduce using rule 69 (iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    IF              reduce using rule 69 (iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    $end            reduce using rule 69 (iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 69 (iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    COMMA           reduce using rule 69 (iniciarMap -> variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)


state 201

    (72) claveValor -> clave COLON valor COMMA . claveValor
    (71) claveValor -> . clave COLON valor
    (72) claveValor -> . clave COLON valor COMMA claveValor
    (73) clave -> . datatype
    (44) datatype -> . NUMBER
    (45) datatype -> . STRING
    (46) datatype -> . CHAR

    NUMBER          shift and go to state 80
    STRING          shift and go to state 81
    CHAR            shift and go to state 50

    clave                          shift and go to state 76
    claveValor                     shift and go to state 231
    datatype                       shift and go to state 78

state 202

    (64) array -> type NAME . IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (65) array -> type NAME . IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (87) set -> type NAME . IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (88) set -> type NAME . IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (89) set -> type NAME . IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (11) variable -> type NAME . IGUAL datatype SEMICOLON
    (12) variable -> type NAME . IGUAL operations SEMICOLON

    IGUAL           shift and go to state 232


state 203

    (90) set -> NAME IGUAL . NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (91) set -> NAME IGUAL . NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (92) set -> NAME IGUAL . NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (13) variable -> NAME IGUAL . datatype SEMICOLON
    (44) datatype -> . NUMBER
    (45) datatype -> . STRING
    (46) datatype -> . CHAR

    NEW             shift and go to state 47
    NUMBER          shift and go to state 80
    STRING          shift and go to state 81
    CHAR            shift and go to state 50

    datatype                       shift and go to state 45

state 204

    (80) tupla -> OPEN_BRACKET datatype COMMA datatype . CLOSE_BRACKET

    CLOSE_BRACKET   shift and go to state 233


state 205

    (41) operations -> NAME operand NAME operations .

    SEMICOLON       reduce using rule 41 (operations -> NAME operand NAME operations .)
    CLOSE_PARENTHESIS reduce using rule 41 (operations -> NAME operand NAME operations .)


state 206

    (34) operations -> NUMBER . operand NUMBER
    (36) operations -> NUMBER .
    (37) operations -> NUMBER . operand NAME operations
    (39) operations -> NUMBER . operand NAME
    (47) operand -> . SUMA
    (48) operand -> . RESTA
    (49) operand -> . MULTIPLICACION
    (50) operand -> . DIVISION

    SEMICOLON       reduce using rule 36 (operations -> NUMBER .)
    CLOSE_PARENTHESIS reduce using rule 36 (operations -> NUMBER .)
    SUMA            shift and go to state 122
    RESTA           shift and go to state 123
    MULTIPLICACION  shift and go to state 124
    DIVISION        shift and go to state 125

    operand                        shift and go to state 137

state 207

    (38) operations -> NAME operand NUMBER operations .

    SEMICOLON       reduce using rule 38 (operations -> NAME operand NUMBER operations .)
    CLOSE_PARENTHESIS reduce using rule 38 (operations -> NAME operand NUMBER operations .)


state 208

    (64) array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .

    NAME            reduce using rule 64 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    CONST           reduce using rule 64 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    LET             reduce using rule 64 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    VAR             reduce using rule 64 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    WHILE           reduce using rule 64 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    FOR             reduce using rule 64 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    IF              reduce using rule 64 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    $end            reduce using rule 64 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    CLOSE_BRACE     reduce using rule 64 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    COMMA           reduce using rule 64 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)


state 209

    (99) numeros -> NUMBER COMMA numeros .

    CLOSE_BRACKET   reduce using rule 99 (numeros -> NUMBER COMMA numeros .)
    CLOSE_PARENTHESIS reduce using rule 99 (numeros -> NUMBER COMMA numeros .)


state 210

    (101) cadena -> STRING COMMA cadena .

    CLOSE_BRACKET   reduce using rule 101 (cadena -> STRING COMMA cadena .)
    CLOSE_PARENTHESIS reduce using rule 101 (cadena -> STRING COMMA cadena .)


state 211

    (65) array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items . CLOSE_PARENTHESIS SEMICOLON

    CLOSE_PARENTHESIS shift and go to state 234


state 212

    (87) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 235


state 213

    (88) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET . items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (96) items -> . numeros
    (97) items -> . cadena
    (98) numeros -> . NUMBER
    (99) numeros -> . NUMBER COMMA numeros
    (100) cadena -> . STRING
    (101) cadena -> . STRING COMMA cadena

    NUMBER          shift and go to state 131
    STRING          shift and go to state 132

    items                          shift and go to state 236
    numeros                        shift and go to state 129
    cadena                         shift and go to state 130

state 214

    (89) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element . CLOSE_PARENTHESIS SEMICOLON

    CLOSE_PARENTHESIS shift and go to state 237


state 215

    (42) operations -> OPEN_PARENTHESIS NAME operand NAME . CLOSE_PARENTHESIS operand operations

    CLOSE_PARENTHESIS shift and go to state 238


state 216

    (43) operations -> OPEN_PARENTHESIS NUMBER operand NUMBER . CLOSE_PARENTHESIS operand operations

    CLOSE_PARENTHESIS shift and go to state 239


state 217

    (37) operations -> NUMBER operand NAME operations .

    SEMICOLON       reduce using rule 37 (operations -> NUMBER operand NAME operations .)
    CLOSE_PARENTHESIS reduce using rule 37 (operations -> NUMBER operand NAME operations .)


state 218

    (90) set -> NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .

    NAME            reduce using rule 90 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    CONST           reduce using rule 90 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    LET             reduce using rule 90 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    VAR             reduce using rule 90 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    WHILE           reduce using rule 90 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    FOR             reduce using rule 90 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    IF              reduce using rule 90 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    $end            reduce using rule 90 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 90 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    COMMA           reduce using rule 90 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)


state 219

    (91) set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items . CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON

    CLOSE_BRACKET   shift and go to state 240


state 220

    (92) set -> NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 241


state 221

    (93) methodsSet -> NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .

    $end            reduce using rule 93 (methodsSet -> NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 93 (methodsSet -> NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)


state 222

    (94) methodsSet -> NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .

    $end            reduce using rule 94 (methodsSet -> NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 94 (methodsSet -> NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)


state 223

    (82) mapFunctions -> NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON .

    $end            reduce using rule 82 (mapFunctions -> NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 82 (mapFunctions -> NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON .)


state 224

    (83) mapFunctions -> NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON .

    $end            reduce using rule 83 (mapFunctions -> NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 83 (mapFunctions -> NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON .)


state 225

    (20) while -> WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .

    NAME            reduce using rule 20 (while -> WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CONST           reduce using rule 20 (while -> WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    LET             reduce using rule 20 (while -> WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    VAR             reduce using rule 20 (while -> WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    WHILE           reduce using rule 20 (while -> WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    FOR             reduce using rule 20 (while -> WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    IF              reduce using rule 20 (while -> WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    $end            reduce using rule 20 (while -> WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 20 (while -> WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)


state 226

    (21) while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .

    NAME            reduce using rule 21 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CONST           reduce using rule 21 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    LET             reduce using rule 21 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    VAR             reduce using rule 21 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    WHILE           reduce using rule 21 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    FOR             reduce using rule 21 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    IF              reduce using rule 21 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    $end            reduce using rule 21 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 21 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)


state 227

    (31) for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations . CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    CLOSE_PARENTHESIS shift and go to state 242


state 228

    (111) expBoolean -> expBoolean logicalOperator expBoolean .
    (111) expBoolean -> expBoolean . logicalOperator expBoolean
    (106) logicalOperator -> . AND
    (107) logicalOperator -> . OR

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 111 (expBoolean -> expBoolean logicalOperator expBoolean .)
    AND             shift and go to state 194
    OR              shift and go to state 195

  ! AND             [ reduce using rule 111 (expBoolean -> expBoolean logicalOperator expBoolean .) ]
  ! OR              [ reduce using rule 111 (expBoolean -> expBoolean logicalOperator expBoolean .) ]

    logicalOperator                shift and go to state 193

state 229

    (27) elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression . CLOSE_BRACE
    (28) elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression . CLOSE_BRACE soloIf

    CLOSE_BRACE     shift and go to state 243


state 230

    (26) soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .

    ELSEIF          reduce using rule 26 (soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    ELSE            reduce using rule 26 (soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    NAME            reduce using rule 26 (soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CONST           reduce using rule 26 (soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    LET             reduce using rule 26 (soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    VAR             reduce using rule 26 (soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    WHILE           reduce using rule 26 (soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    FOR             reduce using rule 26 (soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    IF              reduce using rule 26 (soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    $end            reduce using rule 26 (soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 26 (soloIf -> IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)


state 231

    (72) claveValor -> clave COLON valor COMMA claveValor .

    CLOSE_BRACE     reduce using rule 72 (claveValor -> clave COLON valor COMMA claveValor .)


state 232

    (64) array -> type NAME IGUAL . OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (65) array -> type NAME IGUAL . NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (87) set -> type NAME IGUAL . NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (88) set -> type NAME IGUAL . NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (89) set -> type NAME IGUAL . NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (11) variable -> type NAME IGUAL . datatype SEMICOLON
    (12) variable -> type NAME IGUAL . operations SEMICOLON
    (44) datatype -> . NUMBER
    (45) datatype -> . STRING
    (46) datatype -> . CHAR
    (34) operations -> . NUMBER operand NUMBER
    (35) operations -> . NAME
    (36) operations -> . NUMBER
    (37) operations -> . NUMBER operand NAME operations
    (38) operations -> . NAME operand NUMBER operations
    (39) operations -> . NUMBER operand NAME
    (40) operations -> . NAME operand NUMBER
    (41) operations -> . NAME operand NAME operations
    (42) operations -> . OPEN_PARENTHESIS NAME operand NAME CLOSE_PARENTHESIS operand operations
    (43) operations -> . OPEN_PARENTHESIS NUMBER operand NUMBER CLOSE_PARENTHESIS operand operations

    OPEN_BRACKET    shift and go to state 85
    NEW             shift and go to state 86
    NUMBER          shift and go to state 88
    STRING          shift and go to state 81
    CHAR            shift and go to state 50
    NAME            shift and go to state 82
    OPEN_PARENTHESIS shift and go to state 87

    datatype                       shift and go to state 83
    operations                     shift and go to state 84

state 233

    (80) tupla -> OPEN_BRACKET datatype COMMA datatype CLOSE_BRACKET .

    COMMA           reduce using rule 80 (tupla -> OPEN_BRACKET datatype COMMA datatype CLOSE_BRACKET .)
    CLOSE_BRACE     reduce using rule 80 (tupla -> OPEN_BRACKET datatype COMMA datatype CLOSE_BRACKET .)


state 234

    (65) array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 244


state 235

    (87) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .

    NAME            reduce using rule 87 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    CONST           reduce using rule 87 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    LET             reduce using rule 87 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    VAR             reduce using rule 87 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    WHILE           reduce using rule 87 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    FOR             reduce using rule 87 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    IF              reduce using rule 87 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    $end            reduce using rule 87 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 87 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)
    COMMA           reduce using rule 87 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON .)


state 236

    (88) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items . CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON

    CLOSE_BRACKET   shift and go to state 245


state 237

    (89) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 246


state 238

    (42) operations -> OPEN_PARENTHESIS NAME operand NAME CLOSE_PARENTHESIS . operand operations
    (47) operand -> . SUMA
    (48) operand -> . RESTA
    (49) operand -> . MULTIPLICACION
    (50) operand -> . DIVISION

    SUMA            shift and go to state 122
    RESTA           shift and go to state 123
    MULTIPLICACION  shift and go to state 124
    DIVISION        shift and go to state 125

    operand                        shift and go to state 247

state 239

    (43) operations -> OPEN_PARENTHESIS NUMBER operand NUMBER CLOSE_PARENTHESIS . operand operations
    (47) operand -> . SUMA
    (48) operand -> . RESTA
    (49) operand -> . MULTIPLICACION
    (50) operand -> . DIVISION

    SUMA            shift and go to state 122
    RESTA           shift and go to state 123
    MULTIPLICACION  shift and go to state 124
    DIVISION        shift and go to state 125

    operand                        shift and go to state 248

state 240

    (91) set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET . CLOSE_PARENTHESIS SEMICOLON

    CLOSE_PARENTHESIS shift and go to state 249


state 241

    (92) set -> NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .

    NAME            reduce using rule 92 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    CONST           reduce using rule 92 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    LET             reduce using rule 92 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    VAR             reduce using rule 92 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    WHILE           reduce using rule 92 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    FOR             reduce using rule 92 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    IF              reduce using rule 92 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    $end            reduce using rule 92 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 92 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    COMMA           reduce using rule 92 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)


state 242

    (31) for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS . OPEN_BRACE expression CLOSE_BRACE

    OPEN_BRACE      shift and go to state 250


state 243

    (27) elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .
    (28) elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE . soloIf
    (26) soloIf -> . IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

  ! shift/reduce conflict for IF resolved as shift
    ELSE            reduce using rule 27 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    NAME            reduce using rule 27 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CONST           reduce using rule 27 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    LET             reduce using rule 27 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    VAR             reduce using rule 27 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    WHILE           reduce using rule 27 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    FOR             reduce using rule 27 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    $end            reduce using rule 27 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 27 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    IF              shift and go to state 26

  ! IF              [ reduce using rule 27 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .) ]

    soloIf                         shift and go to state 251

state 244

    (65) array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .

    NAME            reduce using rule 65 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    CONST           reduce using rule 65 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    LET             reduce using rule 65 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    VAR             reduce using rule 65 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    WHILE           reduce using rule 65 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    FOR             reduce using rule 65 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    IF              reduce using rule 65 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    $end            reduce using rule 65 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 65 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    COMMA           reduce using rule 65 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)


state 245

    (88) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET . CLOSE_PARENTHESIS SEMICOLON

    CLOSE_PARENTHESIS shift and go to state 252


state 246

    (89) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .

    NAME            reduce using rule 89 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    CONST           reduce using rule 89 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    LET             reduce using rule 89 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    VAR             reduce using rule 89 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    WHILE           reduce using rule 89 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    FOR             reduce using rule 89 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    IF              reduce using rule 89 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    $end            reduce using rule 89 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 89 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)
    COMMA           reduce using rule 89 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON .)


state 247

    (42) operations -> OPEN_PARENTHESIS NAME operand NAME CLOSE_PARENTHESIS operand . operations
    (34) operations -> . NUMBER operand NUMBER
    (35) operations -> . NAME
    (36) operations -> . NUMBER
    (37) operations -> . NUMBER operand NAME operations
    (38) operations -> . NAME operand NUMBER operations
    (39) operations -> . NUMBER operand NAME
    (40) operations -> . NAME operand NUMBER
    (41) operations -> . NAME operand NAME operations
    (42) operations -> . OPEN_PARENTHESIS NAME operand NAME CLOSE_PARENTHESIS operand operations
    (43) operations -> . OPEN_PARENTHESIS NUMBER operand NUMBER CLOSE_PARENTHESIS operand operations

    NUMBER          shift and go to state 206
    NAME            shift and go to state 82
    OPEN_PARENTHESIS shift and go to state 87

    operations                     shift and go to state 253

state 248

    (43) operations -> OPEN_PARENTHESIS NUMBER operand NUMBER CLOSE_PARENTHESIS operand . operations
    (34) operations -> . NUMBER operand NUMBER
    (35) operations -> . NAME
    (36) operations -> . NUMBER
    (37) operations -> . NUMBER operand NAME operations
    (38) operations -> . NAME operand NUMBER operations
    (39) operations -> . NUMBER operand NAME
    (40) operations -> . NAME operand NUMBER
    (41) operations -> . NAME operand NAME operations
    (42) operations -> . OPEN_PARENTHESIS NAME operand NAME CLOSE_PARENTHESIS operand operations
    (43) operations -> . OPEN_PARENTHESIS NUMBER operand NUMBER CLOSE_PARENTHESIS operand operations

    NUMBER          shift and go to state 206
    NAME            shift and go to state 82
    OPEN_PARENTHESIS shift and go to state 87

    operations                     shift and go to state 254

state 249

    (91) set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 255


state 250

    (31) for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE . expression CLOSE_BRACE
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) expression -> . methodsSet
    (8) expression -> . mapFunctions
    (9) expression -> . arrayFn
    (10) expression -> . declaration
    (11) variable -> . type NAME IGUAL datatype SEMICOLON
    (12) variable -> . type NAME IGUAL operations SEMICOLON
    (13) variable -> . NAME IGUAL datatype SEMICOLON
    (17) dataStruct -> . array
    (18) dataStruct -> . set
    (19) dataStruct -> . map
    (14) controlStruct -> . while
    (15) controlStruct -> . for
    (16) controlStruct -> . if
    (93) methodsSet -> . NAME POINT ADD OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (94) methodsSet -> . NAME POINT DELETE OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (95) methodsSet -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (81) mapFunctions -> . NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (82) mapFunctions -> . NAME POINT GET OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (83) mapFunctions -> . NAME POINT HAS OPEN_PARENTHESIS clave CLOSE_PARENTHESIS SEMICOLON
    (84) arrayFn -> . NAME POINT POP OPEN_PARENTHESIS CLOSE_PARENTHESIS
    (85) arrayFn -> . NAME POINT PUSH OPEN_PARENTHESIS element CLOSE_PARENTHESIS
    (86) arrayFn -> . NAME POINT UNSHIFT OPEN_PARENTHESIS element CLOSE_PARENTHESIS
    (105) declaration -> . NAME IGUAL element SEMICOLON
    (53) type -> . CONST
    (54) type -> . LET
    (55) type -> . VAR
    (64) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (65) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (87) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (88) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (89) set -> . type NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (90) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (91) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON
    (92) set -> . NAME IGUAL NEW SET OPEN_PARENTHESIS element CLOSE_PARENTHESIS SEMICOLON
    (66) map -> . iniciarMap
    (67) map -> . escribirMap
    (68) map -> . generarMap
    (20) while -> . WHILE OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (21) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (31) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (22) if -> . soloIf
    (23) if -> . soloIf elseIf
    (24) if -> . soloIf elseIf else
    (25) if -> . soloIf else
    (69) iniciarMap -> . variable IGUAL NEW MAP OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON
    (70) escribirMap -> . variable IGUAL OPEN_BRACE claveValor CLOSE_BRACE
    (76) generarMap -> . variable IGUAL OPEN_BRACE tuplas CLOSE_BRACE
    (26) soloIf -> . IF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    NAME            shift and go to state 10
    CONST           shift and go to state 17
    LET             shift and go to state 18
    VAR             shift and go to state 19
    WHILE           shift and go to state 23
    FOR             shift and go to state 24
    IF              shift and go to state 26

    expression                     shift and go to state 256
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    methodsSet                     shift and go to state 5
    mapFunctions                   shift and go to state 6
    arrayFn                        shift and go to state 7
    declaration                    shift and go to state 8
    type                           shift and go to state 9
    array                          shift and go to state 11
    set                            shift and go to state 12
    map                            shift and go to state 13
    while                          shift and go to state 14
    for                            shift and go to state 15
    if                             shift and go to state 16
    iniciarMap                     shift and go to state 20
    escribirMap                    shift and go to state 21
    generarMap                     shift and go to state 22
    soloIf                         shift and go to state 25

state 251

    (28) elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .

    ELSE            reduce using rule 28 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .)
    NAME            reduce using rule 28 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .)
    CONST           reduce using rule 28 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .)
    LET             reduce using rule 28 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .)
    VAR             reduce using rule 28 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .)
    WHILE           reduce using rule 28 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .)
    FOR             reduce using rule 28 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .)
    IF              reduce using rule 28 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .)
    $end            reduce using rule 28 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .)
    CLOSE_BRACE     reduce using rule 28 (elseIf -> ELSEIF OPEN_PARENTHESIS controlArg CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE soloIf .)


state 252

    (88) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 257


state 253

    (42) operations -> OPEN_PARENTHESIS NAME operand NAME CLOSE_PARENTHESIS operand operations .

    SEMICOLON       reduce using rule 42 (operations -> OPEN_PARENTHESIS NAME operand NAME CLOSE_PARENTHESIS operand operations .)
    CLOSE_PARENTHESIS reduce using rule 42 (operations -> OPEN_PARENTHESIS NAME operand NAME CLOSE_PARENTHESIS operand operations .)


state 254

    (43) operations -> OPEN_PARENTHESIS NUMBER operand NUMBER CLOSE_PARENTHESIS operand operations .

    SEMICOLON       reduce using rule 43 (operations -> OPEN_PARENTHESIS NUMBER operand NUMBER CLOSE_PARENTHESIS operand operations .)
    CLOSE_PARENTHESIS reduce using rule 43 (operations -> OPEN_PARENTHESIS NUMBER operand NUMBER CLOSE_PARENTHESIS operand operations .)


state 255

    (91) set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .

    NAME            reduce using rule 91 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    CONST           reduce using rule 91 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    LET             reduce using rule 91 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    VAR             reduce using rule 91 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    WHILE           reduce using rule 91 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    FOR             reduce using rule 91 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    IF              reduce using rule 91 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    $end            reduce using rule 91 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 91 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    COMMA           reduce using rule 91 (set -> NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)


state 256

    (31) for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression . CLOSE_BRACE

    CLOSE_BRACE     shift and go to state 258


state 257

    (88) set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .

    NAME            reduce using rule 88 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    CONST           reduce using rule 88 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    LET             reduce using rule 88 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    VAR             reduce using rule 88 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    WHILE           reduce using rule 88 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    FOR             reduce using rule 88 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    IF              reduce using rule 88 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    $end            reduce using rule 88 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 88 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)
    COMMA           reduce using rule 88 (set -> type NAME IGUAL NEW SET OPEN_PARENTHESIS OPEN_BRACKET items CLOSE_BRACKET CLOSE_PARENTHESIS SEMICOLON .)


state 258

    (31) for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .

    NAME            reduce using rule 31 (for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CONST           reduce using rule 31 (for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    LET             reduce using rule 31 (for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    VAR             reduce using rule 31 (for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    WHILE           reduce using rule 31 (for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    FOR             reduce using rule 31 (for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    IF              reduce using rule 31 (for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    $end            reduce using rule 31 (for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 31 (for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON expBoolean SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for AND in state 196 resolved as shift
WARNING: shift/reduce conflict for OR in state 196 resolved as shift
WARNING: shift/reduce conflict for AND in state 228 resolved as shift
WARNING: shift/reduce conflict for OR in state 228 resolved as shift
WARNING: shift/reduce conflict for IF in state 243 resolved as shift
WARNING: reduce/reduce conflict in state 48 resolved using rule (datatype -> NUMBER)
WARNING: rejected rule (element -> NUMBER) in state 48
WARNING: reduce/reduce conflict in state 49 resolved using rule (datatype -> STRING)
WARNING: rejected rule (element -> STRING) in state 49
WARNING: reduce/reduce conflict in state 88 resolved using rule (operations -> NUMBER)
WARNING: rejected rule (datatype -> NUMBER) in state 88
WARNING: reduce/reduce conflict in state 185 resolved using rule (mapFunctions -> NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON)
WARNING: rejected rule (methodsSet -> NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON) in state 185
WARNING: Rule (methodsSet -> NAME POINT CLEAR OPEN_PARENTHESIS CLOSE_PARENTHESIS SEMICOLON) is never reduced
