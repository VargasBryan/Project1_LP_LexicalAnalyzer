Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    BACKSLASH
    BOOLEAN
    BREAK
    CASE
    CLASS
    COLON
    COMMENTS
    DEFAULT
    DIVIGUAL
    DOUBLE_QUOTES
    ELSE
    FLOAT
    FUNCTION
    IF
    INT
    LENGTH
    LINE_BREAK
    LONGCOMMENT
    MAP
    MASIGUAL
    MENOSIGUAL
    MODIGUAL
    NOT
    NULL
    OR
    POINT
    PORIGUAL
    POTIGUAL
    RETURN
    SET
    SINGLE_QUOTE
    STATIC
    SWITCH
    THEN
    TOSTRING
    TYPEOF
    UNDEFINED

Grammar

Rule 0     S' -> expression
Rule 1     expression -> variable
Rule 2     expression -> variable expression
Rule 3     expression -> dataStruct
Rule 4     expression -> dataStruct expression
Rule 5     expression -> controlStruct
Rule 6     expression -> controlStruct expression
Rule 7     variable -> type NAME IGUAL datatype SEMICOLON
Rule 8     controlStruct -> while
Rule 9     controlStruct -> for
Rule 10    dataStruct -> array
Rule 11    while -> WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
Rule 12    while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
Rule 13    for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
Rule 14    inicialization -> type NAME IGUAL NUMBER
Rule 15    inicialization -> NAME IGUAL NUMBER
Rule 16    condition -> NAME clause value
Rule 17    operations -> NUMBER operand NUMBER
Rule 18    operations -> NAME SUMA SUMA
Rule 19    operations -> NAME RESTA RESTA
Rule 20    datatype -> NUMBER
Rule 21    datatype -> STRING
Rule 22    datatype -> operations
Rule 23    datatype -> CHAR
Rule 24    operand -> SUMA
Rule 25    operand -> RESTA
Rule 26    operand -> MULTIPLICACION
Rule 27    operand -> DIVISION
Rule 28    bool -> TRUE
Rule 29    bool -> FALSE
Rule 30    type -> CONST
Rule 31    type -> LET
Rule 32    type -> VAR
Rule 33    clause -> IGUALIGUAL
Rule 34    clause -> DIFERENTE
Rule 35    clause -> MAYORQUE
Rule 36    clause -> MAYORIGUALQUE
Rule 37    clause -> MENORQUE
Rule 38    clause -> MENORIGUALQUE
Rule 39    value -> NAME
Rule 40    value -> NUMBER
Rule 41    array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
Rule 42    array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
Rule 43    items -> numeros
Rule 44    items -> cadena
Rule 45    numeros -> NUMBER
Rule 46    numeros -> NUMBER COMMA numeros
Rule 47    cadena -> STRING
Rule 48    cadena -> STRING COMMA cadena

Terminals, with rules where they appear

AND                  : 
ARRAY                : 42
BACKSLASH            : 
BOOLEAN              : 
BREAK                : 
CASE                 : 
CHAR                 : 23
CLASS                : 
CLOSE_BRACE          : 11 12 13
CLOSE_BRACKET        : 41
CLOSE_PARENTHESIS    : 11 12 13 42
COLON                : 
COMMA                : 46 48
COMMENTS             : 
CONST                : 30
DEFAULT              : 
DIFERENTE            : 34
DIVIGUAL             : 
DIVISION             : 27
DOUBLE_QUOTES        : 
ELSE                 : 
FALSE                : 29
FLOAT                : 
FOR                  : 13
FUNCTION             : 
IF                   : 
IGUAL                : 7 14 15 41 42
IGUALIGUAL           : 33
INT                  : 
LENGTH               : 
LET                  : 31
LINE_BREAK           : 
LONGCOMMENT          : 
MAP                  : 
MASIGUAL             : 
MAYORIGUALQUE        : 36
MAYORQUE             : 35
MENORIGUALQUE        : 38
MENORQUE             : 37
MENOSIGUAL           : 
MODIGUAL             : 
MULTIPLICACION       : 26
NAME                 : 7 14 15 16 18 19 39 41 42
NEW                  : 42
NOT                  : 
NULL                 : 
NUMBER               : 14 15 17 17 20 40 45 46
OPEN_BRACE           : 11 12 13
OPEN_BRACKET         : 41
OPEN_PARENTHESIS     : 11 12 13 42
OR                   : 
POINT                : 
PORIGUAL             : 
POTIGUAL             : 
RESTA                : 19 19 25
RETURN               : 
SEMICOLON            : 7 13 13 41 42
SET                  : 
SINGLE_QUOTE         : 
STATIC               : 
STRING               : 21 47 48
SUMA                 : 18 18 24
SWITCH               : 
THEN                 : 
TOSTRING             : 
TRUE                 : 28
TYPEOF               : 
UNDEFINED            : 
VAR                  : 32
WHILE                : 11 12
error                : 

Nonterminals, with rules where they appear

array                : 10
bool                 : 12
cadena               : 44 48
clause               : 16
condition            : 13
controlStruct        : 5 6
dataStruct           : 3 4
datatype             : 7
expression           : 2 4 6 11 11 12 13 0
for                  : 9
inicialization       : 13
items                : 41 42
numeros              : 43 46
operand              : 17
operations           : 13 22
type                 : 7 14 41 42
value                : 16
variable             : 1 2
while                : 8

Parsing method: LALR

state 0

    (0) S' -> . expression
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) variable -> . type NAME IGUAL datatype SEMICOLON
    (10) dataStruct -> . array
    (8) controlStruct -> . while
    (9) controlStruct -> . for
    (30) type -> . CONST
    (31) type -> . LET
    (32) type -> . VAR
    (41) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (42) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (11) while -> . WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (12) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (13) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    CONST           shift and go to state 9
    LET             shift and go to state 10
    VAR             shift and go to state 11
    WHILE           shift and go to state 12
    FOR             shift and go to state 13

    expression                     shift and go to state 1
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    type                           shift and go to state 5
    array                          shift and go to state 6
    while                          shift and go to state 7
    for                            shift and go to state 8

state 1

    (0) S' -> expression .



state 2

    (1) expression -> variable .
    (2) expression -> variable . expression
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) variable -> . type NAME IGUAL datatype SEMICOLON
    (10) dataStruct -> . array
    (8) controlStruct -> . while
    (9) controlStruct -> . for
    (30) type -> . CONST
    (31) type -> . LET
    (32) type -> . VAR
    (41) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (42) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (11) while -> . WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (12) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (13) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    $end            reduce using rule 1 (expression -> variable .)
    CLOSE_PARENTHESIS reduce using rule 1 (expression -> variable .)
    CLOSE_BRACE     reduce using rule 1 (expression -> variable .)
    CONST           shift and go to state 9
    LET             shift and go to state 10
    VAR             shift and go to state 11
    WHILE           shift and go to state 12
    FOR             shift and go to state 13

    variable                       shift and go to state 2
    expression                     shift and go to state 14
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    type                           shift and go to state 5
    array                          shift and go to state 6
    while                          shift and go to state 7
    for                            shift and go to state 8

state 3

    (3) expression -> dataStruct .
    (4) expression -> dataStruct . expression
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) variable -> . type NAME IGUAL datatype SEMICOLON
    (10) dataStruct -> . array
    (8) controlStruct -> . while
    (9) controlStruct -> . for
    (30) type -> . CONST
    (31) type -> . LET
    (32) type -> . VAR
    (41) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (42) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (11) while -> . WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (12) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (13) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    $end            reduce using rule 3 (expression -> dataStruct .)
    CLOSE_PARENTHESIS reduce using rule 3 (expression -> dataStruct .)
    CLOSE_BRACE     reduce using rule 3 (expression -> dataStruct .)
    CONST           shift and go to state 9
    LET             shift and go to state 10
    VAR             shift and go to state 11
    WHILE           shift and go to state 12
    FOR             shift and go to state 13

    dataStruct                     shift and go to state 3
    expression                     shift and go to state 15
    variable                       shift and go to state 2
    controlStruct                  shift and go to state 4
    type                           shift and go to state 5
    array                          shift and go to state 6
    while                          shift and go to state 7
    for                            shift and go to state 8

state 4

    (5) expression -> controlStruct .
    (6) expression -> controlStruct . expression
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) variable -> . type NAME IGUAL datatype SEMICOLON
    (10) dataStruct -> . array
    (8) controlStruct -> . while
    (9) controlStruct -> . for
    (30) type -> . CONST
    (31) type -> . LET
    (32) type -> . VAR
    (41) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (42) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (11) while -> . WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (12) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (13) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    $end            reduce using rule 5 (expression -> controlStruct .)
    CLOSE_PARENTHESIS reduce using rule 5 (expression -> controlStruct .)
    CLOSE_BRACE     reduce using rule 5 (expression -> controlStruct .)
    CONST           shift and go to state 9
    LET             shift and go to state 10
    VAR             shift and go to state 11
    WHILE           shift and go to state 12
    FOR             shift and go to state 13

    controlStruct                  shift and go to state 4
    expression                     shift and go to state 16
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    type                           shift and go to state 5
    array                          shift and go to state 6
    while                          shift and go to state 7
    for                            shift and go to state 8

state 5

    (7) variable -> type . NAME IGUAL datatype SEMICOLON
    (41) array -> type . NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (42) array -> type . NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON

    NAME            shift and go to state 17


state 6

    (10) dataStruct -> array .

    CONST           reduce using rule 10 (dataStruct -> array .)
    LET             reduce using rule 10 (dataStruct -> array .)
    VAR             reduce using rule 10 (dataStruct -> array .)
    WHILE           reduce using rule 10 (dataStruct -> array .)
    FOR             reduce using rule 10 (dataStruct -> array .)
    $end            reduce using rule 10 (dataStruct -> array .)
    CLOSE_PARENTHESIS reduce using rule 10 (dataStruct -> array .)
    CLOSE_BRACE     reduce using rule 10 (dataStruct -> array .)


state 7

    (8) controlStruct -> while .

    CONST           reduce using rule 8 (controlStruct -> while .)
    LET             reduce using rule 8 (controlStruct -> while .)
    VAR             reduce using rule 8 (controlStruct -> while .)
    WHILE           reduce using rule 8 (controlStruct -> while .)
    FOR             reduce using rule 8 (controlStruct -> while .)
    $end            reduce using rule 8 (controlStruct -> while .)
    CLOSE_PARENTHESIS reduce using rule 8 (controlStruct -> while .)
    CLOSE_BRACE     reduce using rule 8 (controlStruct -> while .)


state 8

    (9) controlStruct -> for .

    CONST           reduce using rule 9 (controlStruct -> for .)
    LET             reduce using rule 9 (controlStruct -> for .)
    VAR             reduce using rule 9 (controlStruct -> for .)
    WHILE           reduce using rule 9 (controlStruct -> for .)
    FOR             reduce using rule 9 (controlStruct -> for .)
    $end            reduce using rule 9 (controlStruct -> for .)
    CLOSE_PARENTHESIS reduce using rule 9 (controlStruct -> for .)
    CLOSE_BRACE     reduce using rule 9 (controlStruct -> for .)


state 9

    (30) type -> CONST .

    NAME            reduce using rule 30 (type -> CONST .)


state 10

    (31) type -> LET .

    NAME            reduce using rule 31 (type -> LET .)


state 11

    (32) type -> VAR .

    NAME            reduce using rule 32 (type -> VAR .)


state 12

    (11) while -> WHILE . OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (12) while -> WHILE . OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    OPEN_PARENTHESIS shift and go to state 18


state 13

    (13) for -> FOR . OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    OPEN_PARENTHESIS shift and go to state 19


state 14

    (2) expression -> variable expression .

    $end            reduce using rule 2 (expression -> variable expression .)
    CLOSE_PARENTHESIS reduce using rule 2 (expression -> variable expression .)
    CLOSE_BRACE     reduce using rule 2 (expression -> variable expression .)


state 15

    (4) expression -> dataStruct expression .

    $end            reduce using rule 4 (expression -> dataStruct expression .)
    CLOSE_PARENTHESIS reduce using rule 4 (expression -> dataStruct expression .)
    CLOSE_BRACE     reduce using rule 4 (expression -> dataStruct expression .)


state 16

    (6) expression -> controlStruct expression .

    $end            reduce using rule 6 (expression -> controlStruct expression .)
    CLOSE_PARENTHESIS reduce using rule 6 (expression -> controlStruct expression .)
    CLOSE_BRACE     reduce using rule 6 (expression -> controlStruct expression .)


state 17

    (7) variable -> type NAME . IGUAL datatype SEMICOLON
    (41) array -> type NAME . IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (42) array -> type NAME . IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON

    IGUAL           shift and go to state 20


state 18

    (11) while -> WHILE OPEN_PARENTHESIS . expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (12) while -> WHILE OPEN_PARENTHESIS . bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (28) bool -> . TRUE
    (29) bool -> . FALSE
    (7) variable -> . type NAME IGUAL datatype SEMICOLON
    (10) dataStruct -> . array
    (8) controlStruct -> . while
    (9) controlStruct -> . for
    (30) type -> . CONST
    (31) type -> . LET
    (32) type -> . VAR
    (41) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (42) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (11) while -> . WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (12) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (13) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    TRUE            shift and go to state 23
    FALSE           shift and go to state 24
    CONST           shift and go to state 9
    LET             shift and go to state 10
    VAR             shift and go to state 11
    WHILE           shift and go to state 12
    FOR             shift and go to state 13

    expression                     shift and go to state 21
    bool                           shift and go to state 22
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    type                           shift and go to state 5
    array                          shift and go to state 6
    while                          shift and go to state 7
    for                            shift and go to state 8

state 19

    (13) for -> FOR OPEN_PARENTHESIS . inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (14) inicialization -> . type NAME IGUAL NUMBER
    (15) inicialization -> . NAME IGUAL NUMBER
    (30) type -> . CONST
    (31) type -> . LET
    (32) type -> . VAR

    NAME            shift and go to state 27
    CONST           shift and go to state 9
    LET             shift and go to state 10
    VAR             shift and go to state 11

    inicialization                 shift and go to state 25
    type                           shift and go to state 26

state 20

    (7) variable -> type NAME IGUAL . datatype SEMICOLON
    (41) array -> type NAME IGUAL . OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (42) array -> type NAME IGUAL . NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (20) datatype -> . NUMBER
    (21) datatype -> . STRING
    (22) datatype -> . operations
    (23) datatype -> . CHAR
    (17) operations -> . NUMBER operand NUMBER
    (18) operations -> . NAME SUMA SUMA
    (19) operations -> . NAME RESTA RESTA

    OPEN_BRACKET    shift and go to state 30
    NEW             shift and go to state 31
    NUMBER          shift and go to state 32
    STRING          shift and go to state 33
    CHAR            shift and go to state 35
    NAME            shift and go to state 28

    datatype                       shift and go to state 29
    operations                     shift and go to state 34

state 21

    (11) while -> WHILE OPEN_PARENTHESIS expression . CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    CLOSE_PARENTHESIS shift and go to state 36


state 22

    (12) while -> WHILE OPEN_PARENTHESIS bool . CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    CLOSE_PARENTHESIS shift and go to state 37


state 23

    (28) bool -> TRUE .

    CLOSE_PARENTHESIS reduce using rule 28 (bool -> TRUE .)


state 24

    (29) bool -> FALSE .

    CLOSE_PARENTHESIS reduce using rule 29 (bool -> FALSE .)


state 25

    (13) for -> FOR OPEN_PARENTHESIS inicialization . SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    SEMICOLON       shift and go to state 38


state 26

    (14) inicialization -> type . NAME IGUAL NUMBER

    NAME            shift and go to state 39


state 27

    (15) inicialization -> NAME . IGUAL NUMBER

    IGUAL           shift and go to state 40


state 28

    (18) operations -> NAME . SUMA SUMA
    (19) operations -> NAME . RESTA RESTA

    SUMA            shift and go to state 41
    RESTA           shift and go to state 42


state 29

    (7) variable -> type NAME IGUAL datatype . SEMICOLON

    SEMICOLON       shift and go to state 43


state 30

    (41) array -> type NAME IGUAL OPEN_BRACKET . items CLOSE_BRACKET SEMICOLON
    (43) items -> . numeros
    (44) items -> . cadena
    (45) numeros -> . NUMBER
    (46) numeros -> . NUMBER COMMA numeros
    (47) cadena -> . STRING
    (48) cadena -> . STRING COMMA cadena

    NUMBER          shift and go to state 47
    STRING          shift and go to state 48

    items                          shift and go to state 44
    numeros                        shift and go to state 45
    cadena                         shift and go to state 46

state 31

    (42) array -> type NAME IGUAL NEW . ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON

    ARRAY           shift and go to state 49


state 32

    (20) datatype -> NUMBER .
    (17) operations -> NUMBER . operand NUMBER
    (24) operand -> . SUMA
    (25) operand -> . RESTA
    (26) operand -> . MULTIPLICACION
    (27) operand -> . DIVISION

    SEMICOLON       reduce using rule 20 (datatype -> NUMBER .)
    SUMA            shift and go to state 51
    RESTA           shift and go to state 52
    MULTIPLICACION  shift and go to state 53
    DIVISION        shift and go to state 54

    operand                        shift and go to state 50

state 33

    (21) datatype -> STRING .

    SEMICOLON       reduce using rule 21 (datatype -> STRING .)


state 34

    (22) datatype -> operations .

    SEMICOLON       reduce using rule 22 (datatype -> operations .)


state 35

    (23) datatype -> CHAR .

    SEMICOLON       reduce using rule 23 (datatype -> CHAR .)


state 36

    (11) while -> WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS . OPEN_BRACE expression CLOSE_BRACE

    OPEN_BRACE      shift and go to state 55


state 37

    (12) while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS . OPEN_BRACE expression CLOSE_BRACE

    OPEN_BRACE      shift and go to state 56


state 38

    (13) for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON . condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (16) condition -> . NAME clause value

    NAME            shift and go to state 58

    condition                      shift and go to state 57

state 39

    (14) inicialization -> type NAME . IGUAL NUMBER

    IGUAL           shift and go to state 59


state 40

    (15) inicialization -> NAME IGUAL . NUMBER

    NUMBER          shift and go to state 60


state 41

    (18) operations -> NAME SUMA . SUMA

    SUMA            shift and go to state 61


state 42

    (19) operations -> NAME RESTA . RESTA

    RESTA           shift and go to state 62


state 43

    (7) variable -> type NAME IGUAL datatype SEMICOLON .

    CONST           reduce using rule 7 (variable -> type NAME IGUAL datatype SEMICOLON .)
    LET             reduce using rule 7 (variable -> type NAME IGUAL datatype SEMICOLON .)
    VAR             reduce using rule 7 (variable -> type NAME IGUAL datatype SEMICOLON .)
    WHILE           reduce using rule 7 (variable -> type NAME IGUAL datatype SEMICOLON .)
    FOR             reduce using rule 7 (variable -> type NAME IGUAL datatype SEMICOLON .)
    $end            reduce using rule 7 (variable -> type NAME IGUAL datatype SEMICOLON .)
    CLOSE_PARENTHESIS reduce using rule 7 (variable -> type NAME IGUAL datatype SEMICOLON .)
    CLOSE_BRACE     reduce using rule 7 (variable -> type NAME IGUAL datatype SEMICOLON .)


state 44

    (41) array -> type NAME IGUAL OPEN_BRACKET items . CLOSE_BRACKET SEMICOLON

    CLOSE_BRACKET   shift and go to state 63


state 45

    (43) items -> numeros .

    CLOSE_BRACKET   reduce using rule 43 (items -> numeros .)
    CLOSE_PARENTHESIS reduce using rule 43 (items -> numeros .)


state 46

    (44) items -> cadena .

    CLOSE_BRACKET   reduce using rule 44 (items -> cadena .)
    CLOSE_PARENTHESIS reduce using rule 44 (items -> cadena .)


state 47

    (45) numeros -> NUMBER .
    (46) numeros -> NUMBER . COMMA numeros

    CLOSE_BRACKET   reduce using rule 45 (numeros -> NUMBER .)
    CLOSE_PARENTHESIS reduce using rule 45 (numeros -> NUMBER .)
    COMMA           shift and go to state 64


state 48

    (47) cadena -> STRING .
    (48) cadena -> STRING . COMMA cadena

    CLOSE_BRACKET   reduce using rule 47 (cadena -> STRING .)
    CLOSE_PARENTHESIS reduce using rule 47 (cadena -> STRING .)
    COMMA           shift and go to state 65


state 49

    (42) array -> type NAME IGUAL NEW ARRAY . OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON

    OPEN_PARENTHESIS shift and go to state 66


state 50

    (17) operations -> NUMBER operand . NUMBER

    NUMBER          shift and go to state 67


state 51

    (24) operand -> SUMA .

    NUMBER          reduce using rule 24 (operand -> SUMA .)


state 52

    (25) operand -> RESTA .

    NUMBER          reduce using rule 25 (operand -> RESTA .)


state 53

    (26) operand -> MULTIPLICACION .

    NUMBER          reduce using rule 26 (operand -> MULTIPLICACION .)


state 54

    (27) operand -> DIVISION .

    NUMBER          reduce using rule 27 (operand -> DIVISION .)


state 55

    (11) while -> WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE . expression CLOSE_BRACE
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) variable -> . type NAME IGUAL datatype SEMICOLON
    (10) dataStruct -> . array
    (8) controlStruct -> . while
    (9) controlStruct -> . for
    (30) type -> . CONST
    (31) type -> . LET
    (32) type -> . VAR
    (41) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (42) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (11) while -> . WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (12) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (13) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    CONST           shift and go to state 9
    LET             shift and go to state 10
    VAR             shift and go to state 11
    WHILE           shift and go to state 12
    FOR             shift and go to state 13

    expression                     shift and go to state 68
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    type                           shift and go to state 5
    array                          shift and go to state 6
    while                          shift and go to state 7
    for                            shift and go to state 8

state 56

    (12) while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE . expression CLOSE_BRACE
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) variable -> . type NAME IGUAL datatype SEMICOLON
    (10) dataStruct -> . array
    (8) controlStruct -> . while
    (9) controlStruct -> . for
    (30) type -> . CONST
    (31) type -> . LET
    (32) type -> . VAR
    (41) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (42) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (11) while -> . WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (12) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (13) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    CONST           shift and go to state 9
    LET             shift and go to state 10
    VAR             shift and go to state 11
    WHILE           shift and go to state 12
    FOR             shift and go to state 13

    expression                     shift and go to state 69
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    type                           shift and go to state 5
    array                          shift and go to state 6
    while                          shift and go to state 7
    for                            shift and go to state 8

state 57

    (13) for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition . SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    SEMICOLON       shift and go to state 70


state 58

    (16) condition -> NAME . clause value
    (33) clause -> . IGUALIGUAL
    (34) clause -> . DIFERENTE
    (35) clause -> . MAYORQUE
    (36) clause -> . MAYORIGUALQUE
    (37) clause -> . MENORQUE
    (38) clause -> . MENORIGUALQUE

    IGUALIGUAL      shift and go to state 72
    DIFERENTE       shift and go to state 73
    MAYORQUE        shift and go to state 74
    MAYORIGUALQUE   shift and go to state 75
    MENORQUE        shift and go to state 76
    MENORIGUALQUE   shift and go to state 77

    clause                         shift and go to state 71

state 59

    (14) inicialization -> type NAME IGUAL . NUMBER

    NUMBER          shift and go to state 78


state 60

    (15) inicialization -> NAME IGUAL NUMBER .

    SEMICOLON       reduce using rule 15 (inicialization -> NAME IGUAL NUMBER .)


state 61

    (18) operations -> NAME SUMA SUMA .

    SEMICOLON       reduce using rule 18 (operations -> NAME SUMA SUMA .)
    CLOSE_PARENTHESIS reduce using rule 18 (operations -> NAME SUMA SUMA .)


state 62

    (19) operations -> NAME RESTA RESTA .

    SEMICOLON       reduce using rule 19 (operations -> NAME RESTA RESTA .)
    CLOSE_PARENTHESIS reduce using rule 19 (operations -> NAME RESTA RESTA .)


state 63

    (41) array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET . SEMICOLON

    SEMICOLON       shift and go to state 79


state 64

    (46) numeros -> NUMBER COMMA . numeros
    (45) numeros -> . NUMBER
    (46) numeros -> . NUMBER COMMA numeros

    NUMBER          shift and go to state 47

    numeros                        shift and go to state 80

state 65

    (48) cadena -> STRING COMMA . cadena
    (47) cadena -> . STRING
    (48) cadena -> . STRING COMMA cadena

    STRING          shift and go to state 48

    cadena                         shift and go to state 81

state 66

    (42) array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS . items CLOSE_PARENTHESIS SEMICOLON
    (43) items -> . numeros
    (44) items -> . cadena
    (45) numeros -> . NUMBER
    (46) numeros -> . NUMBER COMMA numeros
    (47) cadena -> . STRING
    (48) cadena -> . STRING COMMA cadena

    NUMBER          shift and go to state 47
    STRING          shift and go to state 48

    items                          shift and go to state 82
    numeros                        shift and go to state 45
    cadena                         shift and go to state 46

state 67

    (17) operations -> NUMBER operand NUMBER .

    SEMICOLON       reduce using rule 17 (operations -> NUMBER operand NUMBER .)
    CLOSE_PARENTHESIS reduce using rule 17 (operations -> NUMBER operand NUMBER .)


state 68

    (11) while -> WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression . CLOSE_BRACE

    CLOSE_BRACE     shift and go to state 83


state 69

    (12) while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression . CLOSE_BRACE

    CLOSE_BRACE     shift and go to state 84


state 70

    (13) for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON . operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (17) operations -> . NUMBER operand NUMBER
    (18) operations -> . NAME SUMA SUMA
    (19) operations -> . NAME RESTA RESTA

    NUMBER          shift and go to state 86
    NAME            shift and go to state 28

    operations                     shift and go to state 85

state 71

    (16) condition -> NAME clause . value
    (39) value -> . NAME
    (40) value -> . NUMBER

    NAME            shift and go to state 87
    NUMBER          shift and go to state 89

    value                          shift and go to state 88

state 72

    (33) clause -> IGUALIGUAL .

    NAME            reduce using rule 33 (clause -> IGUALIGUAL .)
    NUMBER          reduce using rule 33 (clause -> IGUALIGUAL .)


state 73

    (34) clause -> DIFERENTE .

    NAME            reduce using rule 34 (clause -> DIFERENTE .)
    NUMBER          reduce using rule 34 (clause -> DIFERENTE .)


state 74

    (35) clause -> MAYORQUE .

    NAME            reduce using rule 35 (clause -> MAYORQUE .)
    NUMBER          reduce using rule 35 (clause -> MAYORQUE .)


state 75

    (36) clause -> MAYORIGUALQUE .

    NAME            reduce using rule 36 (clause -> MAYORIGUALQUE .)
    NUMBER          reduce using rule 36 (clause -> MAYORIGUALQUE .)


state 76

    (37) clause -> MENORQUE .

    NAME            reduce using rule 37 (clause -> MENORQUE .)
    NUMBER          reduce using rule 37 (clause -> MENORQUE .)


state 77

    (38) clause -> MENORIGUALQUE .

    NAME            reduce using rule 38 (clause -> MENORIGUALQUE .)
    NUMBER          reduce using rule 38 (clause -> MENORIGUALQUE .)


state 78

    (14) inicialization -> type NAME IGUAL NUMBER .

    SEMICOLON       reduce using rule 14 (inicialization -> type NAME IGUAL NUMBER .)


state 79

    (41) array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .

    CONST           reduce using rule 41 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    LET             reduce using rule 41 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    VAR             reduce using rule 41 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    WHILE           reduce using rule 41 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    FOR             reduce using rule 41 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    $end            reduce using rule 41 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    CLOSE_PARENTHESIS reduce using rule 41 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)
    CLOSE_BRACE     reduce using rule 41 (array -> type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON .)


state 80

    (46) numeros -> NUMBER COMMA numeros .

    CLOSE_BRACKET   reduce using rule 46 (numeros -> NUMBER COMMA numeros .)
    CLOSE_PARENTHESIS reduce using rule 46 (numeros -> NUMBER COMMA numeros .)


state 81

    (48) cadena -> STRING COMMA cadena .

    CLOSE_BRACKET   reduce using rule 48 (cadena -> STRING COMMA cadena .)
    CLOSE_PARENTHESIS reduce using rule 48 (cadena -> STRING COMMA cadena .)


state 82

    (42) array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items . CLOSE_PARENTHESIS SEMICOLON

    CLOSE_PARENTHESIS shift and go to state 90


state 83

    (11) while -> WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .

    CONST           reduce using rule 11 (while -> WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    LET             reduce using rule 11 (while -> WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    VAR             reduce using rule 11 (while -> WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    WHILE           reduce using rule 11 (while -> WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    FOR             reduce using rule 11 (while -> WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    $end            reduce using rule 11 (while -> WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CLOSE_PARENTHESIS reduce using rule 11 (while -> WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 11 (while -> WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)


state 84

    (12) while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .

    CONST           reduce using rule 12 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    LET             reduce using rule 12 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    VAR             reduce using rule 12 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    WHILE           reduce using rule 12 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    FOR             reduce using rule 12 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    $end            reduce using rule 12 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CLOSE_PARENTHESIS reduce using rule 12 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 12 (while -> WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)


state 85

    (13) for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations . CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    CLOSE_PARENTHESIS shift and go to state 91


state 86

    (17) operations -> NUMBER . operand NUMBER
    (24) operand -> . SUMA
    (25) operand -> . RESTA
    (26) operand -> . MULTIPLICACION
    (27) operand -> . DIVISION

    SUMA            shift and go to state 51
    RESTA           shift and go to state 52
    MULTIPLICACION  shift and go to state 53
    DIVISION        shift and go to state 54

    operand                        shift and go to state 50

state 87

    (39) value -> NAME .

    SEMICOLON       reduce using rule 39 (value -> NAME .)


state 88

    (16) condition -> NAME clause value .

    SEMICOLON       reduce using rule 16 (condition -> NAME clause value .)


state 89

    (40) value -> NUMBER .

    SEMICOLON       reduce using rule 40 (value -> NUMBER .)


state 90

    (42) array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 92


state 91

    (13) for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS . OPEN_BRACE expression CLOSE_BRACE

    OPEN_BRACE      shift and go to state 93


state 92

    (42) array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .

    CONST           reduce using rule 42 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    LET             reduce using rule 42 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    VAR             reduce using rule 42 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    WHILE           reduce using rule 42 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    FOR             reduce using rule 42 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    $end            reduce using rule 42 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_PARENTHESIS reduce using rule 42 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)
    CLOSE_BRACE     reduce using rule 42 (array -> type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON .)


state 93

    (13) for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE . expression CLOSE_BRACE
    (1) expression -> . variable
    (2) expression -> . variable expression
    (3) expression -> . dataStruct
    (4) expression -> . dataStruct expression
    (5) expression -> . controlStruct
    (6) expression -> . controlStruct expression
    (7) variable -> . type NAME IGUAL datatype SEMICOLON
    (10) dataStruct -> . array
    (8) controlStruct -> . while
    (9) controlStruct -> . for
    (30) type -> . CONST
    (31) type -> . LET
    (32) type -> . VAR
    (41) array -> . type NAME IGUAL OPEN_BRACKET items CLOSE_BRACKET SEMICOLON
    (42) array -> . type NAME IGUAL NEW ARRAY OPEN_PARENTHESIS items CLOSE_PARENTHESIS SEMICOLON
    (11) while -> . WHILE OPEN_PARENTHESIS expression CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (12) while -> . WHILE OPEN_PARENTHESIS bool CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE
    (13) for -> . FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE

    CONST           shift and go to state 9
    LET             shift and go to state 10
    VAR             shift and go to state 11
    WHILE           shift and go to state 12
    FOR             shift and go to state 13

    expression                     shift and go to state 94
    variable                       shift and go to state 2
    dataStruct                     shift and go to state 3
    controlStruct                  shift and go to state 4
    type                           shift and go to state 5
    array                          shift and go to state 6
    while                          shift and go to state 7
    for                            shift and go to state 8

state 94

    (13) for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression . CLOSE_BRACE

    CLOSE_BRACE     shift and go to state 95


state 95

    (13) for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .

    CONST           reduce using rule 13 (for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    LET             reduce using rule 13 (for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    VAR             reduce using rule 13 (for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    WHILE           reduce using rule 13 (for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    FOR             reduce using rule 13 (for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    $end            reduce using rule 13 (for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CLOSE_PARENTHESIS reduce using rule 13 (for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)
    CLOSE_BRACE     reduce using rule 13 (for -> FOR OPEN_PARENTHESIS inicialization SEMICOLON condition SEMICOLON operations CLOSE_PARENTHESIS OPEN_BRACE expression CLOSE_BRACE .)

